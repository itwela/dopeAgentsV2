module.exports = [
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://api.pinecone.io".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/BackupModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BackupModelToJSON = exports.BackupModelFromJSONTyped = exports.BackupModelFromJSON = exports.instanceOfBackupModel = exports.BackupModelMetricEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.BackupModelMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
/**
 * Check if a given object implements the BackupModel interface.
 */ function instanceOfBackupModel(value) {
    let isInstance = true;
    isInstance = isInstance && "backupId" in value;
    isInstance = isInstance && "sourceIndexName" in value;
    isInstance = isInstance && "sourceIndexId" in value;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "cloud" in value;
    isInstance = isInstance && "region" in value;
    return isInstance;
}
exports.instanceOfBackupModel = instanceOfBackupModel;
function BackupModelFromJSON(json) {
    return BackupModelFromJSONTyped(json, false);
}
exports.BackupModelFromJSON = BackupModelFromJSON;
function BackupModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'backupId': json['backup_id'],
        'sourceIndexName': json['source_index_name'],
        'sourceIndexId': json['source_index_id'],
        'name': !(0, runtime_1.exists)(json, 'name') ? undefined : json['name'],
        'description': !(0, runtime_1.exists)(json, 'description') ? undefined : json['description'],
        'status': json['status'],
        'cloud': json['cloud'],
        'region': json['region'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'metric': !(0, runtime_1.exists)(json, 'metric') ? undefined : json['metric'],
        'recordCount': !(0, runtime_1.exists)(json, 'record_count') ? undefined : json['record_count'],
        'namespaceCount': !(0, runtime_1.exists)(json, 'namespace_count') ? undefined : json['namespace_count'],
        'sizeBytes': !(0, runtime_1.exists)(json, 'size_bytes') ? undefined : json['size_bytes'],
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'createdAt': !(0, runtime_1.exists)(json, 'created_at') ? undefined : json['created_at']
    };
}
exports.BackupModelFromJSONTyped = BackupModelFromJSONTyped;
function BackupModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'backup_id': value.backupId,
        'source_index_name': value.sourceIndexName,
        'source_index_id': value.sourceIndexId,
        'name': value.name,
        'description': value.description,
        'status': value.status,
        'cloud': value.cloud,
        'region': value.region,
        'dimension': value.dimension,
        'metric': value.metric,
        'record_count': value.recordCount,
        'namespace_count': value.namespaceCount,
        'size_bytes': value.sizeBytes,
        'tags': value.tags,
        'created_at': value.createdAt
    };
}
exports.BackupModelToJSON = BackupModelToJSON; //# sourceMappingURL=BackupModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PaginationResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PaginationResponseToJSON = exports.PaginationResponseFromJSONTyped = exports.PaginationResponseFromJSON = exports.instanceOfPaginationResponse = void 0;
/**
 * Check if a given object implements the PaginationResponse interface.
 */ function instanceOfPaginationResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "next" in value;
    return isInstance;
}
exports.instanceOfPaginationResponse = instanceOfPaginationResponse;
function PaginationResponseFromJSON(json) {
    return PaginationResponseFromJSONTyped(json, false);
}
exports.PaginationResponseFromJSON = PaginationResponseFromJSON;
function PaginationResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'next': json['next']
    };
}
exports.PaginationResponseFromJSONTyped = PaginationResponseFromJSONTyped;
function PaginationResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'next': value.next
    };
}
exports.PaginationResponseToJSON = PaginationResponseToJSON; //# sourceMappingURL=PaginationResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/BackupList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BackupListToJSON = exports.BackupListFromJSONTyped = exports.BackupListFromJSON = exports.instanceOfBackupList = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const BackupModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/BackupModel.js [app-route] (ecmascript)");
const PaginationResponse_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PaginationResponse.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the BackupList interface.
 */ function instanceOfBackupList(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfBackupList = instanceOfBackupList;
function BackupListFromJSON(json) {
    return BackupListFromJSONTyped(json, false);
}
exports.BackupListFromJSON = BackupListFromJSON;
function BackupListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'data': !(0, runtime_1.exists)(json, 'data') ? undefined : json['data'].map(BackupModel_1.BackupModelFromJSON),
        'pagination': !(0, runtime_1.exists)(json, 'pagination') ? undefined : (0, PaginationResponse_1.PaginationResponseFromJSON)(json['pagination'])
    };
}
exports.BackupListFromJSONTyped = BackupListFromJSONTyped;
function BackupListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data === undefined ? undefined : value.data.map(BackupModel_1.BackupModelToJSON),
        'pagination': (0, PaginationResponse_1.PaginationResponseToJSON)(value.pagination)
    };
}
exports.BackupListToJSON = BackupListToJSON; //# sourceMappingURL=BackupList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ByocSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ByocSpecToJSON = exports.ByocSpecFromJSONTyped = exports.ByocSpecFromJSON = exports.instanceOfByocSpec = void 0;
/**
 * Check if a given object implements the ByocSpec interface.
 */ function instanceOfByocSpec(value) {
    let isInstance = true;
    isInstance = isInstance && "environment" in value;
    return isInstance;
}
exports.instanceOfByocSpec = instanceOfByocSpec;
function ByocSpecFromJSON(json) {
    return ByocSpecFromJSONTyped(json, false);
}
exports.ByocSpecFromJSON = ByocSpecFromJSON;
function ByocSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'environment': json['environment']
    };
}
exports.ByocSpecFromJSONTyped = ByocSpecFromJSONTyped;
function ByocSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'environment': value.environment
    };
}
exports.ByocSpecToJSON = ByocSpecToJSON; //# sourceMappingURL=ByocSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CollectionModelToJSON = exports.CollectionModelFromJSONTyped = exports.CollectionModelFromJSON = exports.instanceOfCollectionModel = exports.CollectionModelStatusEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.CollectionModelStatusEnum = {
    Initializing: 'Initializing',
    Ready: 'Ready',
    Terminating: 'Terminating'
};
/**
 * Check if a given object implements the CollectionModel interface.
 */ function instanceOfCollectionModel(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "environment" in value;
    return isInstance;
}
exports.instanceOfCollectionModel = instanceOfCollectionModel;
function CollectionModelFromJSON(json) {
    return CollectionModelFromJSONTyped(json, false);
}
exports.CollectionModelFromJSON = CollectionModelFromJSON;
function CollectionModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'size': !(0, runtime_1.exists)(json, 'size') ? undefined : json['size'],
        'status': json['status'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'vectorCount': !(0, runtime_1.exists)(json, 'vector_count') ? undefined : json['vector_count'],
        'environment': json['environment']
    };
}
exports.CollectionModelFromJSONTyped = CollectionModelFromJSONTyped;
function CollectionModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'size': value.size,
        'status': value.status,
        'dimension': value.dimension,
        'vector_count': value.vectorCount,
        'environment': value.environment
    };
}
exports.CollectionModelToJSON = CollectionModelToJSON; //# sourceMappingURL=CollectionModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CollectionListToJSON = exports.CollectionListFromJSONTyped = exports.CollectionListFromJSON = exports.instanceOfCollectionList = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const CollectionModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the CollectionList interface.
 */ function instanceOfCollectionList(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfCollectionList = instanceOfCollectionList;
function CollectionListFromJSON(json) {
    return CollectionListFromJSONTyped(json, false);
}
exports.CollectionListFromJSON = CollectionListFromJSON;
function CollectionListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'collections': !(0, runtime_1.exists)(json, 'collections') ? undefined : json['collections'].map(CollectionModel_1.CollectionModelFromJSON)
    };
}
exports.CollectionListFromJSONTyped = CollectionListFromJSONTyped;
function CollectionListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'collections': value.collections === undefined ? undefined : value.collections.map(CollectionModel_1.CollectionModelToJSON)
    };
}
exports.CollectionListToJSON = CollectionListToJSON; //# sourceMappingURL=CollectionList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestEmbed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigureIndexRequestEmbedToJSON = exports.ConfigureIndexRequestEmbedFromJSONTyped = exports.ConfigureIndexRequestEmbedFromJSON = exports.instanceOfConfigureIndexRequestEmbed = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ConfigureIndexRequestEmbed interface.
 */ function instanceOfConfigureIndexRequestEmbed(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfConfigureIndexRequestEmbed = instanceOfConfigureIndexRequestEmbed;
function ConfigureIndexRequestEmbedFromJSON(json) {
    return ConfigureIndexRequestEmbedFromJSONTyped(json, false);
}
exports.ConfigureIndexRequestEmbedFromJSON = ConfigureIndexRequestEmbedFromJSON;
function ConfigureIndexRequestEmbedFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model'],
        'fieldMap': !(0, runtime_1.exists)(json, 'field_map') ? undefined : json['field_map'],
        'readParameters': !(0, runtime_1.exists)(json, 'read_parameters') ? undefined : json['read_parameters'],
        'writeParameters': !(0, runtime_1.exists)(json, 'write_parameters') ? undefined : json['write_parameters']
    };
}
exports.ConfigureIndexRequestEmbedFromJSONTyped = ConfigureIndexRequestEmbedFromJSONTyped;
function ConfigureIndexRequestEmbedToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'field_map': value.fieldMap,
        'read_parameters': value.readParameters,
        'write_parameters': value.writeParameters
    };
}
exports.ConfigureIndexRequestEmbedToJSON = ConfigureIndexRequestEmbedToJSON; //# sourceMappingURL=ConfigureIndexRequestEmbed.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpecPod.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigureIndexRequestSpecPodToJSON = exports.ConfigureIndexRequestSpecPodFromJSONTyped = exports.ConfigureIndexRequestSpecPodFromJSON = exports.instanceOfConfigureIndexRequestSpecPod = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ConfigureIndexRequestSpecPod interface.
 */ function instanceOfConfigureIndexRequestSpecPod(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfConfigureIndexRequestSpecPod = instanceOfConfigureIndexRequestSpecPod;
function ConfigureIndexRequestSpecPodFromJSON(json) {
    return ConfigureIndexRequestSpecPodFromJSONTyped(json, false);
}
exports.ConfigureIndexRequestSpecPodFromJSON = ConfigureIndexRequestSpecPodFromJSON;
function ConfigureIndexRequestSpecPodFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'replicas': !(0, runtime_1.exists)(json, 'replicas') ? undefined : json['replicas'],
        'podType': !(0, runtime_1.exists)(json, 'pod_type') ? undefined : json['pod_type']
    };
}
exports.ConfigureIndexRequestSpecPodFromJSONTyped = ConfigureIndexRequestSpecPodFromJSONTyped;
function ConfigureIndexRequestSpecPodToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'replicas': value.replicas,
        'pod_type': value.podType
    };
}
exports.ConfigureIndexRequestSpecPodToJSON = ConfigureIndexRequestSpecPodToJSON; //# sourceMappingURL=ConfigureIndexRequestSpecPod.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigureIndexRequestSpecToJSON = exports.ConfigureIndexRequestSpecFromJSONTyped = exports.ConfigureIndexRequestSpecFromJSON = exports.instanceOfConfigureIndexRequestSpec = void 0;
const ConfigureIndexRequestSpecPod_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpecPod.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ConfigureIndexRequestSpec interface.
 */ function instanceOfConfigureIndexRequestSpec(value) {
    let isInstance = true;
    isInstance = isInstance && "pod" in value;
    return isInstance;
}
exports.instanceOfConfigureIndexRequestSpec = instanceOfConfigureIndexRequestSpec;
function ConfigureIndexRequestSpecFromJSON(json) {
    return ConfigureIndexRequestSpecFromJSONTyped(json, false);
}
exports.ConfigureIndexRequestSpecFromJSON = ConfigureIndexRequestSpecFromJSON;
function ConfigureIndexRequestSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'pod': (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodFromJSON)(json['pod'])
    };
}
exports.ConfigureIndexRequestSpecFromJSONTyped = ConfigureIndexRequestSpecFromJSONTyped;
function ConfigureIndexRequestSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'pod': (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodToJSON)(value.pod)
    };
}
exports.ConfigureIndexRequestSpecToJSON = ConfigureIndexRequestSpecToJSON; //# sourceMappingURL=ConfigureIndexRequestSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeletionProtectionToJSON = exports.DeletionProtectionFromJSONTyped = exports.DeletionProtectionFromJSON = exports.DeletionProtection = void 0;
/**
 * Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
 * @export
 */ exports.DeletionProtection = {
    Disabled: 'disabled',
    Enabled: 'enabled'
};
function DeletionProtectionFromJSON(json) {
    return DeletionProtectionFromJSONTyped(json, false);
}
exports.DeletionProtectionFromJSON = DeletionProtectionFromJSON;
function DeletionProtectionFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.DeletionProtectionFromJSONTyped = DeletionProtectionFromJSONTyped;
function DeletionProtectionToJSON(value) {
    return value;
}
exports.DeletionProtectionToJSON = DeletionProtectionToJSON; //# sourceMappingURL=DeletionProtection.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConfigureIndexRequestToJSON = exports.ConfigureIndexRequestFromJSONTyped = exports.ConfigureIndexRequestFromJSON = exports.instanceOfConfigureIndexRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const ConfigureIndexRequestEmbed_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestEmbed.js [app-route] (ecmascript)");
const ConfigureIndexRequestSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpec.js [app-route] (ecmascript)");
const DeletionProtection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ConfigureIndexRequest interface.
 */ function instanceOfConfigureIndexRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfConfigureIndexRequest = instanceOfConfigureIndexRequest;
function ConfigureIndexRequestFromJSON(json) {
    return ConfigureIndexRequestFromJSONTyped(json, false);
}
exports.ConfigureIndexRequestFromJSON = ConfigureIndexRequestFromJSON;
function ConfigureIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'spec': !(0, runtime_1.exists)(json, 'spec') ? undefined : (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecFromJSON)(json['spec']),
        'deletionProtection': !(0, runtime_1.exists)(json, 'deletion_protection') ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json['deletion_protection']),
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'embed': !(0, runtime_1.exists)(json, 'embed') ? undefined : (0, ConfigureIndexRequestEmbed_1.ConfigureIndexRequestEmbedFromJSON)(json['embed'])
    };
}
exports.ConfigureIndexRequestFromJSONTyped = ConfigureIndexRequestFromJSONTyped;
function ConfigureIndexRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'spec': (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecToJSON)(value.spec),
        'deletion_protection': (0, DeletionProtection_1.DeletionProtectionToJSON)(value.deletionProtection),
        'tags': value.tags,
        'embed': (0, ConfigureIndexRequestEmbed_1.ConfigureIndexRequestEmbedToJSON)(value.embed)
    };
}
exports.ConfigureIndexRequestToJSON = ConfigureIndexRequestToJSON; //# sourceMappingURL=ConfigureIndexRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateBackupRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateBackupRequestToJSON = exports.CreateBackupRequestFromJSONTyped = exports.CreateBackupRequestFromJSON = exports.instanceOfCreateBackupRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the CreateBackupRequest interface.
 */ function instanceOfCreateBackupRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfCreateBackupRequest = instanceOfCreateBackupRequest;
function CreateBackupRequestFromJSON(json) {
    return CreateBackupRequestFromJSONTyped(json, false);
}
exports.CreateBackupRequestFromJSON = CreateBackupRequestFromJSON;
function CreateBackupRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': !(0, runtime_1.exists)(json, 'name') ? undefined : json['name'],
        'description': !(0, runtime_1.exists)(json, 'description') ? undefined : json['description']
    };
}
exports.CreateBackupRequestFromJSONTyped = CreateBackupRequestFromJSONTyped;
function CreateBackupRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'description': value.description
    };
}
exports.CreateBackupRequestToJSON = CreateBackupRequestToJSON; //# sourceMappingURL=CreateBackupRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateCollectionRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = void 0;
/**
 * Check if a given object implements the CreateCollectionRequest interface.
 */ function instanceOfCreateCollectionRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "source" in value;
    return isInstance;
}
exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
function CreateCollectionRequestFromJSON(json) {
    return CreateCollectionRequestFromJSONTyped(json, false);
}
exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'source': json['source']
    };
}
exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
function CreateCollectionRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'source': value.source
    };
}
exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON; //# sourceMappingURL=CreateCollectionRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexForModelRequestEmbed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateIndexForModelRequestEmbedToJSON = exports.CreateIndexForModelRequestEmbedFromJSONTyped = exports.CreateIndexForModelRequestEmbedFromJSON = exports.instanceOfCreateIndexForModelRequestEmbed = exports.CreateIndexForModelRequestEmbedMetricEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.CreateIndexForModelRequestEmbedMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
/**
 * Check if a given object implements the CreateIndexForModelRequestEmbed interface.
 */ function instanceOfCreateIndexForModelRequestEmbed(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "fieldMap" in value;
    return isInstance;
}
exports.instanceOfCreateIndexForModelRequestEmbed = instanceOfCreateIndexForModelRequestEmbed;
function CreateIndexForModelRequestEmbedFromJSON(json) {
    return CreateIndexForModelRequestEmbedFromJSONTyped(json, false);
}
exports.CreateIndexForModelRequestEmbedFromJSON = CreateIndexForModelRequestEmbedFromJSON;
function CreateIndexForModelRequestEmbedFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'metric': !(0, runtime_1.exists)(json, 'metric') ? undefined : json['metric'],
        'fieldMap': json['field_map'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'readParameters': !(0, runtime_1.exists)(json, 'read_parameters') ? undefined : json['read_parameters'],
        'writeParameters': !(0, runtime_1.exists)(json, 'write_parameters') ? undefined : json['write_parameters']
    };
}
exports.CreateIndexForModelRequestEmbedFromJSONTyped = CreateIndexForModelRequestEmbedFromJSONTyped;
function CreateIndexForModelRequestEmbedToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'metric': value.metric,
        'field_map': value.fieldMap,
        'dimension': value.dimension,
        'read_parameters': value.readParameters,
        'write_parameters': value.writeParameters
    };
}
exports.CreateIndexForModelRequestEmbedToJSON = CreateIndexForModelRequestEmbedToJSON; //# sourceMappingURL=CreateIndexForModelRequestEmbed.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexForModelRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateIndexForModelRequestToJSON = exports.CreateIndexForModelRequestFromJSONTyped = exports.CreateIndexForModelRequestFromJSON = exports.instanceOfCreateIndexForModelRequest = exports.CreateIndexForModelRequestCloudEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const CreateIndexForModelRequestEmbed_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexForModelRequestEmbed.js [app-route] (ecmascript)");
const DeletionProtection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.CreateIndexForModelRequestCloudEnum = {
    Gcp: 'gcp',
    Aws: 'aws',
    Azure: 'azure'
};
/**
 * Check if a given object implements the CreateIndexForModelRequest interface.
 */ function instanceOfCreateIndexForModelRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "cloud" in value;
    isInstance = isInstance && "region" in value;
    isInstance = isInstance && "embed" in value;
    return isInstance;
}
exports.instanceOfCreateIndexForModelRequest = instanceOfCreateIndexForModelRequest;
function CreateIndexForModelRequestFromJSON(json) {
    return CreateIndexForModelRequestFromJSONTyped(json, false);
}
exports.CreateIndexForModelRequestFromJSON = CreateIndexForModelRequestFromJSON;
function CreateIndexForModelRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'cloud': json['cloud'],
        'region': json['region'],
        'deletionProtection': !(0, runtime_1.exists)(json, 'deletion_protection') ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json['deletion_protection']),
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'embed': (0, CreateIndexForModelRequestEmbed_1.CreateIndexForModelRequestEmbedFromJSON)(json['embed'])
    };
}
exports.CreateIndexForModelRequestFromJSONTyped = CreateIndexForModelRequestFromJSONTyped;
function CreateIndexForModelRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'cloud': value.cloud,
        'region': value.region,
        'deletion_protection': (0, DeletionProtection_1.DeletionProtectionToJSON)(value.deletionProtection),
        'tags': value.tags,
        'embed': (0, CreateIndexForModelRequestEmbed_1.CreateIndexForModelRequestEmbedToJSON)(value.embed)
    };
}
exports.CreateIndexForModelRequestToJSON = CreateIndexForModelRequestToJSON; //# sourceMappingURL=CreateIndexForModelRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexFromBackupRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateIndexFromBackupRequestToJSON = exports.CreateIndexFromBackupRequestFromJSONTyped = exports.CreateIndexFromBackupRequestFromJSON = exports.instanceOfCreateIndexFromBackupRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const DeletionProtection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the CreateIndexFromBackupRequest interface.
 */ function instanceOfCreateIndexFromBackupRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    return isInstance;
}
exports.instanceOfCreateIndexFromBackupRequest = instanceOfCreateIndexFromBackupRequest;
function CreateIndexFromBackupRequestFromJSON(json) {
    return CreateIndexFromBackupRequestFromJSONTyped(json, false);
}
exports.CreateIndexFromBackupRequestFromJSON = CreateIndexFromBackupRequestFromJSON;
function CreateIndexFromBackupRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'deletionProtection': !(0, runtime_1.exists)(json, 'deletion_protection') ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json['deletion_protection'])
    };
}
exports.CreateIndexFromBackupRequestFromJSONTyped = CreateIndexFromBackupRequestFromJSONTyped;
function CreateIndexFromBackupRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'tags': value.tags,
        'deletion_protection': (0, DeletionProtection_1.DeletionProtectionToJSON)(value.deletionProtection)
    };
}
exports.CreateIndexFromBackupRequestToJSON = CreateIndexFromBackupRequestToJSON; //# sourceMappingURL=CreateIndexFromBackupRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexFromBackupResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateIndexFromBackupResponseToJSON = exports.CreateIndexFromBackupResponseFromJSONTyped = exports.CreateIndexFromBackupResponseFromJSON = exports.instanceOfCreateIndexFromBackupResponse = void 0;
/**
 * Check if a given object implements the CreateIndexFromBackupResponse interface.
 */ function instanceOfCreateIndexFromBackupResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "restoreJobId" in value;
    isInstance = isInstance && "indexId" in value;
    return isInstance;
}
exports.instanceOfCreateIndexFromBackupResponse = instanceOfCreateIndexFromBackupResponse;
function CreateIndexFromBackupResponseFromJSON(json) {
    return CreateIndexFromBackupResponseFromJSONTyped(json, false);
}
exports.CreateIndexFromBackupResponseFromJSON = CreateIndexFromBackupResponseFromJSON;
function CreateIndexFromBackupResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'restoreJobId': json['restore_job_id'],
        'indexId': json['index_id']
    };
}
exports.CreateIndexFromBackupResponseFromJSONTyped = CreateIndexFromBackupResponseFromJSONTyped;
function CreateIndexFromBackupResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restore_job_id': value.restoreJobId,
        'index_id': value.indexId
    };
}
exports.CreateIndexFromBackupResponseToJSON = CreateIndexFromBackupResponseToJSON; //# sourceMappingURL=CreateIndexFromBackupResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpecMetadataConfig.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PodSpecMetadataConfigToJSON = exports.PodSpecMetadataConfigFromJSONTyped = exports.PodSpecMetadataConfigFromJSON = exports.instanceOfPodSpecMetadataConfig = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the PodSpecMetadataConfig interface.
 */ function instanceOfPodSpecMetadataConfig(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfPodSpecMetadataConfig = instanceOfPodSpecMetadataConfig;
function PodSpecMetadataConfigFromJSON(json) {
    return PodSpecMetadataConfigFromJSONTyped(json, false);
}
exports.PodSpecMetadataConfigFromJSON = PodSpecMetadataConfigFromJSON;
function PodSpecMetadataConfigFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'indexed': !(0, runtime_1.exists)(json, 'indexed') ? undefined : json['indexed']
    };
}
exports.PodSpecMetadataConfigFromJSONTyped = PodSpecMetadataConfigFromJSONTyped;
function PodSpecMetadataConfigToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'indexed': value.indexed
    };
}
exports.PodSpecMetadataConfigToJSON = PodSpecMetadataConfigToJSON; //# sourceMappingURL=PodSpecMetadataConfig.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PodSpecToJSON = exports.PodSpecFromJSONTyped = exports.PodSpecFromJSON = exports.instanceOfPodSpec = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const PodSpecMetadataConfig_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpecMetadataConfig.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the PodSpec interface.
 */ function instanceOfPodSpec(value) {
    let isInstance = true;
    isInstance = isInstance && "environment" in value;
    isInstance = isInstance && "podType" in value;
    return isInstance;
}
exports.instanceOfPodSpec = instanceOfPodSpec;
function PodSpecFromJSON(json) {
    return PodSpecFromJSONTyped(json, false);
}
exports.PodSpecFromJSON = PodSpecFromJSON;
function PodSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'environment': json['environment'],
        'replicas': !(0, runtime_1.exists)(json, 'replicas') ? undefined : json['replicas'],
        'shards': !(0, runtime_1.exists)(json, 'shards') ? undefined : json['shards'],
        'podType': json['pod_type'],
        'pods': !(0, runtime_1.exists)(json, 'pods') ? undefined : json['pods'],
        'metadataConfig': !(0, runtime_1.exists)(json, 'metadata_config') ? undefined : (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigFromJSON)(json['metadata_config']),
        'sourceCollection': !(0, runtime_1.exists)(json, 'source_collection') ? undefined : json['source_collection']
    };
}
exports.PodSpecFromJSONTyped = PodSpecFromJSONTyped;
function PodSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'environment': value.environment,
        'replicas': value.replicas,
        'shards': value.shards,
        'pod_type': value.podType,
        'pods': value.pods,
        'metadata_config': (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigToJSON)(value.metadataConfig),
        'source_collection': value.sourceCollection
    };
}
exports.PodSpecToJSON = PodSpecToJSON; //# sourceMappingURL=PodSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ServerlessSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerlessSpecToJSON = exports.ServerlessSpecFromJSONTyped = exports.ServerlessSpecFromJSON = exports.instanceOfServerlessSpec = exports.ServerlessSpecCloudEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ServerlessSpecCloudEnum = {
    Gcp: 'gcp',
    Aws: 'aws',
    Azure: 'azure'
};
/**
 * Check if a given object implements the ServerlessSpec interface.
 */ function instanceOfServerlessSpec(value) {
    let isInstance = true;
    isInstance = isInstance && "cloud" in value;
    isInstance = isInstance && "region" in value;
    return isInstance;
}
exports.instanceOfServerlessSpec = instanceOfServerlessSpec;
function ServerlessSpecFromJSON(json) {
    return ServerlessSpecFromJSONTyped(json, false);
}
exports.ServerlessSpecFromJSON = ServerlessSpecFromJSON;
function ServerlessSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'cloud': json['cloud'],
        'region': json['region'],
        'sourceCollection': !(0, runtime_1.exists)(json, 'source_collection') ? undefined : json['source_collection']
    };
}
exports.ServerlessSpecFromJSONTyped = ServerlessSpecFromJSONTyped;
function ServerlessSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'cloud': value.cloud,
        'region': value.region,
        'source_collection': value.sourceCollection
    };
}
exports.ServerlessSpecToJSON = ServerlessSpecToJSON; //# sourceMappingURL=ServerlessSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexSpecToJSON = exports.IndexSpecFromJSONTyped = exports.IndexSpecFromJSON = exports.instanceOfIndexSpec = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const ByocSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ByocSpec.js [app-route] (ecmascript)");
const PodSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpec.js [app-route] (ecmascript)");
const ServerlessSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ServerlessSpec.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the IndexSpec interface.
 */ function instanceOfIndexSpec(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfIndexSpec = instanceOfIndexSpec;
function IndexSpecFromJSON(json) {
    return IndexSpecFromJSONTyped(json, false);
}
exports.IndexSpecFromJSON = IndexSpecFromJSON;
function IndexSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'serverless': !(0, runtime_1.exists)(json, 'serverless') ? undefined : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json['serverless']),
        'pod': !(0, runtime_1.exists)(json, 'pod') ? undefined : (0, PodSpec_1.PodSpecFromJSON)(json['pod']),
        'byoc': !(0, runtime_1.exists)(json, 'byoc') ? undefined : (0, ByocSpec_1.ByocSpecFromJSON)(json['byoc'])
    };
}
exports.IndexSpecFromJSONTyped = IndexSpecFromJSONTyped;
function IndexSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'serverless': (0, ServerlessSpec_1.ServerlessSpecToJSON)(value.serverless),
        'pod': (0, PodSpec_1.PodSpecToJSON)(value.pod),
        'byoc': (0, ByocSpec_1.ByocSpecToJSON)(value.byoc)
    };
}
exports.IndexSpecToJSON = IndexSpecToJSON; //# sourceMappingURL=IndexSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateIndexRequestToJSON = exports.CreateIndexRequestFromJSONTyped = exports.CreateIndexRequestFromJSON = exports.instanceOfCreateIndexRequest = exports.CreateIndexRequestMetricEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const DeletionProtection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)");
const IndexSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexSpec.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.CreateIndexRequestMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
/**
 * Check if a given object implements the CreateIndexRequest interface.
 */ function instanceOfCreateIndexRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "spec" in value;
    return isInstance;
}
exports.instanceOfCreateIndexRequest = instanceOfCreateIndexRequest;
function CreateIndexRequestFromJSON(json) {
    return CreateIndexRequestFromJSONTyped(json, false);
}
exports.CreateIndexRequestFromJSON = CreateIndexRequestFromJSON;
function CreateIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'metric': !(0, runtime_1.exists)(json, 'metric') ? undefined : json['metric'],
        'deletionProtection': !(0, runtime_1.exists)(json, 'deletion_protection') ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json['deletion_protection']),
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'spec': (0, IndexSpec_1.IndexSpecFromJSON)(json['spec']),
        'vectorType': !(0, runtime_1.exists)(json, 'vector_type') ? undefined : json['vector_type']
    };
}
exports.CreateIndexRequestFromJSONTyped = CreateIndexRequestFromJSONTyped;
function CreateIndexRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'dimension': value.dimension,
        'metric': value.metric,
        'deletion_protection': (0, DeletionProtection_1.DeletionProtectionToJSON)(value.deletionProtection),
        'tags': value.tags,
        'spec': (0, IndexSpec_1.IndexSpecToJSON)(value.spec),
        'vector_type': value.vectorType
    };
}
exports.CreateIndexRequestToJSON = CreateIndexRequestToJSON; //# sourceMappingURL=CreateIndexRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponseError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ErrorResponseErrorCodeEnum = {
    Ok: 'OK',
    Unknown: 'UNKNOWN',
    InvalidArgument: 'INVALID_ARGUMENT',
    DeadlineExceeded: 'DEADLINE_EXCEEDED',
    QuotaExceeded: 'QUOTA_EXCEEDED',
    NotFound: 'NOT_FOUND',
    AlreadyExists: 'ALREADY_EXISTS',
    PermissionDenied: 'PERMISSION_DENIED',
    Unauthenticated: 'UNAUTHENTICATED',
    ResourceExhausted: 'RESOURCE_EXHAUSTED',
    FailedPrecondition: 'FAILED_PRECONDITION',
    Aborted: 'ABORTED',
    OutOfRange: 'OUT_OF_RANGE',
    Unimplemented: 'UNIMPLEMENTED',
    Internal: 'INTERNAL',
    Unavailable: 'UNAVAILABLE',
    DataLoss: 'DATA_LOSS',
    Forbidden: 'FORBIDDEN',
    UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
    PaymentRequired: 'PAYMENT_REQUIRED'
};
/**
 * Check if a given object implements the ErrorResponseError interface.
 */ function instanceOfErrorResponseError(value) {
    let isInstance = true;
    isInstance = isInstance && "code" in value;
    isInstance = isInstance && "message" in value;
    return isInstance;
}
exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
}
exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'code': json['code'],
        'message': json['message'],
        'details': !(0, runtime_1.exists)(json, 'details') ? undefined : json['details']
    };
}
exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
function ErrorResponseErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
        'details': value.details
    };
}
exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON; //# sourceMappingURL=ErrorResponseError.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = void 0;
const ErrorResponseError_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponseError.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ErrorResponse interface.
 */ function instanceOfErrorResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "error" in value;
    return isInstance;
}
exports.instanceOfErrorResponse = instanceOfErrorResponse;
function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
}
exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'status': json['status'],
        'error': (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json['error'])
    };
}
exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
function ErrorResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status': value.status,
        'error': (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value.error)
    };
}
exports.ErrorResponseToJSON = ErrorResponseToJSON; //# sourceMappingURL=ErrorResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelSpec.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexModelSpecToJSON = exports.IndexModelSpecFromJSONTyped = exports.IndexModelSpecFromJSON = exports.instanceOfIndexModelSpec = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const ByocSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ByocSpec.js [app-route] (ecmascript)");
const PodSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpec.js [app-route] (ecmascript)");
const ServerlessSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ServerlessSpec.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the IndexModelSpec interface.
 */ function instanceOfIndexModelSpec(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfIndexModelSpec = instanceOfIndexModelSpec;
function IndexModelSpecFromJSON(json) {
    return IndexModelSpecFromJSONTyped(json, false);
}
exports.IndexModelSpecFromJSON = IndexModelSpecFromJSON;
function IndexModelSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'byoc': !(0, runtime_1.exists)(json, 'byoc') ? undefined : (0, ByocSpec_1.ByocSpecFromJSON)(json['byoc']),
        'pod': !(0, runtime_1.exists)(json, 'pod') ? undefined : (0, PodSpec_1.PodSpecFromJSON)(json['pod']),
        'serverless': !(0, runtime_1.exists)(json, 'serverless') ? undefined : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json['serverless'])
    };
}
exports.IndexModelSpecFromJSONTyped = IndexModelSpecFromJSONTyped;
function IndexModelSpecToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'byoc': (0, ByocSpec_1.ByocSpecToJSON)(value.byoc),
        'pod': (0, PodSpec_1.PodSpecToJSON)(value.pod),
        'serverless': (0, ServerlessSpec_1.ServerlessSpecToJSON)(value.serverless)
    };
}
exports.IndexModelSpecToJSON = IndexModelSpecToJSON; //# sourceMappingURL=IndexModelSpec.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelStatus.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexModelStatusToJSON = exports.IndexModelStatusFromJSONTyped = exports.IndexModelStatusFromJSON = exports.instanceOfIndexModelStatus = exports.IndexModelStatusStateEnum = void 0;
/**
 * @export
 */ exports.IndexModelStatusStateEnum = {
    Initializing: 'Initializing',
    InitializationFailed: 'InitializationFailed',
    ScalingUp: 'ScalingUp',
    ScalingDown: 'ScalingDown',
    ScalingUpPodSize: 'ScalingUpPodSize',
    ScalingDownPodSize: 'ScalingDownPodSize',
    Terminating: 'Terminating',
    Ready: 'Ready',
    Disabled: 'Disabled'
};
/**
 * Check if a given object implements the IndexModelStatus interface.
 */ function instanceOfIndexModelStatus(value) {
    let isInstance = true;
    isInstance = isInstance && "ready" in value;
    isInstance = isInstance && "state" in value;
    return isInstance;
}
exports.instanceOfIndexModelStatus = instanceOfIndexModelStatus;
function IndexModelStatusFromJSON(json) {
    return IndexModelStatusFromJSONTyped(json, false);
}
exports.IndexModelStatusFromJSON = IndexModelStatusFromJSON;
function IndexModelStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'ready': json['ready'],
        'state': json['state']
    };
}
exports.IndexModelStatusFromJSONTyped = IndexModelStatusFromJSONTyped;
function IndexModelStatusToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'ready': value.ready,
        'state': value.state
    };
}
exports.IndexModelStatusToJSON = IndexModelStatusToJSON; //# sourceMappingURL=IndexModelStatus.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ModelIndexEmbed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelIndexEmbedToJSON = exports.ModelIndexEmbedFromJSONTyped = exports.ModelIndexEmbedFromJSON = exports.instanceOfModelIndexEmbed = exports.ModelIndexEmbedMetricEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ModelIndexEmbedMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
/**
 * Check if a given object implements the ModelIndexEmbed interface.
 */ function instanceOfModelIndexEmbed(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    return isInstance;
}
exports.instanceOfModelIndexEmbed = instanceOfModelIndexEmbed;
function ModelIndexEmbedFromJSON(json) {
    return ModelIndexEmbedFromJSONTyped(json, false);
}
exports.ModelIndexEmbedFromJSON = ModelIndexEmbedFromJSON;
function ModelIndexEmbedFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'metric': !(0, runtime_1.exists)(json, 'metric') ? undefined : json['metric'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'vectorType': !(0, runtime_1.exists)(json, 'vector_type') ? undefined : json['vector_type'],
        'fieldMap': !(0, runtime_1.exists)(json, 'field_map') ? undefined : json['field_map'],
        'readParameters': !(0, runtime_1.exists)(json, 'read_parameters') ? undefined : json['read_parameters'],
        'writeParameters': !(0, runtime_1.exists)(json, 'write_parameters') ? undefined : json['write_parameters']
    };
}
exports.ModelIndexEmbedFromJSONTyped = ModelIndexEmbedFromJSONTyped;
function ModelIndexEmbedToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'metric': value.metric,
        'dimension': value.dimension,
        'vector_type': value.vectorType,
        'field_map': value.fieldMap,
        'read_parameters': value.readParameters,
        'write_parameters': value.writeParameters
    };
}
exports.ModelIndexEmbedToJSON = ModelIndexEmbedToJSON; //# sourceMappingURL=ModelIndexEmbed.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexModelToJSON = exports.IndexModelFromJSONTyped = exports.IndexModelFromJSON = exports.instanceOfIndexModel = exports.IndexModelMetricEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const DeletionProtection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)");
const IndexModelSpec_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelSpec.js [app-route] (ecmascript)");
const IndexModelStatus_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelStatus.js [app-route] (ecmascript)");
const ModelIndexEmbed_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ModelIndexEmbed.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.IndexModelMetricEnum = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
/**
 * Check if a given object implements the IndexModel interface.
 */ function instanceOfIndexModel(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "metric" in value;
    isInstance = isInstance && "host" in value;
    isInstance = isInstance && "spec" in value;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "vectorType" in value;
    return isInstance;
}
exports.instanceOfIndexModel = instanceOfIndexModel;
function IndexModelFromJSON(json) {
    return IndexModelFromJSONTyped(json, false);
}
exports.IndexModelFromJSON = IndexModelFromJSON;
function IndexModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'metric': json['metric'],
        'host': json['host'],
        'privateHost': !(0, runtime_1.exists)(json, 'private_host') ? undefined : json['private_host'],
        'deletionProtection': !(0, runtime_1.exists)(json, 'deletion_protection') ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json['deletion_protection']),
        'tags': !(0, runtime_1.exists)(json, 'tags') ? undefined : json['tags'],
        'embed': !(0, runtime_1.exists)(json, 'embed') ? undefined : (0, ModelIndexEmbed_1.ModelIndexEmbedFromJSON)(json['embed']),
        'spec': (0, IndexModelSpec_1.IndexModelSpecFromJSON)(json['spec']),
        'status': (0, IndexModelStatus_1.IndexModelStatusFromJSON)(json['status']),
        'vectorType': json['vector_type']
    };
}
exports.IndexModelFromJSONTyped = IndexModelFromJSONTyped;
function IndexModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'dimension': value.dimension,
        'metric': value.metric,
        'host': value.host,
        'private_host': value.privateHost,
        'deletion_protection': (0, DeletionProtection_1.DeletionProtectionToJSON)(value.deletionProtection),
        'tags': value.tags,
        'embed': (0, ModelIndexEmbed_1.ModelIndexEmbedToJSON)(value.embed),
        'spec': (0, IndexModelSpec_1.IndexModelSpecToJSON)(value.spec),
        'status': (0, IndexModelStatus_1.IndexModelStatusToJSON)(value.status),
        'vector_type': value.vectorType
    };
}
exports.IndexModelToJSON = IndexModelToJSON; //# sourceMappingURL=IndexModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexListToJSON = exports.IndexListFromJSONTyped = exports.IndexListFromJSON = exports.instanceOfIndexList = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const IndexModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the IndexList interface.
 */ function instanceOfIndexList(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfIndexList = instanceOfIndexList;
function IndexListFromJSON(json) {
    return IndexListFromJSONTyped(json, false);
}
exports.IndexListFromJSON = IndexListFromJSON;
function IndexListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'indexes': !(0, runtime_1.exists)(json, 'indexes') ? undefined : json['indexes'].map(IndexModel_1.IndexModelFromJSON)
    };
}
exports.IndexListFromJSONTyped = IndexListFromJSONTyped;
function IndexListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'indexes': value.indexes === undefined ? undefined : value.indexes.map(IndexModel_1.IndexModelToJSON)
    };
}
exports.IndexListToJSON = IndexListToJSON; //# sourceMappingURL=IndexList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/RestoreJobModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RestoreJobModelToJSON = exports.RestoreJobModelFromJSONTyped = exports.RestoreJobModelFromJSON = exports.instanceOfRestoreJobModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RestoreJobModel interface.
 */ function instanceOfRestoreJobModel(value) {
    let isInstance = true;
    isInstance = isInstance && "restoreJobId" in value;
    isInstance = isInstance && "backupId" in value;
    isInstance = isInstance && "targetIndexName" in value;
    isInstance = isInstance && "targetIndexId" in value;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "createdAt" in value;
    return isInstance;
}
exports.instanceOfRestoreJobModel = instanceOfRestoreJobModel;
function RestoreJobModelFromJSON(json) {
    return RestoreJobModelFromJSONTyped(json, false);
}
exports.RestoreJobModelFromJSON = RestoreJobModelFromJSON;
function RestoreJobModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'restoreJobId': json['restore_job_id'],
        'backupId': json['backup_id'],
        'targetIndexName': json['target_index_name'],
        'targetIndexId': json['target_index_id'],
        'status': json['status'],
        'createdAt': new Date(json['created_at']),
        'completedAt': !(0, runtime_1.exists)(json, 'completed_at') ? undefined : new Date(json['completed_at']),
        'percentComplete': !(0, runtime_1.exists)(json, 'percent_complete') ? undefined : json['percent_complete']
    };
}
exports.RestoreJobModelFromJSONTyped = RestoreJobModelFromJSONTyped;
function RestoreJobModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'restore_job_id': value.restoreJobId,
        'backup_id': value.backupId,
        'target_index_name': value.targetIndexName,
        'target_index_id': value.targetIndexId,
        'status': value.status,
        'created_at': value.createdAt.toISOString(),
        'completed_at': value.completedAt === undefined ? undefined : value.completedAt.toISOString(),
        'percent_complete': value.percentComplete
    };
}
exports.RestoreJobModelToJSON = RestoreJobModelToJSON; //# sourceMappingURL=RestoreJobModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/RestoreJobList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RestoreJobListToJSON = exports.RestoreJobListFromJSONTyped = exports.RestoreJobListFromJSON = exports.instanceOfRestoreJobList = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)");
const PaginationResponse_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PaginationResponse.js [app-route] (ecmascript)");
const RestoreJobModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/RestoreJobModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RestoreJobList interface.
 */ function instanceOfRestoreJobList(value) {
    let isInstance = true;
    isInstance = isInstance && "data" in value;
    return isInstance;
}
exports.instanceOfRestoreJobList = instanceOfRestoreJobList;
function RestoreJobListFromJSON(json) {
    return RestoreJobListFromJSONTyped(json, false);
}
exports.RestoreJobListFromJSON = RestoreJobListFromJSON;
function RestoreJobListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'data': json['data'].map(RestoreJobModel_1.RestoreJobModelFromJSON),
        'pagination': !(0, runtime_1.exists)(json, 'pagination') ? undefined : (0, PaginationResponse_1.PaginationResponseFromJSON)(json['pagination'])
    };
}
exports.RestoreJobListFromJSONTyped = RestoreJobListFromJSONTyped;
function RestoreJobListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data.map(RestoreJobModel_1.RestoreJobModelToJSON),
        'pagination': (0, PaginationResponse_1.PaginationResponseToJSON)(value.pagination)
    };
}
exports.RestoreJobListToJSON = RestoreJobListToJSON; //# sourceMappingURL=RestoreJobList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/BackupList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/BackupModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ByocSpec.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestEmbed.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpec.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpecPod.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateBackupRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateCollectionRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexForModelRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexForModelRequestEmbed.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexFromBackupRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexFromBackupResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponseError.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelSpec.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelStatus.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexSpec.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ModelIndexEmbed.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PaginationResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpec.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpecMetadataConfig.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/RestoreJobList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/RestoreJobModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ServerlessSpec.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/ManageIndexesApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Control Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ManageIndexesApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class ManageIndexesApi extends runtime.BaseAPI {
    /**
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * Configure an index
     */ async configureIndexRaw(requestParameters, initOverrides) {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName', 'Required parameter requestParameters.indexName was null or undefined when calling configureIndex.');
        }
        if (requestParameters.configureIndexRequest === null || requestParameters.configureIndexRequest === undefined) {
            throw new runtime.RequiredError('configureIndexRequest', 'Required parameter requestParameters.configureIndexRequest was null or undefined when calling configureIndex.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/{index_name}`.replace(`{${"index_name"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ConfigureIndexRequestToJSON)(requestParameters.configureIndexRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexModelFromJSON)(jsonValue));
    }
    /**
     * Configure an existing index. For serverless indexes, you can configure index deletion protection, tags, and integrated inference embedding settings for the index. For pod-based indexes, you can configure the pod size, number of replicas, tags, and index deletion protection.  It is not possible to change the pod type of a pod-based index. However, you can create a collection from a pod-based index and then [create a new pod-based index with a different pod type](http://docs.pinecone.io/guides/indexes/pods/create-a-pod-based-index#create-a-pod-index-from-a-collection) from the collection. For guidance and examples, see [Configure an index](http://docs.pinecone.io/guides/indexes/pods/manage-pod-based-indexes).
     * Configure an index
     */ async configureIndex(requestParameters, initOverrides) {
        const response = await this.configureIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Create a backup of an index.
     * Create a backup of an index
     */ async createBackupRaw(requestParameters, initOverrides) {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName', 'Required parameter requestParameters.indexName was null or undefined when calling createBackup.');
        }
        if (requestParameters.createBackupRequest === null || requestParameters.createBackupRequest === undefined) {
            throw new runtime.RequiredError('createBackupRequest', 'Required parameter requestParameters.createBackupRequest was null or undefined when calling createBackup.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/{index_name}/backups`.replace(`{${"index_name"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateBackupRequestToJSON)(requestParameters.createBackupRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.BackupModelFromJSON)(jsonValue));
    }
    /**
     * Create a backup of an index.
     * Create a backup of an index
     */ async createBackup(requestParameters, initOverrides) {
        const response = await this.createBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Create a Pinecone collection.    Serverless indexes do not support collections.
     * Create a collection
     */ async createCollectionRaw(requestParameters, initOverrides) {
        if (requestParameters.createCollectionRequest === null || requestParameters.createCollectionRequest === undefined) {
            throw new runtime.RequiredError('createCollectionRequest', 'Required parameter requestParameters.createCollectionRequest was null or undefined when calling createCollection.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/collections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.CollectionModelFromJSON)(jsonValue));
    }
    /**
     * Create a Pinecone collection.    Serverless indexes do not support collections.
     * Create a collection
     */ async createCollection(requestParameters, initOverrides) {
        const response = await this.createCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index).
     * Create an index
     */ async createIndexRaw(requestParameters, initOverrides) {
        if (requestParameters.createIndexRequest === null || requestParameters.createIndexRequest === undefined) {
            throw new runtime.RequiredError('createIndexRequest', 'Required parameter requestParameters.createIndexRequest was null or undefined when calling createIndex.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateIndexRequestToJSON)(requestParameters.createIndexRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexModelFromJSON)(jsonValue));
    }
    /**
     * Create a Pinecone index. This is where you specify the measure of similarity, the dimension of vectors to be stored in the index, which cloud provider you would like to deploy with, and more.    For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index).
     * Create an index
     */ async createIndex(requestParameters, initOverrides) {
        const response = await this.createIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Create an index with integrated embedding.  With this type of index, you provide source text, and Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-01/data-plane/upsert_records) and [search](https://docs.pinecone.io/reference/api/2025-01/data-plane/search_records).  For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index#integrated-embedding).
     * Create an index with integrated embedding
     */ async createIndexForModelRaw(requestParameters, initOverrides) {
        if (requestParameters.createIndexForModelRequest === null || requestParameters.createIndexForModelRequest === undefined) {
            throw new runtime.RequiredError('createIndexForModelRequest', 'Required parameter requestParameters.createIndexForModelRequest was null or undefined when calling createIndexForModel.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/create-for-model`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateIndexForModelRequestToJSON)(requestParameters.createIndexForModelRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexModelFromJSON)(jsonValue));
    }
    /**
     * Create an index with integrated embedding.  With this type of index, you provide source text, and Pinecone uses a [hosted embedding model](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) to convert the text automatically during [upsert](https://docs.pinecone.io/reference/api/2025-01/data-plane/upsert_records) and [search](https://docs.pinecone.io/reference/api/2025-01/data-plane/search_records).  For guidance and examples, see [Create an index](https://docs.pinecone.io/guides/index-data/create-an-index#integrated-embedding).
     * Create an index with integrated embedding
     */ async createIndexForModel(requestParameters, initOverrides) {
        const response = await this.createIndexForModelRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Create an index from a backup.
     * Create an index from a backup
     */ async createIndexFromBackupOperationRaw(requestParameters, initOverrides) {
        if (requestParameters.backupId === null || requestParameters.backupId === undefined) {
            throw new runtime.RequiredError('backupId', 'Required parameter requestParameters.backupId was null or undefined when calling createIndexFromBackupOperation.');
        }
        if (requestParameters.createIndexFromBackupRequest === null || requestParameters.createIndexFromBackupRequest === undefined) {
            throw new runtime.RequiredError('createIndexFromBackupRequest', 'Required parameter requestParameters.createIndexFromBackupRequest was null or undefined when calling createIndexFromBackupOperation.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/backups/{backup_id}/create-index`.replace(`{${"backup_id"}}`, encodeURIComponent(String(requestParameters.backupId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateIndexFromBackupRequestToJSON)(requestParameters.createIndexFromBackupRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.CreateIndexFromBackupResponseFromJSON)(jsonValue));
    }
    /**
     * Create an index from a backup.
     * Create an index from a backup
     */ async createIndexFromBackupOperation(requestParameters, initOverrides) {
        const response = await this.createIndexFromBackupOperationRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Delete a backup.
     * Delete a backup
     */ async deleteBackupRaw(requestParameters, initOverrides) {
        if (requestParameters.backupId === null || requestParameters.backupId === undefined) {
            throw new runtime.RequiredError('backupId', 'Required parameter requestParameters.backupId was null or undefined when calling deleteBackup.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/backups/{backup_id}`.replace(`{${"backup_id"}}`, encodeURIComponent(String(requestParameters.backupId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Delete a backup.
     * Delete a backup
     */ async deleteBackup(requestParameters, initOverrides) {
        await this.deleteBackupRaw(requestParameters, initOverrides);
    }
    /**
     * Delete an existing collection. Serverless indexes do not support collections.
     * Delete a collection
     */ async deleteCollectionRaw(requestParameters, initOverrides) {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName', 'Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/collections/{collection_name}`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Delete an existing collection. Serverless indexes do not support collections.
     * Delete a collection
     */ async deleteCollection(requestParameters, initOverrides) {
        await this.deleteCollectionRaw(requestParameters, initOverrides);
    }
    /**
     * Delete an existing index.
     * Delete an index
     */ async deleteIndexRaw(requestParameters, initOverrides) {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName', 'Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/{index_name}`.replace(`{${"index_name"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Delete an existing index.
     * Delete an index
     */ async deleteIndex(requestParameters, initOverrides) {
        await this.deleteIndexRaw(requestParameters, initOverrides);
    }
    /**
     * Get a description of a backup.
     * Describe a backup
     */ async describeBackupRaw(requestParameters, initOverrides) {
        if (requestParameters.backupId === null || requestParameters.backupId === undefined) {
            throw new runtime.RequiredError('backupId', 'Required parameter requestParameters.backupId was null or undefined when calling describeBackup.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/backups/{backup_id}`.replace(`{${"backup_id"}}`, encodeURIComponent(String(requestParameters.backupId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.BackupModelFromJSON)(jsonValue));
    }
    /**
     * Get a description of a backup.
     * Describe a backup
     */ async describeBackup(requestParameters, initOverrides) {
        const response = await this.describeBackupRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get a description of a collection. Serverless indexes do not support collections.
     * Describe a collection
     */ async describeCollectionRaw(requestParameters, initOverrides) {
        if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
            throw new runtime.RequiredError('collectionName', 'Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/collections/{collection_name}`.replace(`{${"collection_name"}}`, encodeURIComponent(String(requestParameters.collectionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.CollectionModelFromJSON)(jsonValue));
    }
    /**
     * Get a description of a collection. Serverless indexes do not support collections.
     * Describe a collection
     */ async describeCollection(requestParameters, initOverrides) {
        const response = await this.describeCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get a description of an index.
     * Describe an index
     */ async describeIndexRaw(requestParameters, initOverrides) {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName', 'Required parameter requestParameters.indexName was null or undefined when calling describeIndex.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/{index_name}`.replace(`{${"index_name"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexModelFromJSON)(jsonValue));
    }
    /**
     * Get a description of an index.
     * Describe an index
     */ async describeIndex(requestParameters, initOverrides) {
        const response = await this.describeIndexRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get a description of a restore job.
     * Describe a restore job
     */ async describeRestoreJobRaw(requestParameters, initOverrides) {
        if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
            throw new runtime.RequiredError('jobId', 'Required parameter requestParameters.jobId was null or undefined when calling describeRestoreJob.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/restore-jobs/{job_id}`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.RestoreJobModelFromJSON)(jsonValue));
    }
    /**
     * Get a description of a restore job.
     * Describe a restore job
     */ async describeRestoreJob(requestParameters, initOverrides) {
        const response = await this.describeRestoreJobRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all collections in a project. Serverless indexes do not support collections.
     * List collections
     */ async listCollectionsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/collections`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.CollectionListFromJSON)(jsonValue));
    }
    /**
     * List all collections in a project. Serverless indexes do not support collections.
     * List collections
     */ async listCollections(initOverrides) {
        const response = await this.listCollectionsRaw(initOverrides);
        return await response.value();
    }
    /**
     * List all backups for an index.
     * List backups for an index
     */ async listIndexBackupsRaw(requestParameters, initOverrides) {
        if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
            throw new runtime.RequiredError('indexName', 'Required parameter requestParameters.indexName was null or undefined when calling listIndexBackups.');
        }
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes/{index_name}/backups`.replace(`{${"index_name"}}`, encodeURIComponent(String(requestParameters.indexName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.BackupListFromJSON)(jsonValue));
    }
    /**
     * List all backups for an index.
     * List backups for an index
     */ async listIndexBackups(requestParameters, initOverrides) {
        const response = await this.listIndexBackupsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all indexes in a project.
     * List indexes
     */ async listIndexesRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/indexes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexListFromJSON)(jsonValue));
    }
    /**
     * List all indexes in a project.
     * List indexes
     */ async listIndexes(initOverrides) {
        const response = await this.listIndexesRaw(initOverrides);
        return await response.value();
    }
    /**
     * List all backups for a project.
     * List backups for all indexes in a project
     */ async listProjectBackupsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/backups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.BackupListFromJSON)(jsonValue));
    }
    /**
     * List all backups for a project.
     * List backups for all indexes in a project
     */ async listProjectBackups(requestParameters = {}, initOverrides) {
        const response = await this.listProjectBackupsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all restore jobs for a project.
     * List restore jobs
     */ async listRestoreJobsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/restore-jobs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.RestoreJobListFromJSON)(jsonValue));
    }
    /**
     * List all restore jobs for a project.
     * List restore jobs
     */ async listRestoreJobs(requestParameters = {}, initOverrides) {
        const response = await this.listRestoreJobsRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.ManageIndexesApi = ManageIndexesApi; //# sourceMappingURL=ManageIndexesApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/ManageIndexesApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.debugLog = void 0;
const debugLog = (str)=>{
    if (typeof process !== 'undefined' && process && process.env && process.env.PINECONE_DEBUG) {
        console.log(str);
    }
};
exports.debugLog = debugLog; //# sourceMappingURL=debugLog.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/normalizeUrl.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeUrl = void 0;
function normalizeUrl(url) {
    if (!url || url.trim().length === 0) {
        return;
    }
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
        return 'https://' + url;
    }
    return url;
}
exports.normalizeUrl = normalizeUrl; //# sourceMappingURL=normalizeUrl.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.queryParamsStringify = void 0;
// Everything in this file is lifted from the generated openapi runtime.
// I need to create a small modification of the generated queryParamStringify
// function in order to fix an issue with array params.
//
// See https://github.com/pinecone-io/pinecone-ts-client/pull/74
function queryParamsStringify(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.queryParamsStringify = queryParamsStringify;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    // This is a one line change from the default querystring implementation. Checking
    // with `Array.isArray` instead of `value instanceof Array` allows us to get the
    // the correct behavior when stringifying array params.
    if (Array.isArray(value)) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return queryParamsStringify(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
} //# sourceMappingURL=queryParamsStringify.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/environment.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBrowser = exports.isEdge = void 0;
const isEdge = ()=>{
    // This is the recommended way to detect
    // running in the Edge Runtime according
    // to Vercel docs.
    return typeof EdgeRuntime === 'string';
};
exports.isEdge = isEdge;
const isBrowser = ()=>{
    return "undefined" !== 'undefined';
};
exports.isBrowser = isBrowser; //# sourceMappingURL=environment.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/version.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v(JSON.parse("{\"name\":\"@pinecone-database/pinecone\",\"version\":\"6.1.1\"}"));}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildUserAgent = void 0;
const environment_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/environment.js [app-route] (ecmascript)");
const packageInfo = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/version.json (json)"));
const buildUserAgent = (config)=>{
    // We always want to include the package name and version
    // along with the langauge name to help distinguish these
    // requests from those emitted by other clients
    const userAgentParts = [
        `${packageInfo.name} v${packageInfo.version}`,
        'lang=typescript'
    ];
    if ((0, environment_1.isEdge)()) {
        userAgentParts.push('Edge Runtime');
    }
    // If available, capture information about the Node.js version
    if (typeof process !== 'undefined' && process && process.version) {
        userAgentParts.push(`node ${process.version}`);
    }
    if (config.sourceTag) {
        userAgentParts.push(`source_tag=${normalizeSourceTag(config.sourceTag)}`);
    }
    return userAgentParts.join('; ');
};
exports.buildUserAgent = buildUserAgent;
const normalizeSourceTag = (sourceTag)=>{
    if (!sourceTag) {
        return;
    }
    /**
     * normalize sourceTag
     * 1. Lowercase
     * 2. Limit charset to [a-z0-9_ :]
     * 3. Trim left/right spaces
     * 4. Condense multiple spaces to one, and replace with underscore
     */ return sourceTag.toLowerCase().replace(/[^a-z0-9_ :]/g, '').trim().replace(/[ ]+/g, '_');
}; //# sourceMappingURL=user-agent.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BasePineconeError = void 0;
class BasePineconeError extends Error {
    constructor(message, cause){
        super(message);
        // Set the prototype explicitly to ensure instanceof works correctly
        Object.setPrototypeOf(this, new.target.prototype);
        // Maintain a proper stack trace in V8 environments (Chrome and Node.js)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, new.target);
        }
        this.name = this.constructor.name;
        this.cause = cause;
    }
}
exports.BasePineconeError = BasePineconeError; //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/config.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)");
const CONFIG_HELP = `You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io.`;
/**
 * This exception indicates there is a problem with the configuration values
 * you have provided to the client. The error message should contain additional
 * context about what you are missing.
 *
 * @see {@link Pinecone} for information about initializing the client.
 */ class PineconeConfigurationError extends base_1.BasePineconeError {
    constructor(message){
        super(`${message} ${CONFIG_HELP}`);
        this.name = 'PineconeConfigurationError';
    }
}
exports.PineconeConfigurationError = PineconeConfigurationError;
/**
 * This exception indicates an API call that returned a response that was
 * unable to be parsed or that did not include expected fields. It's not
 * expected to ever occur.
 *
 * If you encounter this error, please [file an issue](https://github.com/pinecone-io/pinecone-ts-client/issues) so we can investigate.
 */ class PineconeUnexpectedResponseError extends base_1.BasePineconeError {
    constructor(url, status, body, message){
        super(`Unexpected response while calling ${url}. ${message ? message + ' ' : ''}Status: ${status}. Body: ${body}`);
        this.name = 'PineconeUnexpectedResponseError';
    }
}
exports.PineconeUnexpectedResponseError = PineconeUnexpectedResponseError;
/**
 * This error occurs when the client tries to read environment variables in
 * an environment that does not have access to the Node.js global `process.env`.
 *
 * If you are seeing this error, you will need to configure the client by passing
 * configuration values to the `Pinecone` constructor.
 *
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 *
 * const pinecone = new Pinecone({
 *    apiKey: 'YOUR_API_KEY',
 * })
 * ```
 *
 * @see Instructions for configuring { @link Pinecone }
 */ class PineconeEnvironmentVarsNotSupportedError extends base_1.BasePineconeError {
    constructor(message){
        super(message);
        this.name = 'PineconeEnvironmentVarsNotSupportedError';
    }
}
exports.PineconeEnvironmentVarsNotSupportedError = PineconeEnvironmentVarsNotSupportedError;
/**
 * This error occurs when the client is unable to resolve the database host for a given
 * index. This is unexpected to occur unless there is a problem with the Pinecone service.
 *
 * If you encounter this error, please [file an issue](https://github.com/pinecone-io/pinecone-ts-client/issues) so we can investigate.
 */ class PineconeUnableToResolveHostError extends base_1.BasePineconeError {
    constructor(message){
        super(message);
        this.name = 'PineconeUnableToResolveHostError';
    }
}
exports.PineconeUnableToResolveHostError = PineconeUnableToResolveHostError; //# sourceMappingURL=config.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/http.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapHttpStatusError = exports.PineconeUnmappedHttpError = exports.PineconeNotImplementedError = exports.PineconeUnavailableError = exports.PineconeMaxRetriesExceededError = exports.PineconeInternalServerError = exports.PineconeConflictError = exports.PineconeNotFoundError = exports.PineconeAuthorizationError = exports.PineconeBadRequestError = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)");
const CONFIG_HELP = `You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io`;
/** This error is thrown when API requests return with status 400. Typically this is due to some aspect of the request being incorrect or invalid.
 *
 * Some examples when this error could occur:
 * - While attempting to create an index with no available quota in your project.
 * - While upserting records that do not match the `dimension` of your index
 * - While attempting to create an index using an invalid name ("!@#$%")
 */ class PineconeBadRequestError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { message } = failedRequest;
        super(message);
        this.name = 'PineconeBadRequestError';
    }
}
exports.PineconeBadRequestError = PineconeBadRequestError;
/**
 * This error occurs when API requests are attempted using invalid configurations such as a mispelled or revoked API key.
 *
 * Log in to https://app.pinecone.io to verify you have configured the { @link Pinecone }
 * client using the correct values.
 */ class PineconeAuthorizationError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url } = failedRequest;
        if (url) {
            super(`The API key you provided was rejected while calling ${url}. Please check your configuration values and try again. ${CONFIG_HELP}`);
        } else {
            super(`The API key you provided was rejected. Please check your configuration values and try again. ${CONFIG_HELP}`);
        }
        this.name = 'PineconeAuthorizationError';
    }
}
exports.PineconeAuthorizationError = PineconeAuthorizationError;
/**
 * This error is thrown when interacting with a resource such as an index or collection
 * that cannot be found.
 */ class PineconeNotFoundError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url } = failedRequest;
        if (url) {
            super(`A call to ${url} returned HTTP status 404.`);
        } else {
            super('The requested resource could not be found.');
        }
        this.name = 'PineconeNotFoundError';
    }
}
exports.PineconeNotFoundError = PineconeNotFoundError;
/**
 * This error is thrown when attempting to create a resource such as an index or
 * collection with a name that is already in use.
 * */ class PineconeConflictError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url, message } = failedRequest;
        if (url) {
            super(`A call to ${url} returned HTTP status 409. ${message ? message : ''}`);
        } else {
            super('The resource you are attempting to create already exists.');
        }
        this.name = 'PineconeConflictError';
    }
}
exports.PineconeConflictError = PineconeConflictError;
/**
 * This error indicates API responses are returning with status 500 and
 * something is wrong with Pinecone. Check the [status page](https://status.pinecone.io/)
 * for information about current or recent outages.
 *
 * @see [Pinecone's status page](https://status.pinecone.io/)
 */ class PineconeInternalServerError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url, body, status } = failedRequest;
        const intro = url ? `An internal server error occurred while calling the ${url} endpoint.` : '';
        const help = `To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client`;
        const statusMessage = status ? `Status Code: ${status}.` : '';
        const bodyMessage = body ? `Body: ${body}` : '';
        super([
            intro,
            statusMessage,
            help,
            bodyMessage
        ].join(' ').trim());
        this.name = 'PineconeInternalServerError';
    }
}
exports.PineconeInternalServerError = PineconeInternalServerError;
/* We can choose to throw this error when we want to limit requests to the server. When instantiated, pass the
 number of retries the user has made already. */ class PineconeMaxRetriesExceededError extends base_1.BasePineconeError {
    constructor(retries){
        const intro = `You have exceeded the max configured retries (${retries}). `;
        const help = 'Increase the maxRetries field in the RetryOptions object to retry more times. If you believe the' + ' error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client';
        super([
            intro,
            help
        ].join(' ').trim());
        this.name = 'PineconeMaxRetriesExceededError';
    }
}
exports.PineconeMaxRetriesExceededError = PineconeMaxRetriesExceededError;
/**
 * This error indicates API responses are returning with status 503 and
 * Pinecone itself is down. Check the [status page](https://status.pinecone.io/)
 * for information about current or recent outages.
 *
 * The difference between this error (503) and a PineconeInternalServerError (500) is that this error does NOT indicate
 * that the server is _unable_ to process the request, just that the server will not process the request.
 *
 * @see [Pinecone's status page](https://status.pinecone.io/)
 */ class PineconeUnavailableError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url, body, status } = failedRequest;
        const intro = url ? `The Pinecone service (${url}) is temporarily unavailable.` : '';
        const statusMessage = status ? `Status Code: ${status}.` : '';
        const help = `To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client`;
        const bodyMessage = body ? `Body: ${body}` : '';
        super([
            intro,
            statusMessage,
            help,
            bodyMessage
        ].join(' ').trim());
        this.name = 'PineconeUnavailableError';
    }
}
exports.PineconeUnavailableError = PineconeUnavailableError;
/**
 * This error is thrown when you are attempting to use a feature that is
 * not implemented or unavailable to you on your current plan. Free indexes
 * only support a subset of Pinecone's capabilities, and if you are seeing
 * these exceptions then you should consult the
 * [pricing page](https://www.pinecone.io/pricing/) to see whether upgrading
 * makes sense for your use case.
 */ class PineconeNotImplementedError extends base_1.BasePineconeError {
    constructor(requestInfo){
        const { url, message } = requestInfo;
        if (url) {
            super(`A call to ${url} returned HTTP status 501. ${message ? message : ''}`);
        } else {
            super();
        }
        this.name = 'PineconeNotImplementedError';
    }
}
exports.PineconeNotImplementedError = PineconeNotImplementedError;
/**
 * This catch-all exception is thrown when a request error that is not
 * specifically mapped to another exception is thrown.
 */ class PineconeUnmappedHttpError extends base_1.BasePineconeError {
    constructor(failedRequest){
        const { url, status, body, message } = failedRequest;
        const intro = url ? `An unexpected error occured while calling the ${url} endpoint. ` : '';
        const statusMsg = status ? `Status: ${status}. ` : '';
        const bodyMsg = body ? `Body: ${body}` : '';
        super([
            intro,
            message,
            statusMsg,
            bodyMsg
        ].join(' ').trim());
        this.name = 'PineconeUnmappedHttpError';
    }
}
exports.PineconeUnmappedHttpError = PineconeUnmappedHttpError;
/** @internal */ const mapHttpStatusError = (failedRequestInfo)=>{
    switch(failedRequestInfo.status){
        case 400:
            return new PineconeBadRequestError(failedRequestInfo);
        case 401:
            return new PineconeAuthorizationError(failedRequestInfo);
        case 403:
            return new PineconeBadRequestError(failedRequestInfo);
        case 404:
            return new PineconeNotFoundError(failedRequestInfo);
        case 409:
            return new PineconeConflictError(failedRequestInfo);
        case 500:
            return new PineconeInternalServerError(failedRequestInfo);
        case 501:
            return new PineconeNotImplementedError(failedRequestInfo);
        case 503:
            return new PineconeUnavailableError(failedRequestInfo);
        default:
            throw new PineconeUnmappedHttpError(failedRequestInfo);
    }
};
exports.mapHttpStatusError = mapHttpStatusError; //# sourceMappingURL=http.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/request.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PineconeRequestError = exports.PineconeConnectionError = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)");
/**
 * This error is thrown when the client attempts to make a
 * request and never receives any response.
 *
 * This could be due to:
 * - Network problems which prevent the request from being completed.
 * - An outage of Pinecone's APIs. See [Pinecone's status page](https://status.pinecone.io/) to find out whether there is an ongoing incident.
 *
 * The `cause` property will contain a reference to the underlying error. Inspect its value to find out more about the root cause of the error.
 * ```
 * import { Pinecone } from '@pinecone-database/pinecone';
 *
 * const p = new Pinecone({ apiKey: 'invalid-api-key-value' })
 *
 * try {
 *  await p.listIndexes();
 * } catch (e) {
 *  console.log(e.name); // PineconeConnectionError
 *  console.log(e.cause); // Error [FetchError]: The request failed and the interceptors did not return an alternative response
 *  console.log(e.cause.cause); // TypeError: fetch failed
 *  console.log(e.cause.cause.cause); // Error: getaddrinfo ENOTFOUND controller.wrong-environment.pinecone.io
 * }
 * ```
 *
 * @see [Pinecone's status page](https://status.pinecone.io/)
 * */ class PineconeConnectionError extends base_1.BasePineconeError {
    constructor(e, url){
        let urlMessage = '';
        if (url) {
            urlMessage = ` while calling ${url}`;
        }
        super(`Request failed to reach Pinecone${urlMessage}. This can occur for reasons such as network problems that prevent the request from being completed, or a Pinecone API outage. Check your network connection, and visit https://status.pinecone.io/ to see whether any outages are ongoing.`, e);
        this.name = 'PineconeConnectionError';
    }
}
exports.PineconeConnectionError = PineconeConnectionError;
/**
 * This error is thrown any time a request to the Pinecone API fails.
 *
 * The `cause` property will contain a reference to the underlying error. Inspect its value to find out more about the root cause.
 */ class PineconeRequestError extends base_1.BasePineconeError {
    constructor(context){
        if (context.response) {
            super(`Request failed during a call to ${context.init.method} ${context.url} with status ${context.response.status}`, context.error);
        } else {
            super(`Request failed during a call to ${context.init.method} ${context.url}`, context.error);
        }
    }
}
exports.PineconeRequestError = PineconeRequestError; //# sourceMappingURL=request.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/validation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PineconeArgumentError = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)");
/**
 * This error is thrown when arguments passed to a Pinecone
 * client method fail a runtime validation.
 */ class PineconeArgumentError extends base_1.BasePineconeError {
    constructor(message){
        super(`${message}`);
        this.name = 'PineconeArgumentError';
    }
}
exports.PineconeArgumentError = PineconeArgumentError; //# sourceMappingURL=validation.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/utils.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extractMessage = void 0;
/** @internal */ const extractMessage = async (error)=>{
    let message = await error.response.text();
    // Error response is sometimes the raw message, sometimes it's JSON
    // so we will try to parse out the actual message text, but
    // we wrap it in a try to avoid crashing in a way that obscures
    // the actual error if the response format changes in the future.
    try {
        const messageJSON = JSON.parse(message);
        if (messageJSON.message) {
            message = messageJSON.message;
        }
    } catch (e) {
    // noop
    }
    return message;
};
exports.extractMessage = extractMessage; //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/handling.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleApiError = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/utils.js [app-route] (ecmascript)");
const http_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/http.js [app-route] (ecmascript)");
const request_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/request.js [app-route] (ecmascript)");
/** @internal */ const handleApiError = async (e, customMessage, url)=>{
    if (e instanceof Error && e.name === 'ResponseError') {
        const responseError = e;
        const rawMessage = await (0, utils_1.extractMessage)(responseError);
        const statusCode = responseError.response.status;
        const message = customMessage ? await customMessage(statusCode, rawMessage) : rawMessage;
        return (0, http_1.mapHttpStatusError)({
            status: responseError.response.status,
            url: responseError.response.url || url,
            message: message
        });
    } else if (e instanceof request_1.PineconeConnectionError) {
        // If we've already wrapped this error, just return it
        return e;
    } else {
        // There seem to be some situations where "e instanceof Error" is erroneously
        // false (perhaps the custom errors emitted by cross-fetch do not extend Error?)
        // but we can still cast it to an Error type because all we're going to do
        // with it is store off a reference to whatever it is under the "cause"
        const err = e;
        return new request_1.PineconeConnectionError(err);
    }
};
exports.handleApiError = handleApiError; //# sourceMappingURL=handling.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleApiError = exports.extractMessage = exports.PineconeArgumentError = exports.BasePineconeError = exports.PineconeRequestError = exports.PineconeConnectionError = exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = void 0;
var config_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/config.js [app-route] (ecmascript)");
Object.defineProperty(exports, "PineconeConfigurationError", {
    enumerable: true,
    get: function() {
        return config_1.PineconeConfigurationError;
    }
});
Object.defineProperty(exports, "PineconeUnexpectedResponseError", {
    enumerable: true,
    get: function() {
        return config_1.PineconeUnexpectedResponseError;
    }
});
Object.defineProperty(exports, "PineconeEnvironmentVarsNotSupportedError", {
    enumerable: true,
    get: function() {
        return config_1.PineconeEnvironmentVarsNotSupportedError;
    }
});
Object.defineProperty(exports, "PineconeUnableToResolveHostError", {
    enumerable: true,
    get: function() {
        return config_1.PineconeUnableToResolveHostError;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/http.js [app-route] (ecmascript)"), exports);
var request_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/request.js [app-route] (ecmascript)");
Object.defineProperty(exports, "PineconeConnectionError", {
    enumerable: true,
    get: function() {
        return request_1.PineconeConnectionError;
    }
});
Object.defineProperty(exports, "PineconeRequestError", {
    enumerable: true,
    get: function() {
        return request_1.PineconeRequestError;
    }
});
var base_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/base.js [app-route] (ecmascript)");
Object.defineProperty(exports, "BasePineconeError", {
    enumerable: true,
    get: function() {
        return base_1.BasePineconeError;
    }
});
var validation_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/validation.js [app-route] (ecmascript)");
Object.defineProperty(exports, "PineconeArgumentError", {
    enumerable: true,
    get: function() {
        return validation_1.PineconeArgumentError;
    }
});
var utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/utils.js [app-route] (ecmascript)");
Object.defineProperty(exports, "extractMessage", {
    enumerable: true,
    get: function() {
        return utils_1.extractMessage;
    }
});
var handling_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/handling.js [app-route] (ecmascript)");
Object.defineProperty(exports, "handleApiError", {
    enumerable: true,
    get: function() {
        return handling_1.handleApiError;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/fetch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFetch = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const getFetch = (config)=>{
    if (config.fetchApi) {
        // User-provided fetch implementation, if any, takes precedence.
        return config.fetchApi;
    } else if (/*TURBOPACK member replacement*/ __turbopack_context__.g.fetch) {
        // If a fetch implementation is present in the global scope (will work with native fetch in Node18+, Edge runtimes,
        // etc.), use that. This should prevent confusing failures in
        // Next.js projects where @vercel/fetch is mandated and
        // other implementations are stubbed out.
        return /*TURBOPACK member replacement*/ __turbopack_context__.g.fetch;
    } else {
        // If no fetch implementation is found, throw an error.
        throw new errors_1.PineconeConfigurationError('No global or user-provided fetch implementations found. Please supply a fetch implementation.');
    }
};
exports.getFetch = getFetch; //# sourceMappingURL=fetch.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/retries.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RetryOnServerFailure = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
// TODO: Parameterize this class to allow for custom error handling (e.g. only retry 400 errors on Chat endpoint,
//  but not globally
/* Retry asynchronous operations.
 *
 * @param maxRetries - The maximum number of retries to attempt.
 * @param asyncFn - The asynchronous function to retry.
 */ class RetryOnServerFailure {
    constructor(asyncFn, maxRetries){
        /*
         * Calculate the delay time for retrying an operation.
         *
         * @param attempt: The # of times the operation has been attempted.
         * @param baseDelay: The base delay time in milliseconds.
         * @param maxDelay: The maximum delay time in milliseconds.
         * @param jitterFactor: The magnitude of jitter relative to the delay.
         */ this.calculateRetryDelay = (attempt, baseDelay = 200, maxDelay = 20000, jitterFactor = 0.25)=>{
            let delay = baseDelay * 2 ** attempt; // Exponential (baseDelay * 2^attempt)
            // Apply jitter as a random percentage of the original delay; e.g.: if `jitterFactor` = 0.25 and `baseDelay` = 1000,
            // then `jitter` is 25% of `baseDelay`
            const jitter = delay * jitterFactor * (Math.random() - 0.5);
            delay += jitter;
            // Ensure delay is not negative or greater than maxDelay
            return Math.min(maxDelay, Math.max(0, delay));
        };
        if (maxRetries) {
            this.maxRetries = maxRetries;
        } else {
            this.maxRetries = 3;
        }
        if (this.maxRetries > 10) {
            throw new Error('Max retries cannot exceed 10');
        }
        this.asyncFn = asyncFn;
    }
    async execute(...args) {
        if (this.maxRetries < 1) {
            return this.asyncFn(...args);
        }
        for(let attempt = 0; attempt < this.maxRetries; attempt++){
            try {
                const response = await this.asyncFn(...args);
                // Return immediately if the response is not a retryable error
                if (!this.isRetryError(response)) {
                    return response;
                }
                throw response; // Will catch this in next line
            } catch (error) {
                const mappedError = this.mapErrorIfNeeded(error);
                // If the error is not retryable, throw it immediately
                if (this.shouldStopRetrying(mappedError)) {
                    throw mappedError;
                }
                // On the last retry, throw a MaxRetriesExceededError
                if (attempt === this.maxRetries - 1) {
                    throw new errors_1.PineconeMaxRetriesExceededError(this.maxRetries);
                }
                // Wait before retrying
                await this.delay(attempt + 1);
            }
        }
        // This fallback is unnecessary, but included for type safety
        throw new errors_1.PineconeMaxRetriesExceededError(this.maxRetries);
    }
    isRetryError(response) {
        if (!response) {
            return false;
        }
        if (response) {
            if (response.name && [
                'PineconeUnavailableError',
                'PineconeInternalServerError'
            ].includes(response.name)) {
                return true;
            }
            if (response.status && response.status >= 500) {
                return true;
            }
        }
        return false;
    }
    async delay(attempt) {
        const delayTime = this.calculateRetryDelay(attempt);
        return new Promise((resolve)=>setTimeout(resolve, delayTime));
    }
    mapErrorIfNeeded(error) {
        if (error?.status) {
            return (0, errors_1.mapHttpStatusError)(error);
        }
        return error; // Return original error if no mapping is needed
    }
    shouldStopRetrying(error) {
        if (error.status) {
            return error.status < 500;
        }
        if (error.name) {
            return error.name !== 'PineconeUnavailableError' && error.name !== 'PineconeInternalServerError';
        }
        return true;
    }
}
exports.RetryOnServerFailure = RetryOnServerFailure; //# sourceMappingURL=retries.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/convertKeys.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertKeysToCamelCase = void 0;
// converts keys of a json payload from snake_case to camelCase
const convertKeysToCamelCase = (object)=>{
    if (Array.isArray(object)) {
        return object.map((item)=>(0, exports.convertKeysToCamelCase)(item));
    } else if (object !== null && typeof object === 'object') {
        return Object.entries(object).reduce((acc, [key, value])=>{
            const camelKey = toCamelCase(key);
            acc[camelKey] = (0, exports.convertKeysToCamelCase)(value);
            return acc;
        }, {});
    }
    return object; // return primitives as is
};
exports.convertKeysToCamelCase = convertKeysToCamelCase;
// converts snake-case keys to camelCase
const toCamelCase = (str)=>str.replace(/_([a-z])/g, (_, letter)=>letter.toUpperCase()); //# sourceMappingURL=convertKeys.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/chatStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatStream = void 0;
const convertKeys_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/convertKeys.js [app-route] (ecmascript)");
/**
 * Implements an async iterable that processes the readable stream of an assistant chat response.
 *
 * This class expects each chunk of data in the stream to begin with `data:` and be followed by a valid chunk of JSON.
 * If a chunk contains malformed JSON, it is skipped, and a debug message is logged.
 *
 * @template Item - The type of items yielded by the iterable.
 */ class ChatStream {
    constructor(stream){
        this.stream = stream;
    }
    async *[Symbol.asyncIterator]() {
        let buffer = '';
        for await (const chunk of this.stream){
            buffer += chunk.toString();
            let newlineIndex;
            while((newlineIndex = buffer.indexOf('\n')) !== -1){
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                // each chunk of json should begin with 'data:'
                if (line && line.startsWith('data:')) {
                    const json = line.slice(5).trim();
                    try {
                        const parsedJson = JSON.parse(json);
                        const convertedJson = (0, convertKeys_1.convertKeysToCamelCase)(parsedJson);
                        yield convertedJson;
                    } catch (err) {
                        console.debug(`Skipping malformed JSON:${line}`);
                        continue;
                    }
                }
            }
        }
        if (buffer.trim()) {
            try {
                const parsedJson = JSON.parse(buffer);
                const convertedJson = (0, convertKeys_1.convertKeysToCamelCase)(parsedJson);
                yield convertedJson;
            } catch (err) {
                console.debug(`Skipping malformed JSON:${buffer}`);
            }
        }
    }
}
exports.ChatStream = ChatStream; //# sourceMappingURL=chatStream.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatStream = exports.RetryOnServerFailure = exports.convertKeysToCamelCase = exports.getFetch = exports.buildUserAgent = exports.queryParamsStringify = exports.normalizeUrl = exports.debugLog = void 0;
const debugLog_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js [app-route] (ecmascript)");
Object.defineProperty(exports, "debugLog", {
    enumerable: true,
    get: function() {
        return debugLog_1.debugLog;
    }
});
const normalizeUrl_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/normalizeUrl.js [app-route] (ecmascript)");
Object.defineProperty(exports, "normalizeUrl", {
    enumerable: true,
    get: function() {
        return normalizeUrl_1.normalizeUrl;
    }
});
const queryParamsStringify_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js [app-route] (ecmascript)");
Object.defineProperty(exports, "queryParamsStringify", {
    enumerable: true,
    get: function() {
        return queryParamsStringify_1.queryParamsStringify;
    }
});
const user_agent_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js [app-route] (ecmascript)");
Object.defineProperty(exports, "buildUserAgent", {
    enumerable: true,
    get: function() {
        return user_agent_1.buildUserAgent;
    }
});
const fetch_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/fetch.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getFetch", {
    enumerable: true,
    get: function() {
        return fetch_1.getFetch;
    }
});
const retries_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/retries.js [app-route] (ecmascript)");
Object.defineProperty(exports, "RetryOnServerFailure", {
    enumerable: true,
    get: function() {
        return retries_1.RetryOnServerFailure;
    }
});
const chatStream_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/chatStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatStream", {
    enumerable: true,
    get: function() {
        return chatStream_1.ChatStream;
    }
});
const convertKeys_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/convertKeys.js [app-route] (ecmascript)");
Object.defineProperty(exports, "convertKeysToCamelCase", {
    enumerable: true,
    get: function() {
        return convertKeys_1.convertKeysToCamelCase;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.middleware = void 0;
const db_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const debugMiddleware = [];
const chalk = (str, color)=>{
    const colors = {
        blue: '\x1b[34m',
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m'
    };
    return colors[color] + str + '\x1b[39m';
};
/**
 * Enable the `PINECONE_DEBUG` environment variable to print the request and
 * response bodies for each request.
 *
 * Api-Key headers will be redacted.
 */ if (typeof process !== 'undefined' && process && process.env && process.env.PINECONE_DEBUG) {
    const debugLogMiddleware = {
        pre: async (context)=>{
            console.debug(chalk(`>>> Request: ${context.init.method} ${context.url}`, 'blue'));
            const headers = JSON.parse(JSON.stringify(context.init.headers));
            headers['Api-Key'] = '***REDACTED***';
            console.debug(chalk(`>>> Headers: ${JSON.stringify(headers)}`, 'blue'));
            if (context.init.body) {
                console.debug(chalk(`>>> Body: ${context.init.body}`, 'blue'));
            }
            console.debug('');
        },
        post: async (context)=>{
            console.debug(chalk(`<<< Status: ${context.response.status}`, 'green'));
            console.debug(chalk(`<<< Body: ${await context.response.text()}`, 'green'));
            console.debug('');
        }
    };
    debugMiddleware.push(debugLogMiddleware);
}
/**
 * Enable the `PINECONE_DEBUG_CURL` environment variable to print the equivalent
 * curl commands for each request. These commands will include the API key and
 * other sensitive information, so be careful when using this option.
 */ if (typeof process !== 'undefined' && process && process.env && process.env.PINECONE_DEBUG_CURL) {
    const debugCurlMiddleware = {
        post: async (context)=>{
            let headers = `-H "Api-Key: ${(context.init.headers || {})['Api-Key']}"`;
            if (context.init.headers && context.init.headers['Content-Type']) {
                headers += ` -H "Content-Type: ${context.init.headers['Content-Type']}"`;
            }
            const cmd = `curl -X ${context.init.method} ${context.url} ${headers} ${context.init.body ? `-d '${context.init.body}'` : ''}`;
            console.debug(chalk(cmd, 'red'));
            console.debug('');
        }
    };
    debugMiddleware.push(debugCurlMiddleware);
}
exports.middleware = [
    ...debugMiddleware,
    {
        onError: async (context)=>{
            const err = await (0, errors_1.handleApiError)(context.error, undefined, context.url);
            throw err;
        },
        post: async (context)=>{
            const { response } = context;
            if (response.status >= 200 && response.status < 300) {
                return response;
            } else {
                const err = await (0, errors_1.handleApiError)(new db_control_1.ResponseError(response, 'Response returned an error'), undefined, context.url);
                throw err;
            }
        }
    }
]; //# sourceMappingURL=middleware.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/indexOperationsBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.indexOperationsBuilder = void 0;
const db_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
const indexOperationsBuilder = (config)=>{
    const { apiKey } = config;
    const controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || 'https://api.pinecone.io';
    const headers = config.additionalHeaders || null;
    const apiConfig = {
        basePath: controllerPath,
        apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: {
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': db_control_1.X_PINECONE_API_VERSION,
            ...headers
        },
        fetchApi: (0, utils_1.getFetch)(config),
        middleware: middleware_1.middleware
    };
    return new db_control_1.ManageIndexesApi(new db_control_1.Configuration(apiConfig));
};
exports.indexOperationsBuilder = indexOperationsBuilder; //# sourceMappingURL=indexOperationsBuilder.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidateObjectProperties = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
function ValidateObjectProperties(item, validProperties) {
    const itemKeys = Object.keys(item);
    // Check for any keys in `item` that are not in `validProperties`
    const invalidKeys = itemKeys.filter((key)=>!validProperties.includes(key));
    if (invalidKeys.length > 0) {
        throw new errors_1.PineconeArgumentError(`Object contained invalid properties: ${invalidKeys.join(', ')}. Valid properties include ${validProperties.join(', ')}.`);
    }
}
exports.ValidateObjectProperties = ValidateObjectProperties; //# sourceMappingURL=validateObjectProperties.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.configureIndex = exports.ConfigureIndexRequestProperties = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
exports.ConfigureIndexRequestProperties = [
    'deletionProtection',
    'spec',
    'tags',
    'embed'
];
const configureIndex = (api)=>{
    const validator = (indexName, options)=>{
        if (options) {
            (0, validateObjectProperties_1.ValidateObjectProperties)(options, exports.ConfigureIndexRequestProperties);
        }
        if (!indexName) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `indexName` to configureIndex.');
        }
        // !options.deletionProtection evaluates to false if options.deletionProtection is undefined, empty string, or
        // not provided
        if (!options.spec && !options.deletionProtection && !options.tags && !options.embed) {
            throw new errors_1.PineconeArgumentError('You must pass either `spec`, `deletionProtection`, `tags`, or `embed` to configureIndex in order to update.');
        }
        if (options.spec) {
            if (options.spec.pod) {
                (0, validateObjectProperties_1.ValidateObjectProperties)(options.spec.pod, [
                    'replicas',
                    'podType'
                ]);
            }
            if (options.spec.pod && options.spec.pod.replicas) {
                if (options.spec.pod.replicas <= 0) {
                    throw new errors_1.PineconeArgumentError('`replicas` must be a positive integer.');
                }
            }
        }
    };
    return async (indexName, options, maxRetries)=>{
        validator(indexName, options);
        const retryWrapper = new utils_1.RetryOnServerFailure(api.configureIndex.bind(api), maxRetries);
        return await retryWrapper.execute({
            indexName,
            configureIndexRequest: options
        });
    };
};
exports.configureIndex = configureIndex; //# sourceMappingURL=configureIndex.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidPodTypes = void 0;
exports.ValidPodTypes = [
    's1.x1',
    's1.x2',
    's1.x4',
    's1.x8',
    'p1.x1',
    'p1.x2',
    'p1.x4',
    'p1.x8',
    'p2.x1',
    'p2.x2',
    'p2.x4',
    'p2.x8'
]; //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.waitUntilIndexIsReady = exports.createIndex = void 0;
const db_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/types.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const CreateIndexOptionsProperties = [
    'spec',
    'name',
    'dimension',
    'metric',
    'deletionProtection',
    'waitUntilReady',
    'suppressConflicts',
    'tags',
    'vectorType'
];
const CreateIndexSpecProperties = [
    'serverless',
    'pod'
];
const CreateIndexServerlessSpecProperties = [
    'cloud',
    'region',
    'sourceCollection'
];
const CreateIndexPodSpecProperties = [
    'environment',
    'replicas',
    'shards',
    'podType',
    'pods',
    'metadataConfig',
    'sourceCollection'
];
const createIndex = (api)=>{
    return async (options)=>{
        if (!options) {
            throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`name`, `dimension`, `spec`) to create an index.');
        }
        // If metric is not specified for a sparse index, default to dotproduct
        if (options.vectorType && options.vectorType.toLowerCase() === 'sparse') {
            if (!options.metric) {
                options.metric = db_control_1.IndexModelMetricEnum.Dotproduct;
            }
        } else {
            // If metric is not specified for a dense index, default to cosine
            if (!options.metric) {
                options.metric = db_control_1.IndexModelMetricEnum.Cosine;
            }
        }
        validateCreateIndexRequest(options);
        try {
            const createResponse = await api.createIndex({
                createIndexRequest: options
            });
            if (options.waitUntilReady) {
                return await (0, exports.waitUntilIndexIsReady)(api, options.name);
            }
            return createResponse;
        } catch (e) {
            if (!(options.suppressConflicts && e instanceof Error && e.name === 'PineconeConflictError')) {
                throw e;
            }
        }
    };
};
exports.createIndex = createIndex;
const waitUntilIndexIsReady = async (api, indexName, seconds = 0)=>{
    try {
        const indexDescription = await api.describeIndex({
            indexName
        });
        if (!indexDescription.status?.ready) {
            await new Promise((r)=>setTimeout(r, 1000));
            return await (0, exports.waitUntilIndexIsReady)(api, indexName, seconds + 1);
        } else {
            (0, utils_1.debugLog)(`Index ${indexName} is ready after ${seconds}`);
            return indexDescription;
        }
    } catch (e) {
        const err = await (0, errors_1.handleApiError)(e, async (_, rawMessageText)=>`Error creating index ${indexName}: ${rawMessageText}`);
        throw err;
    }
};
exports.waitUntilIndexIsReady = waitUntilIndexIsReady;
const validateCreateIndexRequest = (options)=>{
    // validate options properties
    if (options) {
        (0, validateObjectProperties_1.ValidateObjectProperties)(options, CreateIndexOptionsProperties);
    }
    if (!options.name) {
        throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to create an index.');
    }
    if (options.dimension && options.dimension <= 0) {
        throw new errors_1.PineconeArgumentError('You must pass a positive integer for `dimension` in order to create an index.');
    }
    // validate options.spec properties
    if (!options.spec) {
        throw new errors_1.PineconeArgumentError('You must pass a `pods` or `serverless` `spec` object in order to create an index.');
    }
    if (options.spec) {
        (0, validateObjectProperties_1.ValidateObjectProperties)(options.spec, CreateIndexSpecProperties);
    }
    // validate options.metric
    if (options.metric && !Object.values(db_control_1.IndexModelMetricEnum).includes(options.metric)) {
        {
            throw new errors_1.PineconeArgumentError(`Invalid metric value: ${options.metric}. Valid values are: 'cosine', 'euclidean', or 'dotproduct.'`);
        }
    }
    // validate options.spec.serverless properties if serverless spec is passed
    if (options.spec.serverless) {
        (0, validateObjectProperties_1.ValidateObjectProperties)(options.spec.serverless, CreateIndexServerlessSpecProperties);
        // extract and default vectorType to 'dense' if not specified
        const vectorType = options.vectorType ? options.vectorType.toLowerCase() : 'dense';
        if (vectorType !== 'dense' && vectorType !== 'sparse') {
            throw new errors_1.PineconeArgumentError('Invalid `vectorType` value. Valid values are `dense` or `sparse`.');
        }
        // sparse indexes must have a metric of 'dotproduct' and no dimension
        if (vectorType == 'sparse') {
            if (options.dimension && options.dimension > 0) {
                throw new errors_1.PineconeArgumentError('Sparse indexes cannot have a `dimension`.');
            }
            if (options.metric && options.metric !== 'dotproduct') {
                throw new errors_1.PineconeArgumentError('Sparse indexes must have a `metric` of `dotproduct`.');
            }
        } else if (vectorType == 'dense') {
            // dense indexes must have a dimension
            if (!options.dimension || options.dimension <= 0) {
                throw new errors_1.PineconeArgumentError('You must pass a positive `dimension` when creating a dense index.');
            }
        }
        // validate serverless cloud & region
        if (!options.spec.serverless.cloud) {
            throw new errors_1.PineconeArgumentError('You must pass a `cloud` for the serverless `spec` object in order to create an index.');
        }
        if (options.spec.serverless.cloud && !Object.values(db_control_1.ServerlessSpecCloudEnum).includes(options.spec.serverless.cloud)) {
            throw new errors_1.PineconeArgumentError(`Invalid cloud value: ${options.spec.serverless.cloud}. Valid values are: ${Object.values(db_control_1.ServerlessSpecCloudEnum).join(', ')}.`);
        }
        if (!options.spec.serverless.region) {
            throw new errors_1.PineconeArgumentError('You must pass a `region` for the serverless `spec` object in order to create an index.');
        }
    } else if (options.spec.pod) {
        // validate options.spec.pod properties if pod spec is passed
        (0, validateObjectProperties_1.ValidateObjectProperties)(options.spec.pod, CreateIndexPodSpecProperties);
        if (!options.spec.pod.environment) {
            throw new errors_1.PineconeArgumentError('You must pass an `environment` for the pod `spec` object in order to create an index.');
        }
        // pod indexes must have a dimension
        if (!options.dimension || options.dimension <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive `dimension` when creating a dense index.');
        }
        // pod indexes must be dense
        const vectorType = 'dense';
        if (options.vectorType && options.vectorType.toLowerCase() !== vectorType) {
            throw new errors_1.PineconeArgumentError('Pod indexes must have a `vectorType` of `dense`.');
        }
        if (!options.spec.pod.podType) {
            throw new errors_1.PineconeArgumentError('You must pass a `podType` for the pod `spec` object in order to create an index.');
        }
        if (options.spec.pod.replicas && options.spec.pod.replicas <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive integer for `replicas` in order to create an index.');
        }
        if (options.spec.pod.pods && options.spec.pod.pods <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive integer for `pods` in order to create an index.');
        }
        if (!types_1.ValidPodTypes.includes(options.spec.pod.podType)) {
            throw new errors_1.PineconeArgumentError(`Invalid pod type: ${options.spec.pod.podType}. Valid values are: ${types_1.ValidPodTypes.join(', ')}.`);
        }
    }
}; //# sourceMappingURL=createIndex.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndexForModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIndexForModel = void 0;
const db_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const createIndex_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndex.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const CreateIndexForModelOptionsProperties = [
    'name',
    'cloud',
    'region',
    'embed',
    'deletionProtection',
    'tags',
    'waitUntilReady',
    'suppressConflicts'
];
const CreateIndexForModelEmbedProperties = [
    'model',
    'metric',
    'fieldMap',
    'readParameters',
    'writeParameters'
];
const createIndexForModel = (api)=>{
    return async (options)=>{
        if (!options) {
            throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`name`, `cloud`, `region`, and an `embed`)');
        }
        validateCreateIndexForModelRequest(options);
        try {
            const createResponse = await api.createIndexForModel({
                createIndexForModelRequest: options
            });
            if (options.waitUntilReady) {
                return await (0, createIndex_1.waitUntilIndexIsReady)(api, createResponse.name);
            }
            return createResponse;
        } catch (e) {
            if (!(options.suppressConflicts && e instanceof Error && e.name === 'PineconeConflictError')) {
                throw e;
            }
        }
    };
};
exports.createIndexForModel = createIndexForModel;
const validateCreateIndexForModelRequest = (options)=>{
    // validate options properties
    if (options) {
        (0, validateObjectProperties_1.ValidateObjectProperties)(options, CreateIndexForModelOptionsProperties);
    }
    if (!options.name) {
        throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to create an index.');
    }
    if (!options.cloud) {
        throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `cloud` in order to create an index.');
    }
    if (options.cloud && !Object.values(db_control_1.ServerlessSpecCloudEnum).includes(options.cloud)) {
        throw new errors_1.PineconeArgumentError(`Invalid cloud value: ${options.cloud}. Valid values are: ${Object.values(db_control_1.ServerlessSpecCloudEnum).join(', ')}.`);
    }
    if (!options.region) {
        throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `region` in order to create an index.');
    }
    if (!options.embed) {
        throw new errors_1.PineconeArgumentError('You must pass an `embed` object in order to create an index.');
    }
    // validate embed properties
    if (options.embed) {
        (0, validateObjectProperties_1.ValidateObjectProperties)(options.embed, CreateIndexForModelEmbedProperties);
    }
    if (options.embed.metric && !Object.values(db_control_1.IndexModelMetricEnum).includes(options.embed.metric)) {
        {
            throw new errors_1.PineconeArgumentError(`Invalid metric value: ${options.embed.metric}. Valid values are: ${Object.values(db_control_1.IndexModelMetricEnum).join(', ')}.`);
        }
    }
}; //# sourceMappingURL=createIndexForModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteIndex = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteIndex = (api)=>{
    return async (indexName)=>{
        if (!indexName) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `indexName` in order to delete an index');
        }
        await api.deleteIndex({
            indexName
        });
        return;
    };
};
exports.deleteIndex = deleteIndex; //# sourceMappingURL=deleteIndex.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeIndex = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const describeIndex = (api)=>{
    const removeDeprecatedFields = (result)=>{
        if (result.database) {
            for (const key of Object.keys(result.database)){
                if (result.database[key] === undefined) {
                    delete result.database[key];
                }
            }
        }
    };
    return async (indexName)=>{
        if (!indexName) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to describe an index');
        }
        const result = await api.describeIndex({
            indexName
        });
        removeDeprecatedFields(result);
        return result;
    };
};
exports.describeIndex = describeIndex; //# sourceMappingURL=describeIndex.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listIndexes = void 0;
const listIndexes = (api)=>{
    return async ()=>{
        const response = await api.listIndexes();
        return response;
    };
};
exports.listIndexes = listIndexes; //# sourceMappingURL=listIndexes.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/createCollection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCollection = exports.CreateCollectionRequestProperties = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
exports.CreateCollectionRequestProperties = [
    'source',
    'name'
];
const createCollection = (api)=>{
    const validator = (options)=>{
        if (options) {
            (0, validateObjectProperties_1.ValidateObjectProperties)(options, exports.CreateCollectionRequestProperties);
        }
        if (!options || typeof options !== 'object') {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty object with `name` and `source` fields in order to create a collection.');
        }
        if (!options.name && !options.source) {
            throw new errors_1.PineconeArgumentError('The argument to createCollection must have required properties: `name`, `source`.');
        }
        if (!options.name) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to create a collection.');
        }
        if (!options.source) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `source` in order to create a collection.');
        }
    };
    return async (options)=>{
        validator(options);
        return await api.createCollection({
            createCollectionRequest: options
        });
    };
};
exports.createCollection = createCollection; //# sourceMappingURL=createCollection.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteCollection = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteCollection = (api)=>{
    return async (collectionName)=>{
        if (!collectionName) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `collectionName`');
        }
        await api.deleteCollection({
            collectionName
        });
        return;
    };
};
exports.deleteCollection = deleteCollection; //# sourceMappingURL=deleteCollection.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeCollection = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const describeCollection = (api)=>{
    return async (name)=>{
        if (!name || name.length === 0) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to describe a collection');
        }
        return await api.describeCollection({
            collectionName: name
        });
    };
};
exports.describeCollection = describeCollection; //# sourceMappingURL=describeCollection.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/listCollections.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listCollections = void 0;
const listCollections = (api)=>{
    return async ()=>{
        const results = await api.listCollections();
        return results;
    };
};
exports.listCollections = listCollections; //# sourceMappingURL=listCollections.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/createBackup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createBackup = void 0;
const createBackup = (api)=>{
    return async (createBackupOptions)=>{
        if (!createBackupOptions.indexName) {
            throw new Error('You must pass a non-empty string for `indexName` in order to create a backup');
        }
        return await api.createBackup({
            indexName: createBackupOptions.indexName,
            createBackupRequest: {
                name: createBackupOptions.name,
                description: createBackupOptions.description
            }
        });
    };
};
exports.createBackup = createBackup; //# sourceMappingURL=createBackup.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndexFromBackup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIndexFromBackup = void 0;
const createIndexFromBackup = (api)=>{
    return async (createIndexFromBackupOptions)=>{
        if (!createIndexFromBackupOptions.backupId) {
            throw new Error('You must pass a non-empty string for `backupId` in order to create an index from backup');
        } else if (!createIndexFromBackupOptions.name) {
            throw new Error('You must pass a non-empty string for `name` in order to create an index from backup');
        }
        return await api.createIndexFromBackupOperation({
            backupId: createIndexFromBackupOptions.backupId,
            createIndexFromBackupRequest: {
                name: createIndexFromBackupOptions.name,
                tags: createIndexFromBackupOptions.tags,
                deletionProtection: createIndexFromBackupOptions.deletionProtection
            }
        });
    };
};
exports.createIndexFromBackup = createIndexFromBackup; //# sourceMappingURL=createIndexFromBackup.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/describeBackup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeBackup = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const describeBackup = (api)=>{
    return async (backupId)=>{
        if (!backupId) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `backupId` in order to describe a backup');
        }
        return await api.describeBackup({
            backupId: backupId
        });
    };
};
exports.describeBackup = describeBackup; //# sourceMappingURL=describeBackup.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/describeRestoreJob.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeRestoreJob = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const describeRestoreJob = (api)=>{
    return async (restoreJobId)=>{
        if (!restoreJobId) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `restoreJobId` in order to describe a restore job');
        }
        return await api.describeRestoreJob({
            jobId: restoreJobId
        });
    };
};
exports.describeRestoreJob = describeRestoreJob; //# sourceMappingURL=describeRestoreJob.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/listBackups.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listBackups = void 0;
const listBackups = (api)=>{
    return async (listBackupOptions = {})=>{
        const { indexName, ...rest } = listBackupOptions;
        if (!indexName) {
            return await api.listProjectBackups({
                ...rest
            });
        } else {
            return await api.listIndexBackups({
                indexName,
                ...rest
            });
        }
    };
};
exports.listBackups = listBackups; //# sourceMappingURL=listBackups.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/listRestoreJobs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listRestoreJobs = void 0;
const listRestoreJobs = (api)=>{
    return async (listBackupOptions)=>{
        return await api.listRestoreJobs(listBackupOptions);
    };
};
exports.listRestoreJobs = listRestoreJobs; //# sourceMappingURL=listRestoreJobs.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteBackup.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteBackup = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteBackup = (api)=>{
    return async (backupId)=>{
        if (!backupId) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `backupId` in order to delete a backup');
        }
        return await api.deleteBackup({
            backupId: backupId
        });
    };
};
exports.deleteBackup = deleteBackup; //# sourceMappingURL=deleteBackup.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/control/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteBackup = exports.listRestoreJobs = exports.listBackups = exports.describeRestoreJob = exports.describeBackup = exports.createIndexFromBackup = exports.createBackup = exports.listCollections = exports.describeCollection = exports.deleteCollection = exports.createCollection = exports.listIndexes = exports.describeIndex = exports.deleteIndex = exports.createIndexForModel = exports.createIndex = exports.configureIndex = exports.indexOperationsBuilder = void 0;
// Index Operations
var indexOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/indexOperationsBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "indexOperationsBuilder", {
    enumerable: true,
    get: function() {
        return indexOperationsBuilder_1.indexOperationsBuilder;
    }
});
var configureIndex_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js [app-route] (ecmascript)");
Object.defineProperty(exports, "configureIndex", {
    enumerable: true,
    get: function() {
        return configureIndex_1.configureIndex;
    }
});
var createIndex_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndex.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createIndex", {
    enumerable: true,
    get: function() {
        return createIndex_1.createIndex;
    }
});
var createIndexForModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndexForModel.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createIndexForModel", {
    enumerable: true,
    get: function() {
        return createIndexForModel_1.createIndexForModel;
    }
});
var deleteIndex_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js [app-route] (ecmascript)");
Object.defineProperty(exports, "deleteIndex", {
    enumerable: true,
    get: function() {
        return deleteIndex_1.deleteIndex;
    }
});
var describeIndex_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js [app-route] (ecmascript)");
Object.defineProperty(exports, "describeIndex", {
    enumerable: true,
    get: function() {
        return describeIndex_1.describeIndex;
    }
});
var listIndexes_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listIndexes", {
    enumerable: true,
    get: function() {
        return listIndexes_1.listIndexes;
    }
});
var createCollection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createCollection.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createCollection", {
    enumerable: true,
    get: function() {
        return createCollection_1.createCollection;
    }
});
var deleteCollection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js [app-route] (ecmascript)");
Object.defineProperty(exports, "deleteCollection", {
    enumerable: true,
    get: function() {
        return deleteCollection_1.deleteCollection;
    }
});
var describeCollection_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js [app-route] (ecmascript)");
Object.defineProperty(exports, "describeCollection", {
    enumerable: true,
    get: function() {
        return describeCollection_1.describeCollection;
    }
});
var listCollections_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/listCollections.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listCollections", {
    enumerable: true,
    get: function() {
        return listCollections_1.listCollections;
    }
});
var createBackup_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createBackup.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createBackup", {
    enumerable: true,
    get: function() {
        return createBackup_1.createBackup;
    }
});
var createIndexFromBackup_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/createIndexFromBackup.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createIndexFromBackup", {
    enumerable: true,
    get: function() {
        return createIndexFromBackup_1.createIndexFromBackup;
    }
});
var describeBackup_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/describeBackup.js [app-route] (ecmascript)");
Object.defineProperty(exports, "describeBackup", {
    enumerable: true,
    get: function() {
        return describeBackup_1.describeBackup;
    }
});
var describeRestoreJob_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/describeRestoreJob.js [app-route] (ecmascript)");
Object.defineProperty(exports, "describeRestoreJob", {
    enumerable: true,
    get: function() {
        return describeRestoreJob_1.describeRestoreJob;
    }
});
var listBackups_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/listBackups.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listBackups", {
    enumerable: true,
    get: function() {
        return listBackups_1.listBackups;
    }
});
var listRestoreJobs_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/listRestoreJobs.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listRestoreJobs", {
    enumerable: true,
    get: function() {
        return listRestoreJobs_1.listRestoreJobs;
    }
});
var deleteBackup_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/deleteBackup.js [app-route] (ecmascript)");
Object.defineProperty(exports, "deleteBackup", {
    enumerable: true,
    get: function() {
        return deleteBackup_1.deleteBackup;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://api.pinecone.io/assistant".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/Assistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantToJSON = exports.AssistantFromJSONTyped = exports.AssistantFromJSON = exports.instanceOfAssistant = exports.AssistantStatusEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.AssistantStatusEnum = {
    Initializing: 'Initializing',
    Failed: 'Failed',
    Ready: 'Ready',
    Terminating: 'Terminating',
    InitializationFailed: 'InitializationFailed'
};
/**
 * Check if a given object implements the Assistant interface.
 */ function instanceOfAssistant(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "status" in value;
    return isInstance;
}
exports.instanceOfAssistant = instanceOfAssistant;
function AssistantFromJSON(json) {
    return AssistantFromJSONTyped(json, false);
}
exports.AssistantFromJSON = AssistantFromJSON;
function AssistantFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'instructions': !(0, runtime_1.exists)(json, 'instructions') ? undefined : json['instructions'],
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata'],
        'status': json['status'],
        'host': !(0, runtime_1.exists)(json, 'host') ? undefined : json['host'],
        'createdAt': !(0, runtime_1.exists)(json, 'created_at') ? undefined : new Date(json['created_at']),
        'updatedAt': !(0, runtime_1.exists)(json, 'updated_at') ? undefined : new Date(json['updated_at'])
    };
}
exports.AssistantFromJSONTyped = AssistantFromJSONTyped;
function AssistantToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'instructions': value.instructions,
        'metadata': value.metadata,
        'status': value.status,
        'host': value.host,
        'created_at': value.createdAt === undefined ? undefined : value.createdAt.toISOString(),
        'updated_at': value.updatedAt === undefined ? undefined : value.updatedAt.toISOString()
    };
}
exports.AssistantToJSON = AssistantToJSON; //# sourceMappingURL=Assistant.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/CreateAssistantRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateAssistantRequestToJSON = exports.CreateAssistantRequestFromJSONTyped = exports.CreateAssistantRequestFromJSON = exports.instanceOfCreateAssistantRequest = exports.CreateAssistantRequestRegionEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.CreateAssistantRequestRegionEnum = {
    Us: 'us',
    Eu: 'eu'
};
/**
 * Check if a given object implements the CreateAssistantRequest interface.
 */ function instanceOfCreateAssistantRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    return isInstance;
}
exports.instanceOfCreateAssistantRequest = instanceOfCreateAssistantRequest;
function CreateAssistantRequestFromJSON(json) {
    return CreateAssistantRequestFromJSONTyped(json, false);
}
exports.CreateAssistantRequestFromJSON = CreateAssistantRequestFromJSON;
function CreateAssistantRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'instructions': !(0, runtime_1.exists)(json, 'instructions') ? undefined : json['instructions'],
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata'],
        'region': !(0, runtime_1.exists)(json, 'region') ? undefined : json['region']
    };
}
exports.CreateAssistantRequestFromJSONTyped = CreateAssistantRequestFromJSONTyped;
function CreateAssistantRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'instructions': value.instructions,
        'metadata': value.metadata,
        'region': value.region
    };
}
exports.CreateAssistantRequestToJSON = CreateAssistantRequestToJSON; //# sourceMappingURL=CreateAssistantRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ErrorResponseError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ErrorResponseErrorCodeEnum = {
    Ok: 'OK',
    Unknown: 'UNKNOWN',
    InvalidArgument: 'INVALID_ARGUMENT',
    DeadlineExceeded: 'DEADLINE_EXCEEDED',
    QuotaExceeded: 'QUOTA_EXCEEDED',
    NotFound: 'NOT_FOUND',
    AlreadyExists: 'ALREADY_EXISTS',
    PermissionDenied: 'PERMISSION_DENIED',
    Unauthenticated: 'UNAUTHENTICATED',
    ResourceExhausted: 'RESOURCE_EXHAUSTED',
    FailedPrecondition: 'FAILED_PRECONDITION',
    Aborted: 'ABORTED',
    OutOfRange: 'OUT_OF_RANGE',
    Unimplemented: 'UNIMPLEMENTED',
    Internal: 'INTERNAL',
    Unavailable: 'UNAVAILABLE',
    DataLoss: 'DATA_LOSS',
    Forbidden: 'FORBIDDEN'
};
/**
 * Check if a given object implements the ErrorResponseError interface.
 */ function instanceOfErrorResponseError(value) {
    let isInstance = true;
    isInstance = isInstance && "code" in value;
    isInstance = isInstance && "message" in value;
    return isInstance;
}
exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
}
exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'code': json['code'],
        'message': json['message'],
        'details': !(0, runtime_1.exists)(json, 'details') ? undefined : json['details']
    };
}
exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
function ErrorResponseErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
        'details': value.details
    };
}
exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON; //# sourceMappingURL=ErrorResponseError.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ErrorResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = void 0;
const ErrorResponseError_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ErrorResponseError.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ErrorResponse interface.
 */ function instanceOfErrorResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "error" in value;
    return isInstance;
}
exports.instanceOfErrorResponse = instanceOfErrorResponse;
function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
}
exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'status': json['status'],
        'error': (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json['error'])
    };
}
exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
function ErrorResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status': value.status,
        'error': (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value.error)
    };
}
exports.ErrorResponseToJSON = ErrorResponseToJSON; //# sourceMappingURL=ErrorResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ListAssistants200Response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListAssistants200ResponseToJSON = exports.ListAssistants200ResponseFromJSONTyped = exports.ListAssistants200ResponseFromJSON = exports.instanceOfListAssistants200Response = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
const Assistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/Assistant.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListAssistants200Response interface.
 */ function instanceOfListAssistants200Response(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListAssistants200Response = instanceOfListAssistants200Response;
function ListAssistants200ResponseFromJSON(json) {
    return ListAssistants200ResponseFromJSONTyped(json, false);
}
exports.ListAssistants200ResponseFromJSON = ListAssistants200ResponseFromJSON;
function ListAssistants200ResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'assistants': !(0, runtime_1.exists)(json, 'assistants') ? undefined : json['assistants'].map(Assistant_1.AssistantFromJSON)
    };
}
exports.ListAssistants200ResponseFromJSONTyped = ListAssistants200ResponseFromJSONTyped;
function ListAssistants200ResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'assistants': value.assistants === undefined ? undefined : value.assistants.map(Assistant_1.AssistantToJSON)
    };
}
exports.ListAssistants200ResponseToJSON = ListAssistants200ResponseToJSON; //# sourceMappingURL=ListAssistants200Response.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/UpdateAssistant200Response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateAssistant200ResponseToJSON = exports.UpdateAssistant200ResponseFromJSONTyped = exports.UpdateAssistant200ResponseFromJSON = exports.instanceOfUpdateAssistant200Response = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UpdateAssistant200Response interface.
 */ function instanceOfUpdateAssistant200Response(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfUpdateAssistant200Response = instanceOfUpdateAssistant200Response;
function UpdateAssistant200ResponseFromJSON(json) {
    return UpdateAssistant200ResponseFromJSONTyped(json, false);
}
exports.UpdateAssistant200ResponseFromJSON = UpdateAssistant200ResponseFromJSON;
function UpdateAssistant200ResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'assistantName': !(0, runtime_1.exists)(json, 'assistant_name') ? undefined : json['assistant_name'],
        'instructions': !(0, runtime_1.exists)(json, 'instructions') ? undefined : json['instructions'],
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata']
    };
}
exports.UpdateAssistant200ResponseFromJSONTyped = UpdateAssistant200ResponseFromJSONTyped;
function UpdateAssistant200ResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'assistant_name': value.assistantName,
        'instructions': value.instructions,
        'metadata': value.metadata
    };
}
exports.UpdateAssistant200ResponseToJSON = UpdateAssistant200ResponseToJSON; //# sourceMappingURL=UpdateAssistant200Response.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/UpdateAssistantRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateAssistantRequestToJSON = exports.UpdateAssistantRequestFromJSONTyped = exports.UpdateAssistantRequestFromJSON = exports.instanceOfUpdateAssistantRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UpdateAssistantRequest interface.
 */ function instanceOfUpdateAssistantRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfUpdateAssistantRequest = instanceOfUpdateAssistantRequest;
function UpdateAssistantRequestFromJSON(json) {
    return UpdateAssistantRequestFromJSONTyped(json, false);
}
exports.UpdateAssistantRequestFromJSON = UpdateAssistantRequestFromJSON;
function UpdateAssistantRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'instructions': !(0, runtime_1.exists)(json, 'instructions') ? undefined : json['instructions'],
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata']
    };
}
exports.UpdateAssistantRequestFromJSONTyped = UpdateAssistantRequestFromJSONTyped;
function UpdateAssistantRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'instructions': value.instructions,
        'metadata': value.metadata
    };
}
exports.UpdateAssistantRequestToJSON = UpdateAssistantRequestToJSON; //# sourceMappingURL=UpdateAssistantRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/Assistant.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/CreateAssistantRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ErrorResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ErrorResponseError.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/ListAssistants200Response.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/UpdateAssistant200Response.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/UpdateAssistantRequest.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/apis/ManageAssistantsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Control Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge  from millions of documents at scale. This API supports creating and managing assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ManageAssistantsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class ManageAssistantsApi extends runtime.BaseAPI {
    /**
     * Create an assistant. This is where you specify the underlying training model, which cloud provider you would like to deploy with, and more.  For guidance and examples, see [Create an assistant](https://docs.pinecone.io/guides/assistant/create-assistant)
     * Create an assistant
     */ async createAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.createAssistantRequest === null || requestParameters.createAssistantRequest === undefined) {
            throw new runtime.RequiredError('createAssistantRequest', 'Required parameter requestParameters.createAssistantRequest was null or undefined when calling createAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/assistants`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.CreateAssistantRequestToJSON)(requestParameters.createAssistantRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.AssistantFromJSON)(jsonValue));
    }
    /**
     * Create an assistant. This is where you specify the underlying training model, which cloud provider you would like to deploy with, and more.  For guidance and examples, see [Create an assistant](https://docs.pinecone.io/guides/assistant/create-assistant)
     * Create an assistant
     */ async createAssistant(requestParameters, initOverrides) {
        const response = await this.createAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Delete an existing assistant.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#delete-an-assistant)
     * Delete an assistant
     */ async deleteAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling deleteAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/assistants/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Delete an existing assistant.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#delete-an-assistant)
     * Delete an assistant
     */ async deleteAssistant(requestParameters, initOverrides) {
        await this.deleteAssistantRaw(requestParameters, initOverrides);
    }
    /**
     * Get the status of an assistant.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#get-the-status-of-an-assistant)
     * Check assistant status
     */ async getAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling getAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/assistants/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.AssistantFromJSON)(jsonValue));
    }
    /**
     * Get the status of an assistant.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#get-the-status-of-an-assistant)
     * Check assistant status
     */ async getAssistant(requestParameters, initOverrides) {
        const response = await this.getAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List of all assistants in a project.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#list-assistants-for-a-project).
     * List assistants
     */ async listAssistantsRaw(initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/assistants`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ListAssistants200ResponseFromJSON)(jsonValue));
    }
    /**
     * List of all assistants in a project.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#list-assistants-for-a-project).
     * List assistants
     */ async listAssistants(initOverrides) {
        const response = await this.listAssistantsRaw(initOverrides);
        return await response.value();
    }
    /**
     * Update an existing assistant. You can modify the assistant\'s instructions.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#add-instructions-to-an-assistant).
     * Update an assistant
     */ async updateAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling updateAssistant.');
        }
        if (requestParameters.updateAssistantRequest === null || requestParameters.updateAssistantRequest === undefined) {
            throw new runtime.RequiredError('updateAssistantRequest', 'Required parameter requestParameters.updateAssistantRequest was null or undefined when calling updateAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/assistants/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.UpdateAssistantRequestToJSON)(requestParameters.updateAssistantRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.UpdateAssistant200ResponseFromJSON)(jsonValue));
    }
    /**
     * Update an existing assistant. You can modify the assistant\'s instructions.  For guidance and examples, see [Manage assistants](https://docs.pinecone.io/guides/assistant/manage-assistants#add-instructions-to-an-assistant).
     * Update an assistant
     */ async updateAssistant(requestParameters, initOverrides) {
        const response = await this.updateAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.ManageAssistantsApi = ManageAssistantsApi; //# sourceMappingURL=ManageAssistantsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/apis/ManageAssistantsApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantStatusEnum = exports.UpdateAssistantOptionsType = exports.CreateAssistantOptionsType = void 0;
exports.CreateAssistantOptionsType = [
    'name',
    'instructions',
    'metadata',
    'region'
];
exports.UpdateAssistantOptionsType = [
    'instructions',
    'metadata'
];
/**
 * Enum representing the possible statuses of an assistant.
 *
 * - `Initializing`: The assistant is initializing and is not yet ready to handle requests.
 * - `Failed`: The assistant encountered an error and cannot proceed.
 * - `Ready`: The assistant is ready to handle requests.
 * - `Terminating`: The assistant is shutting down and will soon be unavailable.
 */ exports.AssistantStatusEnum = {
    Initializing: 'Initializing',
    Failed: 'Failed',
    Ready: 'Ready',
    Terminating: 'Terminating'
}; //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/createAssistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAssistant = void 0;
const assistant_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/index.js [app-route] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/types.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const createAssistant = (api)=>{
    return async (options)=>{
        validateCreateAssistantOptions(options);
        return await api.createAssistant({
            createAssistantRequest: {
                name: options.name,
                instructions: options?.instructions,
                metadata: options?.metadata,
                region: options?.region
            }
        });
    };
};
exports.createAssistant = createAssistant;
const validateCreateAssistantOptions = (options)=>{
    if (!options) {
        throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`name`) to create an Assistant.');
    }
    (0, validateObjectProperties_1.ValidateObjectProperties)(options, types_1.CreateAssistantOptionsType);
    if (options.region) {
        let region = assistant_control_1.CreateAssistantRequestRegionEnum.Us;
        if (!Object.values(assistant_control_1.CreateAssistantRequestRegionEnum).toString().includes(options.region.toLowerCase())) {
            throw new errors_1.PineconeArgumentError('Invalid region specified. Must be one of "us" or "eu"');
        } else {
            region = options.region.toLowerCase();
        }
        options.region = region;
    }
}; //# sourceMappingURL=createAssistant.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/deleteAssistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteAssistant = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteAssistant = (api)=>{
    return async (assistantName)=>{
        if (!assistantName) {
            throw new errors_1.PineconeArgumentError('You must pass the name of an assistant to update.');
        }
        return await api.deleteAssistant({
            assistantName: assistantName
        });
    };
};
exports.deleteAssistant = deleteAssistant; //# sourceMappingURL=deleteAssistant.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/describeAssistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeAssistant = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const describeAssistant = (api)=>{
    return async (assistantName)=>{
        if (!assistantName) {
            throw new errors_1.PineconeArgumentError('You must pass the name of an assistant to update.');
        }
        return await api.getAssistant({
            assistantName: assistantName
        });
    };
};
exports.describeAssistant = describeAssistant; //# sourceMappingURL=describeAssistant.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/listAssistants.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listAssistants = void 0;
const listAssistants = (api)=>{
    return async ()=>{
        return await api.listAssistants();
    };
};
exports.listAssistants = listAssistants; //# sourceMappingURL=listAssistants.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/updateAssistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.updateAssistant = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/types.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const updateAssistant = (api)=>{
    return async (name, options)=>{
        if (!name) {
            throw new errors_1.PineconeArgumentError('You must pass the name of an assistant to update.');
        }
        validateUpdateAssistantOptions(options);
        const updateAssistantRequest = {};
        if (options?.instructions) {
            updateAssistantRequest['instructions'] = options.instructions;
        }
        if (options?.metadata) {
            updateAssistantRequest['metadata'] = options.metadata;
        }
        return await api.updateAssistant({
            assistantName: name,
            updateAssistantRequest: updateAssistantRequest
        });
    };
};
exports.updateAssistant = updateAssistant;
const validateUpdateAssistantOptions = (options)=>{
    if (!options) {
        throw new errors_1.PineconeArgumentError('You must pass an object with at least one property to update an assistant.');
    }
    (0, validateObjectProperties_1.ValidateObjectProperties)(options, types_1.UpdateAssistantOptionsType);
}; //# sourceMappingURL=updateAssistant.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstControlOperationsBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.asstControlOperationsBuilder = void 0;
const assistant_control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_control/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
const asstControlOperationsBuilder = (config)=>{
    const { apiKey } = config;
    const controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || 'https://api.pinecone.io/assistant';
    const headers = config.additionalHeaders || null;
    const apiConfig = {
        basePath: controllerPath,
        apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: {
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': assistant_control_1.X_PINECONE_API_VERSION,
            ...headers
        },
        fetchApi: (0, utils_1.getFetch)(config),
        middleware: middleware_1.middleware
    };
    return new assistant_control_1.ManageAssistantsApi(new assistant_control_1.Configuration(apiConfig));
};
exports.asstControlOperationsBuilder = asstControlOperationsBuilder; //# sourceMappingURL=asstControlOperationsBuilder.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://prod-1-data.ke.pinecone.io/assistant".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/AlignmentRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlignmentRequestToJSON = exports.AlignmentRequestFromJSONTyped = exports.AlignmentRequestFromJSON = exports.instanceOfAlignmentRequest = void 0;
/**
 * Check if a given object implements the AlignmentRequest interface.
 */ function instanceOfAlignmentRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "question" in value;
    isInstance = isInstance && "answer" in value;
    isInstance = isInstance && "groundTruthAnswer" in value;
    return isInstance;
}
exports.instanceOfAlignmentRequest = instanceOfAlignmentRequest;
function AlignmentRequestFromJSON(json) {
    return AlignmentRequestFromJSONTyped(json, false);
}
exports.AlignmentRequestFromJSON = AlignmentRequestFromJSON;
function AlignmentRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'question': json['question'],
        'answer': json['answer'],
        'groundTruthAnswer': json['ground_truth_answer']
    };
}
exports.AlignmentRequestFromJSONTyped = AlignmentRequestFromJSONTyped;
function AlignmentRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'question': value.question,
        'answer': value.answer,
        'ground_truth_answer': value.groundTruthAnswer
    };
}
exports.AlignmentRequestToJSON = AlignmentRequestToJSON; //# sourceMappingURL=AlignmentRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Metrics.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricsToJSON = exports.MetricsFromJSONTyped = exports.MetricsFromJSON = exports.instanceOfMetrics = void 0;
/**
 * Check if a given object implements the Metrics interface.
 */ function instanceOfMetrics(value) {
    let isInstance = true;
    isInstance = isInstance && "correctness" in value;
    isInstance = isInstance && "completeness" in value;
    isInstance = isInstance && "alignment" in value;
    return isInstance;
}
exports.instanceOfMetrics = instanceOfMetrics;
function MetricsFromJSON(json) {
    return MetricsFromJSONTyped(json, false);
}
exports.MetricsFromJSON = MetricsFromJSON;
function MetricsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'correctness': json['correctness'],
        'completeness': json['completeness'],
        'alignment': json['alignment']
    };
}
exports.MetricsFromJSONTyped = MetricsFromJSONTyped;
function MetricsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'correctness': value.correctness,
        'completeness': value.completeness,
        'alignment': value.alignment
    };
}
exports.MetricsToJSON = MetricsToJSON; //# sourceMappingURL=Metrics.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Entailment.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntailmentToJSON = exports.EntailmentFromJSONTyped = exports.EntailmentFromJSON = exports.Entailment = void 0;
/**
 * The entailment of a fact.
 * @export
 */ exports.Entailment = {
    Entailed: 'entailed',
    Contradicted: 'contradicted',
    Neutral: 'neutral'
};
function EntailmentFromJSON(json) {
    return EntailmentFromJSONTyped(json, false);
}
exports.EntailmentFromJSON = EntailmentFromJSON;
function EntailmentFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.EntailmentFromJSONTyped = EntailmentFromJSONTyped;
function EntailmentToJSON(value) {
    return value;
}
exports.EntailmentToJSON = EntailmentToJSON; //# sourceMappingURL=Entailment.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Fact.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FactToJSON = exports.FactFromJSONTyped = exports.FactFromJSON = exports.instanceOfFact = void 0;
/**
 * Check if a given object implements the Fact interface.
 */ function instanceOfFact(value) {
    let isInstance = true;
    isInstance = isInstance && "content" in value;
    return isInstance;
}
exports.instanceOfFact = instanceOfFact;
function FactFromJSON(json) {
    return FactFromJSONTyped(json, false);
}
exports.FactFromJSON = FactFromJSON;
function FactFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'content': json['content']
    };
}
exports.FactFromJSONTyped = FactFromJSONTyped;
function FactToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'content': value.content
    };
}
exports.FactToJSON = FactToJSON; //# sourceMappingURL=Fact.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/EvaluatedFact.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EvaluatedFactToJSON = exports.EvaluatedFactFromJSONTyped = exports.EvaluatedFactFromJSON = exports.instanceOfEvaluatedFact = void 0;
const Entailment_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Entailment.js [app-route] (ecmascript)");
const Fact_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Fact.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the EvaluatedFact interface.
 */ function instanceOfEvaluatedFact(value) {
    let isInstance = true;
    isInstance = isInstance && "fact" in value;
    isInstance = isInstance && "entailment" in value;
    return isInstance;
}
exports.instanceOfEvaluatedFact = instanceOfEvaluatedFact;
function EvaluatedFactFromJSON(json) {
    return EvaluatedFactFromJSONTyped(json, false);
}
exports.EvaluatedFactFromJSON = EvaluatedFactFromJSON;
function EvaluatedFactFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'fact': (0, Fact_1.FactFromJSON)(json['fact']),
        'entailment': (0, Entailment_1.EntailmentFromJSON)(json['entailment'])
    };
}
exports.EvaluatedFactFromJSONTyped = EvaluatedFactFromJSONTyped;
function EvaluatedFactToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'fact': (0, Fact_1.FactToJSON)(value.fact),
        'entailment': (0, Entailment_1.EntailmentToJSON)(value.entailment)
    };
}
exports.EvaluatedFactToJSON = EvaluatedFactToJSON; //# sourceMappingURL=EvaluatedFact.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Reasoning.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReasoningToJSON = exports.ReasoningFromJSONTyped = exports.ReasoningFromJSON = exports.instanceOfReasoning = void 0;
const EvaluatedFact_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/EvaluatedFact.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the Reasoning interface.
 */ function instanceOfReasoning(value) {
    let isInstance = true;
    isInstance = isInstance && "evaluatedFacts" in value;
    return isInstance;
}
exports.instanceOfReasoning = instanceOfReasoning;
function ReasoningFromJSON(json) {
    return ReasoningFromJSONTyped(json, false);
}
exports.ReasoningFromJSON = ReasoningFromJSON;
function ReasoningFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'evaluatedFacts': json['evaluated_facts'].map(EvaluatedFact_1.EvaluatedFactFromJSON)
    };
}
exports.ReasoningFromJSONTyped = ReasoningFromJSONTyped;
function ReasoningToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'evaluated_facts': value.evaluatedFacts.map(EvaluatedFact_1.EvaluatedFactToJSON)
    };
}
exports.ReasoningToJSON = ReasoningToJSON; //# sourceMappingURL=Reasoning.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/TokenCounts.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenCountsToJSON = exports.TokenCountsFromJSONTyped = exports.TokenCountsFromJSON = exports.instanceOfTokenCounts = void 0;
/**
 * Check if a given object implements the TokenCounts interface.
 */ function instanceOfTokenCounts(value) {
    let isInstance = true;
    isInstance = isInstance && "promptTokens" in value;
    isInstance = isInstance && "completionTokens" in value;
    isInstance = isInstance && "totalTokens" in value;
    return isInstance;
}
exports.instanceOfTokenCounts = instanceOfTokenCounts;
function TokenCountsFromJSON(json) {
    return TokenCountsFromJSONTyped(json, false);
}
exports.TokenCountsFromJSON = TokenCountsFromJSON;
function TokenCountsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'promptTokens': json['prompt_tokens'],
        'completionTokens': json['completion_tokens'],
        'totalTokens': json['total_tokens']
    };
}
exports.TokenCountsFromJSONTyped = TokenCountsFromJSONTyped;
function TokenCountsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'prompt_tokens': value.promptTokens,
        'completion_tokens': value.completionTokens,
        'total_tokens': value.totalTokens
    };
}
exports.TokenCountsToJSON = TokenCountsToJSON; //# sourceMappingURL=TokenCounts.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/AlignmentResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AlignmentResponseToJSON = exports.AlignmentResponseFromJSONTyped = exports.AlignmentResponseFromJSON = exports.instanceOfAlignmentResponse = void 0;
const Metrics_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Metrics.js [app-route] (ecmascript)");
const Reasoning_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Reasoning.js [app-route] (ecmascript)");
const TokenCounts_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/TokenCounts.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the AlignmentResponse interface.
 */ function instanceOfAlignmentResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "metrics" in value;
    isInstance = isInstance && "reasoning" in value;
    isInstance = isInstance && "usage" in value;
    return isInstance;
}
exports.instanceOfAlignmentResponse = instanceOfAlignmentResponse;
function AlignmentResponseFromJSON(json) {
    return AlignmentResponseFromJSONTyped(json, false);
}
exports.AlignmentResponseFromJSON = AlignmentResponseFromJSON;
function AlignmentResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'metrics': (0, Metrics_1.MetricsFromJSON)(json['metrics']),
        'reasoning': (0, Reasoning_1.ReasoningFromJSON)(json['reasoning']),
        'usage': (0, TokenCounts_1.TokenCountsFromJSON)(json['usage'])
    };
}
exports.AlignmentResponseFromJSONTyped = AlignmentResponseFromJSONTyped;
function AlignmentResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'metrics': (0, Metrics_1.MetricsToJSON)(value.metrics),
        'reasoning': (0, Reasoning_1.ReasoningToJSON)(value.reasoning),
        'usage': (0, TokenCounts_1.TokenCountsToJSON)(value.usage)
    };
}
exports.AlignmentResponseToJSON = AlignmentResponseToJSON; //# sourceMappingURL=AlignmentResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/BasicErrorResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BasicErrorResponseToJSON = exports.BasicErrorResponseFromJSONTyped = exports.BasicErrorResponseFromJSON = exports.instanceOfBasicErrorResponse = void 0;
/**
 * Check if a given object implements the BasicErrorResponse interface.
 */ function instanceOfBasicErrorResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "message" in value;
    return isInstance;
}
exports.instanceOfBasicErrorResponse = instanceOfBasicErrorResponse;
function BasicErrorResponseFromJSON(json) {
    return BasicErrorResponseFromJSONTyped(json, false);
}
exports.BasicErrorResponseFromJSON = BasicErrorResponseFromJSON;
function BasicErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'message': json['message']
    };
}
exports.BasicErrorResponseFromJSONTyped = BasicErrorResponseFromJSONTyped;
function BasicErrorResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'message': value.message
    };
}
exports.BasicErrorResponseToJSON = BasicErrorResponseToJSON; //# sourceMappingURL=BasicErrorResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/AlignmentRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/AlignmentResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/BasicErrorResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Entailment.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/EvaluatedFact.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Fact.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Metrics.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/Reasoning.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/TokenCounts.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/apis/MetricsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Evaluation API
 * Provides endpoints for evaluating RAG systems using various metrics.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class MetricsApi extends runtime.BaseAPI {
    /**
     * Evaluate the correctness and completeness of a response from an assistant or a RAG system. The correctness and completeness are evaluated based on the precision and recall of the generated answer with respect to the ground truth answer facts. Alignment is the harmonic mean of correctness and completeness.  For guidance and examples, see [Evaluate answers](https://docs.pinecone.io/guides/assistant/evaluate-answers).
     * Evaluate an answer
     */ async metricsAlignmentRaw(requestParameters, initOverrides) {
        if (requestParameters.alignmentRequest === null || requestParameters.alignmentRequest === undefined) {
            throw new runtime.RequiredError('alignmentRequest', 'Required parameter requestParameters.alignmentRequest was null or undefined when calling metricsAlignment.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/evaluation/metrics/alignment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.AlignmentRequestToJSON)(requestParameters.alignmentRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.AlignmentResponseFromJSON)(jsonValue));
    }
    /**
     * Evaluate the correctness and completeness of a response from an assistant or a RAG system. The correctness and completeness are evaluated based on the precision and recall of the generated answer with respect to the ground truth answer facts. Alignment is the harmonic mean of correctness and completeness.  For guidance and examples, see [Evaluate answers](https://docs.pinecone.io/guides/assistant/evaluate-answers).
     * Evaluate an answer
     */ async metricsAlignment(requestParameters, initOverrides) {
        const response = await this.metricsAlignmentRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.MetricsApi = MetricsApi; //# sourceMappingURL=MetricsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/apis/MetricsApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstMetricsOperationsBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.asstMetricsOperationsBuilder = void 0;
const assistant_evaluation_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_evaluation/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
const asstMetricsOperationsBuilder = (config)=>{
    const { apiKey } = config;
    let hostUrl = 'https://prod-1-data.ke.pinecone.io/assistant';
    // If 'eu' is specified use that, otherwise default to 'us'
    if (config.assistantRegion && config.assistantRegion.toLowerCase() === 'eu') {
        hostUrl = 'https://prod-eu-data.ke.pinecone.io/assistant';
    }
    const headers = config.additionalHeaders || null;
    const apiConfig = {
        basePath: hostUrl,
        apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: {
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': assistant_evaluation_1.X_PINECONE_API_VERSION,
            ...headers
        },
        fetchApi: (0, utils_1.getFetch)(config),
        middleware: middleware_1.middleware
    };
    return new assistant_evaluation_1.MetricsApi(new assistant_evaluation_1.Configuration(apiConfig));
};
exports.asstMetricsOperationsBuilder = asstMetricsOperationsBuilder; //# sourceMappingURL=asstMetricsOperationsBuilder.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.asstMetricsOperationsBuilder = exports.asstControlOperationsBuilder = exports.updateAssistant = exports.listAssistants = exports.describeAssistant = exports.deleteAssistant = exports.createAssistant = void 0;
var createAssistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/createAssistant.js [app-route] (ecmascript)");
Object.defineProperty(exports, "createAssistant", {
    enumerable: true,
    get: function() {
        return createAssistant_1.createAssistant;
    }
});
var deleteAssistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/deleteAssistant.js [app-route] (ecmascript)");
Object.defineProperty(exports, "deleteAssistant", {
    enumerable: true,
    get: function() {
        return deleteAssistant_1.deleteAssistant;
    }
});
var describeAssistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/describeAssistant.js [app-route] (ecmascript)");
Object.defineProperty(exports, "describeAssistant", {
    enumerable: true,
    get: function() {
        return describeAssistant_1.describeAssistant;
    }
});
var listAssistants_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/listAssistants.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listAssistants", {
    enumerable: true,
    get: function() {
        return listAssistants_1.listAssistants;
    }
});
var updateAssistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/updateAssistant.js [app-route] (ecmascript)");
Object.defineProperty(exports, "updateAssistant", {
    enumerable: true,
    get: function() {
        return updateAssistant_1.updateAssistant;
    }
});
var asstControlOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstControlOperationsBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "asstControlOperationsBuilder", {
    enumerable: true,
    get: function() {
        return asstControlOperationsBuilder_1.asstControlOperationsBuilder;
    }
});
var asstMetricsOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstMetricsOperationsBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "asstMetricsOperationsBuilder", {
    enumerable: true,
    get: function() {
        return asstMetricsOperationsBuilder_1.asstMetricsOperationsBuilder;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/assistantHostSingleton.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantHostSingleton = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const asstControlOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstControlOperationsBuilder.js [app-route] (ecmascript)");
const control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/index.js [app-route] (ecmascript)");
exports.AssistantHostSingleton = function() {
    const hostUrls = {}; // map of apiKey-assistantName to hostUrl
    function ensureAssistantPath(url) {
        if (!url.endsWith('/assistant')) {
            // Append "/assistant" if it doesn't already end with it
            url = url.endsWith('/') ? `${url}assistant` : `${url}/assistant`;
        }
        return url;
    }
    const _describeAssistant = async (config, assistantName)=>{
        const assistantControlApi = (0, asstControlOperationsBuilder_1.asstControlOperationsBuilder)(config);
        const describeResponse = await (0, control_1.describeAssistant)(assistantControlApi)(assistantName);
        const host = describeResponse?.host;
        if (!host) {
            // if the host is empty for some reason, default based on region
            let defaultHost = 'https://prod-1-data.ke.pinecone.io';
            // If 'eu' is specified use that, otherwise default to 'us'
            if (config.assistantRegion && config.assistantRegion.toLowerCase() === 'eu') {
                defaultHost = 'https://prod-eu-data.ke.pinecone.io';
            }
            return defaultHost;
        } else {
            return host;
        }
    };
    const _key = (config, assistantName)=>`${config.apiKey}-${assistantName}`;
    // singleton object
    const singleton = {
        getHostUrl: async (config, assistantName)=>{
            const cacheKey = _key(config, assistantName);
            if (cacheKey in hostUrls) {
                return hostUrls[cacheKey];
            } else {
                const hostUrl = await _describeAssistant(config, assistantName);
                hostUrls[cacheKey] = (0, utils_1.normalizeUrl)(ensureAssistantPath(hostUrl));
            }
            return hostUrls[cacheKey];
        },
        _reset: ()=>{
            for (const key of Object.keys(hostUrls)){
                delete hostUrls[key];
            }
        },
        _set: (config, assistantName, hostUrl)=>{
            const normalizedHostUrl = (0, utils_1.normalizeUrl)(ensureAssistantPath(hostUrl));
            // prevent adding an empty hostUrl to the cache
            if (!hostUrl || !normalizedHostUrl) {
                return;
            }
            const cacheKey = _key(config, assistantName);
            hostUrls[cacheKey] = normalizedHostUrl;
        },
        _delete: (config, assistantName)=>{
            const cacheKey = _key(config, assistantName);
            delete hostUrls[cacheKey];
        }
    };
    return singleton;
}(); //# sourceMappingURL=assistantHostSingleton.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexHostSingleton = void 0;
const control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
// We use describeIndex to retrieve the data plane url (host) for a given API key
// and index. We only ever want to call describeIndex a maximum of once per API key
// and index, so we cache them in a singleton for reuse.
exports.IndexHostSingleton = function() {
    const hostUrls = {}; // map of apiKey-indexName to hostUrl
    const _describeIndex = async (config, indexName)=>{
        const indexOperationsApi = (0, control_1.indexOperationsBuilder)(config);
        const describeResponse = await (0, control_1.describeIndex)(indexOperationsApi)(indexName);
        const host = describeResponse.host;
        if (!host) {
            // Generally, middleware will handle most errors from the call itself such as index not found, etc
            // However, we need to explicitly handle the optionality of status.host
            throw new errors_1.PineconeUnableToResolveHostError('The HTTP call succeeded but the host URL could not be resolved. Please make sure the index exists and is in a ready state.');
        } else {
            return host;
        }
    };
    const _key = (config, indexName)=>`${config.apiKey}-${indexName}`;
    const singleton = {
        getHostUrl: async (config, indexName)=>{
            const cacheKey = _key(config, indexName);
            if (cacheKey in hostUrls) {
                return hostUrls[cacheKey];
            } else {
                const hostUrl = await _describeIndex(config, indexName);
                singleton._set(config, indexName, hostUrl);
                if (!hostUrls[cacheKey]) {
                    throw new errors_1.PineconeUnableToResolveHostError(`Could not get host for index: ${indexName}. Call describeIndex('${indexName}') to check the current status.`);
                }
                return hostUrls[cacheKey];
            }
        },
        _reset: ()=>{
            for (const key of Object.keys(hostUrls)){
                delete hostUrls[key];
            }
        },
        _set: (config, indexName, hostUrl)=>{
            const normalizedHostUrl = (0, utils_1.normalizeUrl)(hostUrl);
            // prevent adding an empty hostUrl to the cache
            if (!normalizedHostUrl) {
                return;
            }
            const cacheKey = _key(config, indexName);
            hostUrls[cacheKey] = normalizedHostUrl;
        },
        _delete: (config, indexName)=>{
            const cacheKey = _key(config, indexName);
            delete hostUrls[cacheKey];
        }
    };
    return singleton;
}(); //# sourceMappingURL=indexHostSingleton.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PineconeRecordsProperties = exports.PineconeConfigurationProperties = void 0;
exports.PineconeConfigurationProperties = [
    'apiKey',
    'controllerHostUrl',
    'fetchApi',
    'additionalHeaders',
    'sourceTag',
    'maxRetries'
];
exports.PineconeRecordsProperties = [
    'id',
    'values',
    'sparseValues',
    'metadata'
]; //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/upsert.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpsertCommand = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/types.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
class UpsertCommand {
    constructor(apiProvider, namespace){
        this.validator = (records)=>{
            for (const record of records){
                (0, validateObjectProperties_1.ValidateObjectProperties)(record, types_1.PineconeRecordsProperties);
            }
            if (records.length === 0) {
                throw new errors_1.PineconeArgumentError('Must pass in at least 1 record to upsert.');
            }
            records.forEach((record)=>{
                if (!record.id) {
                    throw new errors_1.PineconeArgumentError('Every record must include an `id` property in order to upsert.');
                }
                if (!record.values && !record.sparseValues) {
                    throw new errors_1.PineconeArgumentError('Every record must include either `values` or `sparseValues` in order to upsert.');
                }
            });
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(records, maxRetries) {
        this.validator(records);
        const api = await this.apiProvider.provide();
        const retryWrapper = new utils_1.RetryOnServerFailure(api.upsertVectors.bind(api), maxRetries);
        await retryWrapper.execute({
            upsertRequest: {
                vectors: records,
                namespace: this.namespace
            }
        });
    }
}
exports.UpsertCommand = UpsertCommand; //# sourceMappingURL=upsert.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/fetch.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchCommand = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
class FetchCommand {
    constructor(apiProvider, namespace){
        this.validator = (options)=>{
            if (options.length === 0) {
                throw new errors_1.PineconeArgumentError('Must pass in at least 1 recordID.');
            }
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(ids) {
        this.validator(ids);
        const api = await this.apiProvider.provide();
        const response = await api.fetchVectors({
            ids: ids,
            namespace: this.namespace
        });
        // My testing shows that in reality vectors and namespace are
        // never undefined even when there are no records returned. So these
        // default values are needed only to satisfy the typescript compiler.
        return {
            records: response.vectors ? response.vectors : {},
            namespace: response.namespace ? response.namespace : '',
            ...response.usage && {
                usage: response.usage
            }
        };
    }
}
exports.FetchCommand = FetchCommand; //# sourceMappingURL=fetch.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/update.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateCommand = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const UpdateOptionsProperties = [
    'id',
    'values',
    'sparseValues',
    'metadata'
];
class UpdateCommand {
    constructor(apiProvider, namespace){
        this.validator = (options)=>{
            if (options) {
                (0, validateObjectProperties_1.ValidateObjectProperties)(options, UpdateOptionsProperties);
            }
            if (options && !options.id) {
                throw new errors_1.PineconeArgumentError('You must enter a non-empty string for the `id` field in order to update a record.');
            }
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(options, maxRetries) {
        this.validator(options);
        const requestOptions = {
            id: options['id'],
            values: options['values'],
            sparseValues: options['sparseValues'],
            setMetadata: options['metadata']
        };
        const api = await this.apiProvider.provide();
        const retryWrapper = new utils_1.RetryOnServerFailure(api.updateVector.bind(api), maxRetries);
        await retryWrapper.execute({
            updateRequest: {
                ...requestOptions,
                namespace: this.namespace
            }
        });
        return;
    }
}
exports.UpdateCommand = UpdateCommand; //# sourceMappingURL=update.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/query.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryCommand = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const QueryOptionsProperties = [
    'id',
    'vector',
    'sparseVector',
    'includeValues',
    'includeMetadata',
    'filter',
    'topK'
];
class QueryCommand {
    constructor(apiProvider, namespace){
        this.validator = (options)=>{
            if (options) {
                (0, validateObjectProperties_1.ValidateObjectProperties)(options, QueryOptionsProperties);
            }
            if (!options) {
                throw new errors_1.PineconeArgumentError('You must enter a query configuration object to query the index.');
            }
            if (options && !options.topK) {
                throw new errors_1.PineconeArgumentError('You must enter an integer for the `topK` search results to be returned.');
            }
            if (options && options.topK && options.topK < 1) {
                throw new errors_1.PineconeArgumentError('`topK` property must be greater than 0.');
            }
            if (options && options.filter) {
                const keys = Object.keys(options.filter);
                if (keys.length === 0) {
                    throw new errors_1.PineconeArgumentError('You must enter a `filter` object with at least one key-value pair.');
                }
            }
            if ('id' in options) {
                if (!options.id) {
                    throw new errors_1.PineconeArgumentError('You must enter non-empty string for `id` to query by record ID.');
                }
            }
            if ('vector' in options) {
                if (options.vector.length === 0) {
                    throw new errors_1.PineconeArgumentError('You must enter an array of `RecordValues` in order to query by vector values.');
                }
            }
            if ('sparseVector' in options) {
                if (options.sparseVector?.indices.length === 0 || options.sparseVector?.values.length === 0) {
                    throw new errors_1.PineconeArgumentError('You must enter a `RecordSparseValues` object with `indices` and `values` properties in order to query by' + ' sparse vector values.');
                }
            }
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(query) {
        this.validator(query);
        const api = await this.apiProvider.provide();
        const results = await api.queryVectors({
            queryRequest: {
                ...query,
                namespace: this.namespace
            }
        });
        const matches = results.matches ? results.matches : [];
        return {
            matches: matches,
            namespace: this.namespace,
            ...results.usage && {
                usage: results.usage
            }
        };
    }
}
exports.QueryCommand = QueryCommand; //# sourceMappingURL=query.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteOne.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteOne = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteOne = (apiProvider, namespace)=>{
    const validator = (options)=>{
        if (!options) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `options` in order to delete a record.');
        }
    };
    return async (options)=>{
        validator(options);
        const api = await apiProvider.provide();
        await api.deleteVectors({
            deleteRequest: {
                ids: [
                    options
                ],
                namespace
            }
        });
        return;
    };
};
exports.deleteOne = deleteOne; //# sourceMappingURL=deleteOne.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteMany.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteMany = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const deleteMany = (apiProvider, namespace)=>{
    const FilterValidator = (options)=>{
        for(const key in options){
            if (!options[key]) {
                throw new errors_1.PineconeArgumentError(`\`filter\` property cannot be empty for key ${key}`);
            }
        }
    };
    const validator = (options)=>{
        if (!Array.isArray(options)) {
            return FilterValidator(options);
        } else {
            if (options.length === 0) {
                throw new errors_1.PineconeArgumentError('Must pass in at least 1 record ID.');
            }
        }
    };
    return async (options)=>{
        validator(options);
        const requestOptions = {};
        if (Array.isArray(options)) {
            requestOptions.ids = options;
        } else {
            requestOptions.filter = options;
        }
        const api = await apiProvider.provide();
        await api.deleteVectors({
            deleteRequest: {
                ...requestOptions,
                namespace
            }
        });
    };
};
exports.deleteMany = deleteMany; //# sourceMappingURL=deleteMany.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteAll.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteAll = void 0;
const deleteAll = (apiProvider, namespace)=>{
    return async ()=>{
        const api = await apiProvider.provide();
        await api.deleteVectors({
            deleteRequest: {
                deleteAll: true,
                namespace
            }
        });
        return;
    };
};
exports.deleteAll = deleteAll; //# sourceMappingURL=deleteAll.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/describeIndexStats.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeIndexStats = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const describeIndexStats = (apiProvider)=>{
    const validator = (options)=>{
        if (options) {
            (0, validateObjectProperties_1.ValidateObjectProperties)(options, [
                'filter'
            ]);
        }
        const map = options['filter'];
        for(const key in map){
            if (!map[key]) {
                throw new errors_1.PineconeArgumentError(`\`filter\` property cannot be empty for ${key}`);
            }
        }
    };
    return async (options)=>{
        if (options) {
            validator(options);
        }
        const api = await apiProvider.provide();
        const results = await api.describeIndexStats({
            describeIndexStatsRequest: {
                ...options
            }
        });
        const mappedResult = {
            namespaces: {},
            dimension: results.dimension,
            indexFullness: results.indexFullness,
            totalRecordCount: results.totalVectorCount
        };
        if (results.namespaces) {
            for(const key in results.namespaces){
                mappedResult.namespaces[key] = {
                    recordCount: results.namespaces[key].vectorCount
                };
            }
        }
        return mappedResult;
    };
};
exports.describeIndexStats = describeIndexStats; //# sourceMappingURL=describeIndexStats.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://unknown".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DeleteRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the DeleteRequest interface.
 */ function instanceOfDeleteRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
function DeleteRequestFromJSON(json) {
    return DeleteRequestFromJSONTyped(json, false);
}
exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'ids': !(0, runtime_1.exists)(json, 'ids') ? undefined : json['ids'],
        'deleteAll': !(0, runtime_1.exists)(json, 'deleteAll') ? undefined : json['deleteAll'],
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter']
    };
}
exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
function DeleteRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'ids': value.ids,
        'deleteAll': value.deleteAll,
        'namespace': value.namespace,
        'filter': value.filter
    };
}
exports.DeleteRequestToJSON = DeleteRequestToJSON; //# sourceMappingURL=DeleteRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DescribeIndexStatsRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the DescribeIndexStatsRequest interface.
 */ function instanceOfDescribeIndexStatsRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
function DescribeIndexStatsRequestFromJSON(json) {
    return DescribeIndexStatsRequestFromJSONTyped(json, false);
}
exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter']
    };
}
exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
function DescribeIndexStatsRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'filter': value.filter
    };
}
exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON; //# sourceMappingURL=DescribeIndexStatsRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsageToJSON = exports.UsageFromJSONTyped = exports.UsageFromJSON = exports.instanceOfUsage = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the Usage interface.
 */ function instanceOfUsage(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfUsage = instanceOfUsage;
function UsageFromJSON(json) {
    return UsageFromJSONTyped(json, false);
}
exports.UsageFromJSON = UsageFromJSON;
function UsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'readUnits': !(0, runtime_1.exists)(json, 'readUnits') ? undefined : json['readUnits']
    };
}
exports.UsageFromJSONTyped = UsageFromJSONTyped;
function UsageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'readUnits': value.readUnits
    };
}
exports.UsageToJSON = UsageToJSON; //# sourceMappingURL=Usage.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = void 0;
/**
 * Check if a given object implements the SparseValues interface.
 */ function instanceOfSparseValues(value) {
    let isInstance = true;
    isInstance = isInstance && "indices" in value;
    isInstance = isInstance && "values" in value;
    return isInstance;
}
exports.instanceOfSparseValues = instanceOfSparseValues;
function SparseValuesFromJSON(json) {
    return SparseValuesFromJSONTyped(json, false);
}
exports.SparseValuesFromJSON = SparseValuesFromJSON;
function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'indices': json['indices'],
        'values': json['values']
    };
}
exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
function SparseValuesToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'indices': value.indices,
        'values': value.values
    };
}
exports.SparseValuesToJSON = SparseValuesToJSON; //# sourceMappingURL=SparseValues.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Vector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SparseValues_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the Vector interface.
 */ function instanceOfVector(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
exports.instanceOfVector = instanceOfVector;
function VectorFromJSON(json) {
    return VectorFromJSONTyped(json, false);
}
exports.VectorFromJSON = VectorFromJSON;
function VectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': json['id'],
        'values': !(0, runtime_1.exists)(json, 'values') ? undefined : json['values'],
        'sparseValues': !(0, runtime_1.exists)(json, 'sparseValues') ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json['sparseValues']),
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata']
    };
}
exports.VectorFromJSONTyped = VectorFromJSONTyped;
function VectorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'values': value.values,
        'sparseValues': (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        'metadata': value.metadata
    };
}
exports.VectorToJSON = VectorToJSON; //# sourceMappingURL=Vector.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/FetchResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const Usage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js [app-route] (ecmascript)");
const Vector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Vector.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the FetchResponse interface.
 */ function instanceOfFetchResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfFetchResponse = instanceOfFetchResponse;
function FetchResponseFromJSON(json) {
    return FetchResponseFromJSONTyped(json, false);
}
exports.FetchResponseFromJSON = FetchResponseFromJSON;
function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'vectors': !(0, runtime_1.exists)(json, 'vectors') ? undefined : (0, runtime_1.mapValues)(json['vectors'], Vector_1.VectorFromJSON),
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'usage': !(0, runtime_1.exists)(json, 'usage') ? undefined : (0, Usage_1.UsageFromJSON)(json['usage'])
    };
}
exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
function FetchResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'vectors': value.vectors === undefined ? undefined : (0, runtime_1.mapValues)(value.vectors, Vector_1.VectorToJSON),
        'namespace': value.namespace,
        'usage': (0, Usage_1.UsageToJSON)(value.usage)
    };
}
exports.FetchResponseToJSON = FetchResponseToJSON; //# sourceMappingURL=FetchResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Hit.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HitToJSON = exports.HitFromJSONTyped = exports.HitFromJSON = exports.instanceOfHit = void 0;
/**
 * Check if a given object implements the Hit interface.
 */ function instanceOfHit(value) {
    let isInstance = true;
    isInstance = isInstance && "_id" in value;
    isInstance = isInstance && "_score" in value;
    isInstance = isInstance && "fields" in value;
    return isInstance;
}
exports.instanceOfHit = instanceOfHit;
function HitFromJSON(json) {
    return HitFromJSONTyped(json, false);
}
exports.HitFromJSON = HitFromJSON;
function HitFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        '_id': json['_id'],
        '_score': json['_score'],
        'fields': json['fields']
    };
}
exports.HitFromJSONTyped = HitFromJSONTyped;
function HitToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        '_id': value._id,
        '_score': value._score,
        'fields': value.fields
    };
}
exports.HitToJSON = HitToJSON; //# sourceMappingURL=Hit.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportErrorMode.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ImportErrorModeToJSON = exports.ImportErrorModeFromJSONTyped = exports.ImportErrorModeFromJSON = exports.instanceOfImportErrorMode = exports.ImportErrorModeOnErrorEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ImportErrorModeOnErrorEnum = {
    Abort: 'abort',
    Continue: 'continue'
};
/**
 * Check if a given object implements the ImportErrorMode interface.
 */ function instanceOfImportErrorMode(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfImportErrorMode = instanceOfImportErrorMode;
function ImportErrorModeFromJSON(json) {
    return ImportErrorModeFromJSONTyped(json, false);
}
exports.ImportErrorModeFromJSON = ImportErrorModeFromJSON;
function ImportErrorModeFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'onError': !(0, runtime_1.exists)(json, 'onError') ? undefined : json['onError']
    };
}
exports.ImportErrorModeFromJSONTyped = ImportErrorModeFromJSONTyped;
function ImportErrorModeToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'onError': value.onError
    };
}
exports.ImportErrorModeToJSON = ImportErrorModeToJSON; //# sourceMappingURL=ImportErrorMode.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ImportModelToJSON = exports.ImportModelFromJSONTyped = exports.ImportModelFromJSON = exports.instanceOfImportModel = exports.ImportModelStatusEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ImportModelStatusEnum = {
    Pending: 'Pending',
    InProgress: 'InProgress',
    Failed: 'Failed',
    Completed: 'Completed',
    Cancelled: 'Cancelled'
};
/**
 * Check if a given object implements the ImportModel interface.
 */ function instanceOfImportModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfImportModel = instanceOfImportModel;
function ImportModelFromJSON(json) {
    return ImportModelFromJSONTyped(json, false);
}
exports.ImportModelFromJSON = ImportModelFromJSON;
function ImportModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id'],
        'uri': !(0, runtime_1.exists)(json, 'uri') ? undefined : json['uri'],
        'status': !(0, runtime_1.exists)(json, 'status') ? undefined : json['status'],
        'createdAt': !(0, runtime_1.exists)(json, 'createdAt') ? undefined : new Date(json['createdAt']),
        'finishedAt': !(0, runtime_1.exists)(json, 'finishedAt') ? undefined : new Date(json['finishedAt']),
        'percentComplete': !(0, runtime_1.exists)(json, 'percentComplete') ? undefined : json['percentComplete'],
        'recordsImported': !(0, runtime_1.exists)(json, 'recordsImported') ? undefined : json['recordsImported'],
        'error': !(0, runtime_1.exists)(json, 'error') ? undefined : json['error']
    };
}
exports.ImportModelFromJSONTyped = ImportModelFromJSONTyped;
function ImportModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'uri': value.uri,
        'status': value.status,
        'createdAt': value.createdAt === undefined ? undefined : value.createdAt.toISOString(),
        'finishedAt': value.finishedAt === undefined ? undefined : value.finishedAt.toISOString(),
        'percentComplete': value.percentComplete,
        'recordsImported': value.recordsImported,
        'error': value.error
    };
}
exports.ImportModelToJSON = ImportModelToJSON; //# sourceMappingURL=ImportModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceSummary.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the NamespaceSummary interface.
 */ function instanceOfNamespaceSummary(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
function NamespaceSummaryFromJSON(json) {
    return NamespaceSummaryFromJSONTyped(json, false);
}
exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'vectorCount': !(0, runtime_1.exists)(json, 'vectorCount') ? undefined : json['vectorCount']
    };
}
exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
function NamespaceSummaryToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'vectorCount': value.vectorCount
    };
}
exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON; //# sourceMappingURL=NamespaceSummary.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/IndexDescription.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexDescriptionToJSON = exports.IndexDescriptionFromJSONTyped = exports.IndexDescriptionFromJSON = exports.instanceOfIndexDescription = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const NamespaceSummary_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceSummary.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the IndexDescription interface.
 */ function instanceOfIndexDescription(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfIndexDescription = instanceOfIndexDescription;
function IndexDescriptionFromJSON(json) {
    return IndexDescriptionFromJSONTyped(json, false);
}
exports.IndexDescriptionFromJSON = IndexDescriptionFromJSON;
function IndexDescriptionFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'namespaces': !(0, runtime_1.exists)(json, 'namespaces') ? undefined : (0, runtime_1.mapValues)(json['namespaces'], NamespaceSummary_1.NamespaceSummaryFromJSON),
        'dimension': !(0, runtime_1.exists)(json, 'dimension') ? undefined : json['dimension'],
        'indexFullness': !(0, runtime_1.exists)(json, 'indexFullness') ? undefined : json['indexFullness'],
        'totalVectorCount': !(0, runtime_1.exists)(json, 'totalVectorCount') ? undefined : json['totalVectorCount'],
        'metric': !(0, runtime_1.exists)(json, 'metric') ? undefined : json['metric'],
        'vectorType': !(0, runtime_1.exists)(json, 'vectorType') ? undefined : json['vectorType']
    };
}
exports.IndexDescriptionFromJSONTyped = IndexDescriptionFromJSONTyped;
function IndexDescriptionToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespaces': value.namespaces === undefined ? undefined : (0, runtime_1.mapValues)(value.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
        'dimension': value.dimension,
        'indexFullness': value.indexFullness,
        'totalVectorCount': value.totalVectorCount,
        'metric': value.metric,
        'vectorType': value.vectorType
    };
}
exports.IndexDescriptionToJSON = IndexDescriptionToJSON; //# sourceMappingURL=IndexDescription.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PaginationToJSON = exports.PaginationFromJSONTyped = exports.PaginationFromJSON = exports.instanceOfPagination = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the Pagination interface.
 */ function instanceOfPagination(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfPagination = instanceOfPagination;
function PaginationFromJSON(json) {
    return PaginationFromJSONTyped(json, false);
}
exports.PaginationFromJSON = PaginationFromJSON;
function PaginationFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'next': !(0, runtime_1.exists)(json, 'next') ? undefined : json['next']
    };
}
exports.PaginationFromJSONTyped = PaginationFromJSONTyped;
function PaginationToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'next': value.next
    };
}
exports.PaginationToJSON = PaginationToJSON; //# sourceMappingURL=Pagination.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListImportsResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListImportsResponseToJSON = exports.ListImportsResponseFromJSONTyped = exports.ListImportsResponseFromJSON = exports.instanceOfListImportsResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ImportModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportModel.js [app-route] (ecmascript)");
const Pagination_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListImportsResponse interface.
 */ function instanceOfListImportsResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListImportsResponse = instanceOfListImportsResponse;
function ListImportsResponseFromJSON(json) {
    return ListImportsResponseFromJSONTyped(json, false);
}
exports.ListImportsResponseFromJSON = ListImportsResponseFromJSON;
function ListImportsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'data': !(0, runtime_1.exists)(json, 'data') ? undefined : json['data'].map(ImportModel_1.ImportModelFromJSON),
        'pagination': !(0, runtime_1.exists)(json, 'pagination') ? undefined : (0, Pagination_1.PaginationFromJSON)(json['pagination'])
    };
}
exports.ListImportsResponseFromJSONTyped = ListImportsResponseFromJSONTyped;
function ListImportsResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'data': value.data === undefined ? undefined : value.data.map(ImportModel_1.ImportModelToJSON),
        'pagination': (0, Pagination_1.PaginationToJSON)(value.pagination)
    };
}
exports.ListImportsResponseToJSON = ListImportsResponseToJSON; //# sourceMappingURL=ListImportsResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListItem.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListItemToJSON = exports.ListItemFromJSONTyped = exports.ListItemFromJSON = exports.instanceOfListItem = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListItem interface.
 */ function instanceOfListItem(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListItem = instanceOfListItem;
function ListItemFromJSON(json) {
    return ListItemFromJSONTyped(json, false);
}
exports.ListItemFromJSON = ListItemFromJSON;
function ListItemFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id']
    };
}
exports.ListItemFromJSONTyped = ListItemFromJSONTyped;
function ListItemToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id
    };
}
exports.ListItemToJSON = ListItemToJSON; //# sourceMappingURL=ListItem.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceDescription.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NamespaceDescriptionToJSON = exports.NamespaceDescriptionFromJSONTyped = exports.NamespaceDescriptionFromJSON = exports.instanceOfNamespaceDescription = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the NamespaceDescription interface.
 */ function instanceOfNamespaceDescription(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfNamespaceDescription = instanceOfNamespaceDescription;
function NamespaceDescriptionFromJSON(json) {
    return NamespaceDescriptionFromJSONTyped(json, false);
}
exports.NamespaceDescriptionFromJSON = NamespaceDescriptionFromJSON;
function NamespaceDescriptionFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': !(0, runtime_1.exists)(json, 'name') ? undefined : json['name'],
        'recordCount': !(0, runtime_1.exists)(json, 'record_count') ? undefined : json['record_count']
    };
}
exports.NamespaceDescriptionFromJSONTyped = NamespaceDescriptionFromJSONTyped;
function NamespaceDescriptionToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'record_count': value.recordCount
    };
}
exports.NamespaceDescriptionToJSON = NamespaceDescriptionToJSON; //# sourceMappingURL=NamespaceDescription.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListNamespacesResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListNamespacesResponseToJSON = exports.ListNamespacesResponseFromJSONTyped = exports.ListNamespacesResponseFromJSON = exports.instanceOfListNamespacesResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const NamespaceDescription_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceDescription.js [app-route] (ecmascript)");
const Pagination_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListNamespacesResponse interface.
 */ function instanceOfListNamespacesResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListNamespacesResponse = instanceOfListNamespacesResponse;
function ListNamespacesResponseFromJSON(json) {
    return ListNamespacesResponseFromJSONTyped(json, false);
}
exports.ListNamespacesResponseFromJSON = ListNamespacesResponseFromJSON;
function ListNamespacesResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'namespaces': !(0, runtime_1.exists)(json, 'namespaces') ? undefined : json['namespaces'].map(NamespaceDescription_1.NamespaceDescriptionFromJSON),
        'pagination': !(0, runtime_1.exists)(json, 'pagination') ? undefined : (0, Pagination_1.PaginationFromJSON)(json['pagination'])
    };
}
exports.ListNamespacesResponseFromJSONTyped = ListNamespacesResponseFromJSONTyped;
function ListNamespacesResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespaces': value.namespaces === undefined ? undefined : value.namespaces.map(NamespaceDescription_1.NamespaceDescriptionToJSON),
        'pagination': (0, Pagination_1.PaginationToJSON)(value.pagination)
    };
}
exports.ListNamespacesResponseToJSON = ListNamespacesResponseToJSON; //# sourceMappingURL=ListNamespacesResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListResponseToJSON = exports.ListResponseFromJSONTyped = exports.ListResponseFromJSON = exports.instanceOfListResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ListItem_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListItem.js [app-route] (ecmascript)");
const Pagination_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js [app-route] (ecmascript)");
const Usage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListResponse interface.
 */ function instanceOfListResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListResponse = instanceOfListResponse;
function ListResponseFromJSON(json) {
    return ListResponseFromJSONTyped(json, false);
}
exports.ListResponseFromJSON = ListResponseFromJSON;
function ListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'vectors': !(0, runtime_1.exists)(json, 'vectors') ? undefined : json['vectors'].map(ListItem_1.ListItemFromJSON),
        'pagination': !(0, runtime_1.exists)(json, 'pagination') ? undefined : (0, Pagination_1.PaginationFromJSON)(json['pagination']),
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'usage': !(0, runtime_1.exists)(json, 'usage') ? undefined : (0, Usage_1.UsageFromJSON)(json['usage'])
    };
}
exports.ListResponseFromJSONTyped = ListResponseFromJSONTyped;
function ListResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'vectors': value.vectors === undefined ? undefined : value.vectors.map(ListItem_1.ListItemToJSON),
        'pagination': (0, Pagination_1.PaginationToJSON)(value.pagination),
        'namespace': value.namespace,
        'usage': (0, Usage_1.UsageToJSON)(value.usage)
    };
}
exports.ListResponseToJSON = ListResponseToJSON; //# sourceMappingURL=ListResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufAny.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ProtobufAny interface.
 */ function instanceOfProtobufAny(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfProtobufAny = instanceOfProtobufAny;
function ProtobufAnyFromJSON(json) {
    return ProtobufAnyFromJSONTyped(json, false);
}
exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'typeUrl': !(0, runtime_1.exists)(json, 'typeUrl') ? undefined : json['typeUrl'],
        'value': !(0, runtime_1.exists)(json, 'value') ? undefined : json['value']
    };
}
exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
function ProtobufAnyToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'typeUrl': value.typeUrl,
        'value': value.value
    };
}
exports.ProtobufAnyToJSON = ProtobufAnyToJSON; //# sourceMappingURL=ProtobufAny.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufNullValue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = void 0;
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.
 * The JSON representation for `NullValue` is JSON `null`.
 * @export
 */ exports.ProtobufNullValue = {
    NullValue: 'NULL_VALUE'
};
function ProtobufNullValueFromJSON(json) {
    return ProtobufNullValueFromJSONTyped(json, false);
}
exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
function ProtobufNullValueToJSON(value) {
    return value;
}
exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON; //# sourceMappingURL=ProtobufNullValue.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryVector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SparseValues_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the QueryVector interface.
 */ function instanceOfQueryVector(value) {
    let isInstance = true;
    isInstance = isInstance && "values" in value;
    return isInstance;
}
exports.instanceOfQueryVector = instanceOfQueryVector;
function QueryVectorFromJSON(json) {
    return QueryVectorFromJSONTyped(json, false);
}
exports.QueryVectorFromJSON = QueryVectorFromJSON;
function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'values': json['values'],
        'sparseValues': !(0, runtime_1.exists)(json, 'sparseValues') ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json['sparseValues']),
        'topK': !(0, runtime_1.exists)(json, 'topK') ? undefined : json['topK'],
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter']
    };
}
exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
function QueryVectorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'values': value.values,
        'sparseValues': (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        'topK': value.topK,
        'namespace': value.namespace,
        'filter': value.filter
    };
}
exports.QueryVectorToJSON = QueryVectorToJSON; //# sourceMappingURL=QueryVector.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const QueryVector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryVector.js [app-route] (ecmascript)");
const SparseValues_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the QueryRequest interface.
 */ function instanceOfQueryRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "topK" in value;
    return isInstance;
}
exports.instanceOfQueryRequest = instanceOfQueryRequest;
function QueryRequestFromJSON(json) {
    return QueryRequestFromJSONTyped(json, false);
}
exports.QueryRequestFromJSON = QueryRequestFromJSON;
function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'topK': json['topK'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter'],
        'includeValues': !(0, runtime_1.exists)(json, 'includeValues') ? undefined : json['includeValues'],
        'includeMetadata': !(0, runtime_1.exists)(json, 'includeMetadata') ? undefined : json['includeMetadata'],
        'queries': !(0, runtime_1.exists)(json, 'queries') ? undefined : json['queries'].map(QueryVector_1.QueryVectorFromJSON),
        'vector': !(0, runtime_1.exists)(json, 'vector') ? undefined : json['vector'],
        'sparseVector': !(0, runtime_1.exists)(json, 'sparseVector') ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json['sparseVector']),
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id']
    };
}
exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
function QueryRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'namespace': value.namespace,
        'topK': value.topK,
        'filter': value.filter,
        'includeValues': value.includeValues,
        'includeMetadata': value.includeMetadata,
        'queries': value.queries === undefined ? undefined : value.queries.map(QueryVector_1.QueryVectorToJSON),
        'vector': value.vector,
        'sparseVector': (0, SparseValues_1.SparseValuesToJSON)(value.sparseVector),
        'id': value.id
    };
}
exports.QueryRequestToJSON = QueryRequestToJSON; //# sourceMappingURL=QueryRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ScoredVector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SparseValues_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ScoredVector interface.
 */ function instanceOfScoredVector(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
exports.instanceOfScoredVector = instanceOfScoredVector;
function ScoredVectorFromJSON(json) {
    return ScoredVectorFromJSONTyped(json, false);
}
exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': json['id'],
        'score': !(0, runtime_1.exists)(json, 'score') ? undefined : json['score'],
        'values': !(0, runtime_1.exists)(json, 'values') ? undefined : json['values'],
        'sparseValues': !(0, runtime_1.exists)(json, 'sparseValues') ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json['sparseValues']),
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata']
    };
}
exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
function ScoredVectorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'score': value.score,
        'values': value.values,
        'sparseValues': (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        'metadata': value.metadata
    };
}
exports.ScoredVectorToJSON = ScoredVectorToJSON; //# sourceMappingURL=ScoredVector.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SingleQueryResults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ScoredVector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ScoredVector.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SingleQueryResults interface.
 */ function instanceOfSingleQueryResults(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
function SingleQueryResultsFromJSON(json) {
    return SingleQueryResultsFromJSONTyped(json, false);
}
exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'matches': !(0, runtime_1.exists)(json, 'matches') ? undefined : json['matches'].map(ScoredVector_1.ScoredVectorFromJSON),
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace']
    };
}
exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
function SingleQueryResultsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'matches': value.matches === undefined ? undefined : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        'namespace': value.namespace
    };
}
exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON; //# sourceMappingURL=SingleQueryResults.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ScoredVector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ScoredVector.js [app-route] (ecmascript)");
const SingleQueryResults_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SingleQueryResults.js [app-route] (ecmascript)");
const Usage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the QueryResponse interface.
 */ function instanceOfQueryResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfQueryResponse = instanceOfQueryResponse;
function QueryResponseFromJSON(json) {
    return QueryResponseFromJSONTyped(json, false);
}
exports.QueryResponseFromJSON = QueryResponseFromJSON;
function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'results': !(0, runtime_1.exists)(json, 'results') ? undefined : json['results'].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
        'matches': !(0, runtime_1.exists)(json, 'matches') ? undefined : json['matches'].map(ScoredVector_1.ScoredVectorFromJSON),
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace'],
        'usage': !(0, runtime_1.exists)(json, 'usage') ? undefined : (0, Usage_1.UsageFromJSON)(json['usage'])
    };
}
exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
function QueryResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'results': value.results === undefined ? undefined : value.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
        'matches': value.matches === undefined ? undefined : value.matches.map(ScoredVector_1.ScoredVectorToJSON),
        'namespace': value.namespace,
        'usage': (0, Usage_1.UsageToJSON)(value.usage)
    };
}
exports.QueryResponseToJSON = QueryResponseToJSON; //# sourceMappingURL=QueryResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/RpcStatus.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ProtobufAny_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufAny.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RpcStatus interface.
 */ function instanceOfRpcStatus(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfRpcStatus = instanceOfRpcStatus;
function RpcStatusFromJSON(json) {
    return RpcStatusFromJSONTyped(json, false);
}
exports.RpcStatusFromJSON = RpcStatusFromJSON;
function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'code': !(0, runtime_1.exists)(json, 'code') ? undefined : json['code'],
        'message': !(0, runtime_1.exists)(json, 'message') ? undefined : json['message'],
        'details': !(0, runtime_1.exists)(json, 'details') ? undefined : json['details'].map(ProtobufAny_1.ProtobufAnyFromJSON)
    };
}
exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
function RpcStatusToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
        'details': value.details === undefined ? undefined : value.details.map(ProtobufAny_1.ProtobufAnyToJSON)
    };
}
exports.RpcStatusToJSON = RpcStatusToJSON; //# sourceMappingURL=RpcStatus.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsVector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsVectorToJSON = exports.SearchRecordsVectorFromJSONTyped = exports.SearchRecordsVectorFromJSON = exports.instanceOfSearchRecordsVector = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsVector interface.
 */ function instanceOfSearchRecordsVector(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfSearchRecordsVector = instanceOfSearchRecordsVector;
function SearchRecordsVectorFromJSON(json) {
    return SearchRecordsVectorFromJSONTyped(json, false);
}
exports.SearchRecordsVectorFromJSON = SearchRecordsVectorFromJSON;
function SearchRecordsVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'values': !(0, runtime_1.exists)(json, 'values') ? undefined : json['values'],
        'sparseValues': !(0, runtime_1.exists)(json, 'sparse_values') ? undefined : json['sparse_values'],
        'sparseIndices': !(0, runtime_1.exists)(json, 'sparse_indices') ? undefined : json['sparse_indices']
    };
}
exports.SearchRecordsVectorFromJSONTyped = SearchRecordsVectorFromJSONTyped;
function SearchRecordsVectorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'values': value.values,
        'sparse_values': value.sparseValues,
        'sparse_indices': value.sparseIndices
    };
}
exports.SearchRecordsVectorToJSON = SearchRecordsVectorToJSON; //# sourceMappingURL=SearchRecordsVector.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestQuery.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsRequestQueryToJSON = exports.SearchRecordsRequestQueryFromJSONTyped = exports.SearchRecordsRequestQueryFromJSON = exports.instanceOfSearchRecordsRequestQuery = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SearchRecordsVector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsVector.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsRequestQuery interface.
 */ function instanceOfSearchRecordsRequestQuery(value) {
    let isInstance = true;
    isInstance = isInstance && "topK" in value;
    return isInstance;
}
exports.instanceOfSearchRecordsRequestQuery = instanceOfSearchRecordsRequestQuery;
function SearchRecordsRequestQueryFromJSON(json) {
    return SearchRecordsRequestQueryFromJSONTyped(json, false);
}
exports.SearchRecordsRequestQueryFromJSON = SearchRecordsRequestQueryFromJSON;
function SearchRecordsRequestQueryFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'topK': json['top_k'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter'],
        'inputs': !(0, runtime_1.exists)(json, 'inputs') ? undefined : json['inputs'],
        'vector': !(0, runtime_1.exists)(json, 'vector') ? undefined : (0, SearchRecordsVector_1.SearchRecordsVectorFromJSON)(json['vector']),
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id']
    };
}
exports.SearchRecordsRequestQueryFromJSONTyped = SearchRecordsRequestQueryFromJSONTyped;
function SearchRecordsRequestQueryToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'top_k': value.topK,
        'filter': value.filter,
        'inputs': value.inputs,
        'vector': (0, SearchRecordsVector_1.SearchRecordsVectorToJSON)(value.vector),
        'id': value.id
    };
}
exports.SearchRecordsRequestQueryToJSON = SearchRecordsRequestQueryToJSON; //# sourceMappingURL=SearchRecordsRequestQuery.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestRerank.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsRequestRerankToJSON = exports.SearchRecordsRequestRerankFromJSONTyped = exports.SearchRecordsRequestRerankFromJSON = exports.instanceOfSearchRecordsRequestRerank = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsRequestRerank interface.
 */ function instanceOfSearchRecordsRequestRerank(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "rankFields" in value;
    return isInstance;
}
exports.instanceOfSearchRecordsRequestRerank = instanceOfSearchRecordsRequestRerank;
function SearchRecordsRequestRerankFromJSON(json) {
    return SearchRecordsRequestRerankFromJSONTyped(json, false);
}
exports.SearchRecordsRequestRerankFromJSON = SearchRecordsRequestRerankFromJSON;
function SearchRecordsRequestRerankFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'rankFields': json['rank_fields'],
        'topN': !(0, runtime_1.exists)(json, 'top_n') ? undefined : json['top_n'],
        'parameters': !(0, runtime_1.exists)(json, 'parameters') ? undefined : json['parameters'],
        'query': !(0, runtime_1.exists)(json, 'query') ? undefined : json['query']
    };
}
exports.SearchRecordsRequestRerankFromJSONTyped = SearchRecordsRequestRerankFromJSONTyped;
function SearchRecordsRequestRerankToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'rank_fields': value.rankFields,
        'top_n': value.topN,
        'parameters': value.parameters,
        'query': value.query
    };
}
exports.SearchRecordsRequestRerankToJSON = SearchRecordsRequestRerankToJSON; //# sourceMappingURL=SearchRecordsRequestRerank.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsRequestToJSON = exports.SearchRecordsRequestFromJSONTyped = exports.SearchRecordsRequestFromJSON = exports.instanceOfSearchRecordsRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SearchRecordsRequestQuery_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestQuery.js [app-route] (ecmascript)");
const SearchRecordsRequestRerank_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestRerank.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsRequest interface.
 */ function instanceOfSearchRecordsRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "query" in value;
    return isInstance;
}
exports.instanceOfSearchRecordsRequest = instanceOfSearchRecordsRequest;
function SearchRecordsRequestFromJSON(json) {
    return SearchRecordsRequestFromJSONTyped(json, false);
}
exports.SearchRecordsRequestFromJSON = SearchRecordsRequestFromJSON;
function SearchRecordsRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'query': (0, SearchRecordsRequestQuery_1.SearchRecordsRequestQueryFromJSON)(json['query']),
        'fields': !(0, runtime_1.exists)(json, 'fields') ? undefined : json['fields'],
        'rerank': !(0, runtime_1.exists)(json, 'rerank') ? undefined : (0, SearchRecordsRequestRerank_1.SearchRecordsRequestRerankFromJSON)(json['rerank'])
    };
}
exports.SearchRecordsRequestFromJSONTyped = SearchRecordsRequestFromJSONTyped;
function SearchRecordsRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'query': (0, SearchRecordsRequestQuery_1.SearchRecordsRequestQueryToJSON)(value.query),
        'fields': value.fields,
        'rerank': (0, SearchRecordsRequestRerank_1.SearchRecordsRequestRerankToJSON)(value.rerank)
    };
}
exports.SearchRecordsRequestToJSON = SearchRecordsRequestToJSON; //# sourceMappingURL=SearchRecordsRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsResponseResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsResponseResultToJSON = exports.SearchRecordsResponseResultFromJSONTyped = exports.SearchRecordsResponseResultFromJSON = exports.instanceOfSearchRecordsResponseResult = void 0;
const Hit_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Hit.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsResponseResult interface.
 */ function instanceOfSearchRecordsResponseResult(value) {
    let isInstance = true;
    isInstance = isInstance && "hits" in value;
    return isInstance;
}
exports.instanceOfSearchRecordsResponseResult = instanceOfSearchRecordsResponseResult;
function SearchRecordsResponseResultFromJSON(json) {
    return SearchRecordsResponseResultFromJSONTyped(json, false);
}
exports.SearchRecordsResponseResultFromJSON = SearchRecordsResponseResultFromJSON;
function SearchRecordsResponseResultFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'hits': json['hits'].map(Hit_1.HitFromJSON)
    };
}
exports.SearchRecordsResponseResultFromJSONTyped = SearchRecordsResponseResultFromJSONTyped;
function SearchRecordsResponseResultToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'hits': value.hits.map(Hit_1.HitToJSON)
    };
}
exports.SearchRecordsResponseResultToJSON = SearchRecordsResponseResultToJSON; //# sourceMappingURL=SearchRecordsResponseResult.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchUsage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchUsageToJSON = exports.SearchUsageFromJSONTyped = exports.SearchUsageFromJSON = exports.instanceOfSearchUsage = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchUsage interface.
 */ function instanceOfSearchUsage(value) {
    let isInstance = true;
    isInstance = isInstance && "readUnits" in value;
    return isInstance;
}
exports.instanceOfSearchUsage = instanceOfSearchUsage;
function SearchUsageFromJSON(json) {
    return SearchUsageFromJSONTyped(json, false);
}
exports.SearchUsageFromJSON = SearchUsageFromJSON;
function SearchUsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'readUnits': json['read_units'],
        'embedTotalTokens': !(0, runtime_1.exists)(json, 'embed_total_tokens') ? undefined : json['embed_total_tokens'],
        'rerankUnits': !(0, runtime_1.exists)(json, 'rerank_units') ? undefined : json['rerank_units']
    };
}
exports.SearchUsageFromJSONTyped = SearchUsageFromJSONTyped;
function SearchUsageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'read_units': value.readUnits,
        'embed_total_tokens': value.embedTotalTokens,
        'rerank_units': value.rerankUnits
    };
}
exports.SearchUsageToJSON = SearchUsageToJSON; //# sourceMappingURL=SearchUsage.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsResponseToJSON = exports.SearchRecordsResponseFromJSONTyped = exports.SearchRecordsResponseFromJSON = exports.instanceOfSearchRecordsResponse = void 0;
const SearchRecordsResponseResult_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsResponseResult.js [app-route] (ecmascript)");
const SearchUsage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchUsage.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchRecordsResponse interface.
 */ function instanceOfSearchRecordsResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "result" in value;
    isInstance = isInstance && "usage" in value;
    return isInstance;
}
exports.instanceOfSearchRecordsResponse = instanceOfSearchRecordsResponse;
function SearchRecordsResponseFromJSON(json) {
    return SearchRecordsResponseFromJSONTyped(json, false);
}
exports.SearchRecordsResponseFromJSON = SearchRecordsResponseFromJSON;
function SearchRecordsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'result': (0, SearchRecordsResponseResult_1.SearchRecordsResponseResultFromJSON)(json['result']),
        'usage': (0, SearchUsage_1.SearchUsageFromJSON)(json['usage'])
    };
}
exports.SearchRecordsResponseFromJSONTyped = SearchRecordsResponseFromJSONTyped;
function SearchRecordsResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'result': (0, SearchRecordsResponseResult_1.SearchRecordsResponseResultToJSON)(value.result),
        'usage': (0, SearchUsage_1.SearchUsageToJSON)(value.usage)
    };
}
exports.SearchRecordsResponseToJSON = SearchRecordsResponseToJSON; //# sourceMappingURL=SearchRecordsResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchVector.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchVectorToJSON = exports.SearchVectorFromJSONTyped = exports.SearchVectorFromJSON = exports.instanceOfSearchVector = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SearchVector interface.
 */ function instanceOfSearchVector(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfSearchVector = instanceOfSearchVector;
function SearchVectorFromJSON(json) {
    return SearchVectorFromJSONTyped(json, false);
}
exports.SearchVectorFromJSON = SearchVectorFromJSON;
function SearchVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'values': !(0, runtime_1.exists)(json, 'values') ? undefined : json['values']
    };
}
exports.SearchVectorFromJSONTyped = SearchVectorFromJSONTyped;
function SearchVectorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'values': value.values
    };
}
exports.SearchVectorToJSON = SearchVectorToJSON; //# sourceMappingURL=SearchVector.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StartImportRequestToJSON = exports.StartImportRequestFromJSONTyped = exports.StartImportRequestFromJSON = exports.instanceOfStartImportRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const ImportErrorMode_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportErrorMode.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the StartImportRequest interface.
 */ function instanceOfStartImportRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "uri" in value;
    return isInstance;
}
exports.instanceOfStartImportRequest = instanceOfStartImportRequest;
function StartImportRequestFromJSON(json) {
    return StartImportRequestFromJSONTyped(json, false);
}
exports.StartImportRequestFromJSON = StartImportRequestFromJSON;
function StartImportRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'integrationId': !(0, runtime_1.exists)(json, 'integrationId') ? undefined : json['integrationId'],
        'uri': json['uri'],
        'errorMode': !(0, runtime_1.exists)(json, 'errorMode') ? undefined : (0, ImportErrorMode_1.ImportErrorModeFromJSON)(json['errorMode'])
    };
}
exports.StartImportRequestFromJSONTyped = StartImportRequestFromJSONTyped;
function StartImportRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'integrationId': value.integrationId,
        'uri': value.uri,
        'errorMode': (0, ImportErrorMode_1.ImportErrorModeToJSON)(value.errorMode)
    };
}
exports.StartImportRequestToJSON = StartImportRequestToJSON; //# sourceMappingURL=StartImportRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StartImportResponseToJSON = exports.StartImportResponseFromJSONTyped = exports.StartImportResponseFromJSON = exports.instanceOfStartImportResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the StartImportResponse interface.
 */ function instanceOfStartImportResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfStartImportResponse = instanceOfStartImportResponse;
function StartImportResponseFromJSON(json) {
    return StartImportResponseFromJSONTyped(json, false);
}
exports.StartImportResponseFromJSON = StartImportResponseFromJSON;
function StartImportResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id']
    };
}
exports.StartImportResponseFromJSONTyped = StartImportResponseFromJSONTyped;
function StartImportResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id
    };
}
exports.StartImportResponseToJSON = StartImportResponseToJSON; //# sourceMappingURL=StartImportResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpdateRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const SparseValues_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UpdateRequest interface.
 */ function instanceOfUpdateRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
function UpdateRequestFromJSON(json) {
    return UpdateRequestFromJSONTyped(json, false);
}
exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': json['id'],
        'values': !(0, runtime_1.exists)(json, 'values') ? undefined : json['values'],
        'sparseValues': !(0, runtime_1.exists)(json, 'sparseValues') ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json['sparseValues']),
        'setMetadata': !(0, runtime_1.exists)(json, 'setMetadata') ? undefined : json['setMetadata'],
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace']
    };
}
exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
function UpdateRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'values': value.values,
        'sparseValues': (0, SparseValues_1.SparseValuesToJSON)(value.sparseValues),
        'setMetadata': value.setMetadata,
        'namespace': value.namespace
    };
}
exports.UpdateRequestToJSON = UpdateRequestToJSON; //# sourceMappingURL=UpdateRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertRecord.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpsertRecordToJSON = exports.UpsertRecordFromJSONTyped = exports.UpsertRecordFromJSON = exports.instanceOfUpsertRecord = void 0;
/**
 * Check if a given object implements the UpsertRecord interface.
 */ function instanceOfUpsertRecord(value) {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
exports.instanceOfUpsertRecord = instanceOfUpsertRecord;
function UpsertRecordFromJSON(json) {
    return UpsertRecordFromJSONTyped(json, false);
}
exports.UpsertRecordFromJSON = UpsertRecordFromJSON;
function UpsertRecordFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': json['_id']
    };
}
exports.UpsertRecordFromJSONTyped = UpsertRecordFromJSONTyped;
function UpsertRecordToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        '_id': value.id
    };
}
exports.UpsertRecordToJSON = UpsertRecordToJSON; //# sourceMappingURL=UpsertRecord.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
const Vector_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Vector.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UpsertRequest interface.
 */ function instanceOfUpsertRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "vectors" in value;
    return isInstance;
}
exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
function UpsertRequestFromJSON(json) {
    return UpsertRequestFromJSONTyped(json, false);
}
exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'vectors': json['vectors'].map(Vector_1.VectorFromJSON),
        'namespace': !(0, runtime_1.exists)(json, 'namespace') ? undefined : json['namespace']
    };
}
exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
function UpsertRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'vectors': value.vectors.map(Vector_1.VectorToJSON),
        'namespace': value.namespace
    };
}
exports.UpsertRequestToJSON = UpsertRequestToJSON; //# sourceMappingURL=UpsertRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UpsertResponse interface.
 */ function instanceOfUpsertResponse(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
function UpsertResponseFromJSON(json) {
    return UpsertResponseFromJSONTyped(json, false);
}
exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'upsertedCount': !(0, runtime_1.exists)(json, 'upsertedCount') ? undefined : json['upsertedCount']
    };
}
exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
function UpsertResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'upsertedCount': value.upsertedCount
    };
}
exports.UpsertResponseToJSON = UpsertResponseToJSON; //# sourceMappingURL=UpsertResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DeleteRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DescribeIndexStatsRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/FetchResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Hit.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportErrorMode.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/IndexDescription.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListImportsResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListItem.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListNamespacesResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceDescription.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceSummary.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufAny.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufNullValue.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryVector.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/RpcStatus.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ScoredVector.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestQuery.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsRequestRerank.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsResponseResult.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchRecordsVector.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchUsage.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SearchVector.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SingleQueryResults.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpdateRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertRecord.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Vector.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/BulkOperationsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BulkOperationsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class BulkOperationsApi extends runtime.BaseAPI {
    /**
     * Cancel an import operation if it is not yet finished. It has no effect if the operation is already finished.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Cancel an import
     */ async cancelBulkImportRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling cancelBulkImport.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/bulk/imports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Cancel an import operation if it is not yet finished. It has no effect if the operation is already finished.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Cancel an import
     */ async cancelBulkImport(requestParameters, initOverrides) {
        const response = await this.cancelBulkImportRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Return details of a specific import operation.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Describe an import
     */ async describeBulkImportRaw(requestParameters, initOverrides) {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id', 'Required parameter requestParameters.id was null or undefined when calling describeBulkImport.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/bulk/imports/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ImportModelFromJSON)(jsonValue));
    }
    /**
     * Return details of a specific import operation.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Describe an import
     */ async describeBulkImport(requestParameters, initOverrides) {
        const response = await this.describeBulkImportRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all recent and ongoing import operations.  By default, `list_imports` returns up to 100 imports per page. If the `limit` parameter is set, `list` returns up to that number of imports instead. Whenever there are additional IDs to return, the response also includes a `pagination_token` that you can use to get the next batch of imports. When the response does not include a `pagination_token`, there are no more imports to return.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * List imports
     */ async listBulkImportsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/bulk/imports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ListImportsResponseFromJSON)(jsonValue));
    }
    /**
     * List all recent and ongoing import operations.  By default, `list_imports` returns up to 100 imports per page. If the `limit` parameter is set, `list` returns up to that number of imports instead. Whenever there are additional IDs to return, the response also includes a `pagination_token` that you can use to get the next batch of imports. When the response does not include a `pagination_token`, there are no more imports to return.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * List imports
     */ async listBulkImports(requestParameters = {}, initOverrides) {
        const response = await this.listBulkImportsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Start an asynchronous import of vectors from object storage into an index.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Start import
     */ async startBulkImportRaw(requestParameters, initOverrides) {
        if (requestParameters.startImportRequest === null || requestParameters.startImportRequest === undefined) {
            throw new runtime.RequiredError('startImportRequest', 'Required parameter requestParameters.startImportRequest was null or undefined when calling startBulkImport.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/bulk/imports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.StartImportRequestToJSON)(requestParameters.startImportRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.StartImportResponseFromJSON)(jsonValue));
    }
    /**
     * Start an asynchronous import of vectors from object storage into an index.  For guidance and examples, see [Import data](https://docs.pinecone.io/guides/index-data/import-data).
     * Start import
     */ async startBulkImport(requestParameters, initOverrides) {
        const response = await this.startBulkImportRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.BulkOperationsApi = BulkOperationsApi; //# sourceMappingURL=BulkOperationsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/NamespaceOperationsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NamespaceOperationsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class NamespaceOperationsApi extends runtime.BaseAPI {
    /**
     * Delete a namespace from a serverless index. Deleting a namespace is irreversible; all data in the namespace is permanently deleted.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * Delete a namespace
     */ async deleteNamespaceRaw(requestParameters, initOverrides) {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace', 'Required parameter requestParameters.namespace was null or undefined when calling deleteNamespace.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/namespaces/{namespace}`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Delete a namespace from a serverless index. Deleting a namespace is irreversible; all data in the namespace is permanently deleted.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * Delete a namespace
     */ async deleteNamespace(requestParameters, initOverrides) {
        const response = await this.deleteNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Describe a namespace in a serverless index, including the total number of vectors in the namespace.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * Describe a namespace
     */ async describeNamespaceRaw(requestParameters, initOverrides) {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace', 'Required parameter requestParameters.namespace was null or undefined when calling describeNamespace.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/namespaces/{namespace}`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.NamespaceDescriptionFromJSON)(jsonValue));
    }
    /**
     * Describe a namespace in a serverless index, including the total number of vectors in the namespace.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * Describe a namespace
     */ async describeNamespace(requestParameters, initOverrides) {
        const response = await this.describeNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all namespaces in a serverless index.  Up to 100 namespaces are returned at a time by default, in sorted order (bitwise C collation). If the `limit` parameter is set, up to that number of namespaces are returned instead. Whenever there are additional namespaces to return, the response also includes a `pagination_token` that you can use to get the next batch of namespaces. When the response does not include a `pagination_token`, there are no more namespaces to return.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * List namespaces
     */ async listNamespacesOperationRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ListNamespacesResponseFromJSON)(jsonValue));
    }
    /**
     * List all namespaces in a serverless index.  Up to 100 namespaces are returned at a time by default, in sorted order (bitwise C collation). If the `limit` parameter is set, up to that number of namespaces are returned instead. Whenever there are additional namespaces to return, the response also includes a `pagination_token` that you can use to get the next batch of namespaces. When the response does not include a `pagination_token`, there are no more namespaces to return.  For guidance and examples, see [Manage namespaces](https://docs.pinecone.io/guides/manage-data/manage-namespaces).  **Note:** This operation is not supported for pod-based indexes.
     * List namespaces
     */ async listNamespacesOperation(requestParameters = {}, initOverrides) {
        const response = await this.listNamespacesOperationRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.NamespaceOperationsApi = NamespaceOperationsApi; //# sourceMappingURL=NamespaceOperationsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/VectorOperationsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Data Plane API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorOperationsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class VectorOperationsApi extends runtime.BaseAPI {
    /**
     * Delete vectors by id from a single namespace.  For guidance and examples, see [Delete data](https://docs.pinecone.io/guides/manage-data/delete-data).
     * Delete vectors
     */ async deleteVectorsRaw(requestParameters, initOverrides) {
        if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === undefined) {
            throw new runtime.RequiredError('deleteRequest', 'Required parameter requestParameters.deleteRequest was null or undefined when calling deleteVectors.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/vectors/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Delete vectors by id from a single namespace.  For guidance and examples, see [Delete data](https://docs.pinecone.io/guides/manage-data/delete-data).
     * Delete vectors
     */ async deleteVectors(requestParameters, initOverrides) {
        const response = await this.deleteVectorsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Return statistics about the contents of an index, including the vector count per namespace, the number of dimensions, and the index fullness.  Serverless indexes scale automatically as needed, so index fullness is relevant only for pod-based indexes.
     * Get index stats
     */ async describeIndexStatsRaw(requestParameters, initOverrides) {
        if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === undefined) {
            throw new runtime.RequiredError('describeIndexStatsRequest', 'Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/describe_index_stats`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.IndexDescriptionFromJSON)(jsonValue));
    }
    /**
     * Return statistics about the contents of an index, including the vector count per namespace, the number of dimensions, and the index fullness.  Serverless indexes scale automatically as needed, so index fullness is relevant only for pod-based indexes.
     * Get index stats
     */ async describeIndexStats(requestParameters, initOverrides) {
        const response = await this.describeIndexStatsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Look up and return vectors by ID from a single namespace. The returned vectors include the vector data and/or metadata.  For guidance and examples, see [Fetch data](https://docs.pinecone.io/guides/manage-data/fetch-data).
     * Fetch vectors
     */ async fetchVectorsRaw(requestParameters, initOverrides) {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids', 'Required parameter requestParameters.ids was null or undefined when calling fetchVectors.');
        }
        const queryParameters = {};
        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids;
        }
        if (requestParameters.namespace !== undefined) {
            queryParameters['namespace'] = requestParameters.namespace;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/vectors/fetch`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.FetchResponseFromJSON)(jsonValue));
    }
    /**
     * Look up and return vectors by ID from a single namespace. The returned vectors include the vector data and/or metadata.  For guidance and examples, see [Fetch data](https://docs.pinecone.io/guides/manage-data/fetch-data).
     * Fetch vectors
     */ async fetchVectors(requestParameters, initOverrides) {
        const response = await this.fetchVectorsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List the IDs of vectors in a single namespace of a serverless index. An optional prefix can be passed to limit the results to IDs with a common prefix.  Returns up to 100 IDs at a time by default in sorted order (bitwise \"C\" collation). If the `limit` parameter is set, `list` returns up to that number of IDs instead. Whenever there are additional IDs to return, the response also includes a `pagination_token` that you can use to get the next batch of IDs. When the response does not include a `pagination_token`, there are no more IDs to return.  For guidance and examples, see [List record IDs](https://docs.pinecone.io/guides/manage-data/list-record-ids).  **Note:** `list` is supported only for serverless indexes.
     * List vector IDs
     */ async listVectorsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.prefix !== undefined) {
            queryParameters['prefix'] = requestParameters.prefix;
        }
        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }
        if (requestParameters.paginationToken !== undefined) {
            queryParameters['paginationToken'] = requestParameters.paginationToken;
        }
        if (requestParameters.namespace !== undefined) {
            queryParameters['namespace'] = requestParameters.namespace;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/vectors/list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ListResponseFromJSON)(jsonValue));
    }
    /**
     * List the IDs of vectors in a single namespace of a serverless index. An optional prefix can be passed to limit the results to IDs with a common prefix.  Returns up to 100 IDs at a time by default in sorted order (bitwise \"C\" collation). If the `limit` parameter is set, `list` returns up to that number of IDs instead. Whenever there are additional IDs to return, the response also includes a `pagination_token` that you can use to get the next batch of IDs. When the response does not include a `pagination_token`, there are no more IDs to return.  For guidance and examples, see [List record IDs](https://docs.pinecone.io/guides/manage-data/list-record-ids).  **Note:** `list` is supported only for serverless indexes.
     * List vector IDs
     */ async listVectors(requestParameters = {}, initOverrides) {
        const response = await this.listVectorsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Search a namespace using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.  For guidance, examples, and limits, see [Search](https://docs.pinecone.io/guides/search/search-overview).
     * Search with a vector
     */ async queryVectorsRaw(requestParameters, initOverrides) {
        if (requestParameters.queryRequest === null || requestParameters.queryRequest === undefined) {
            throw new runtime.RequiredError('queryRequest', 'Required parameter requestParameters.queryRequest was null or undefined when calling queryVectors.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.QueryRequestToJSON)(requestParameters.queryRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.QueryResponseFromJSON)(jsonValue));
    }
    /**
     * Search a namespace using a query vector. It retrieves the ids of the most similar items in a namespace, along with their similarity scores.  For guidance, examples, and limits, see [Search](https://docs.pinecone.io/guides/search/search-overview).
     * Search with a vector
     */ async queryVectors(requestParameters, initOverrides) {
        const response = await this.queryVectorsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Search a namespace with a query text, query vector, or record ID and return the most similar records, along with their similarity scores. Optionally, rerank the initial results based on their relevance to the query.   Searching with text is supported only for [indexes with integrated embedding](https://docs.pinecone.io/guides/indexes/create-an-index#integrated-embedding). Searching with a query vector or record ID is supported for all indexes.   For guidance, examples, and limits, see [Search](https://docs.pinecone.io/guides/search/search-overview).
     * Search with text
     */ async searchRecordsNamespaceRaw(requestParameters, initOverrides) {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace', 'Required parameter requestParameters.namespace was null or undefined when calling searchRecordsNamespace.');
        }
        if (requestParameters.searchRecordsRequest === null || requestParameters.searchRecordsRequest === undefined) {
            throw new runtime.RequiredError('searchRecordsRequest', 'Required parameter requestParameters.searchRecordsRequest was null or undefined when calling searchRecordsNamespace.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/records/namespaces/{namespace}/search`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.SearchRecordsRequestToJSON)(requestParameters.searchRecordsRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.SearchRecordsResponseFromJSON)(jsonValue));
    }
    /**
     * Search a namespace with a query text, query vector, or record ID and return the most similar records, along with their similarity scores. Optionally, rerank the initial results based on their relevance to the query.   Searching with text is supported only for [indexes with integrated embedding](https://docs.pinecone.io/guides/indexes/create-an-index#integrated-embedding). Searching with a query vector or record ID is supported for all indexes.   For guidance, examples, and limits, see [Search](https://docs.pinecone.io/guides/search/search-overview).
     * Search with text
     */ async searchRecordsNamespace(requestParameters, initOverrides) {
        const response = await this.searchRecordsNamespaceRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Update a vector in a namespace. If a value is included, it will overwrite the previous value. If a `set_metadata` is included, the values of the fields specified in it will be added or overwrite the previous value.  For guidance and examples, see [Update data](https://docs.pinecone.io/guides/manage-data/update-data).
     * Update a vector
     */ async updateVectorRaw(requestParameters, initOverrides) {
        if (requestParameters.updateRequest === null || requestParameters.updateRequest === undefined) {
            throw new runtime.RequiredError('updateRequest', 'Required parameter requestParameters.updateRequest was null or undefined when calling updateVector.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/vectors/update`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.UpdateRequestToJSON)(requestParameters.updateRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response);
    }
    /**
     * Update a vector in a namespace. If a value is included, it will overwrite the previous value. If a `set_metadata` is included, the values of the fields specified in it will be added or overwrite the previous value.  For guidance and examples, see [Update data](https://docs.pinecone.io/guides/manage-data/update-data).
     * Update a vector
     */ async updateVector(requestParameters, initOverrides) {
        const response = await this.updateVectorRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Upsert text into a namespace. Pinecone converts the text to vectors automatically using the hosted embedding model associated with the index.  Upserting text is supported only for [indexes with integrated embedding](https://docs.pinecone.io/reference/api/2025-01/control-plane/create_for_model).  For guidance, examples, and limits, see [Upsert data](https://docs.pinecone.io/guides/index-data/upsert-data).
     * Upsert text
     */ async upsertRecordsNamespaceRaw(requestParameters, initOverrides) {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace', 'Required parameter requestParameters.namespace was null or undefined when calling upsertRecordsNamespace.');
        }
        if (requestParameters.upsertRecord === null || requestParameters.upsertRecord === undefined) {
            throw new runtime.RequiredError('upsertRecord', 'Required parameter requestParameters.upsertRecord was null or undefined when calling upsertRecordsNamespace.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/x-ndjson';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/records/namespaces/{namespace}/upsert`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.upsertRecord.map(index_1.UpsertRecordToJSON)
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Upsert text into a namespace. Pinecone converts the text to vectors automatically using the hosted embedding model associated with the index.  Upserting text is supported only for [indexes with integrated embedding](https://docs.pinecone.io/reference/api/2025-01/control-plane/create_for_model).  For guidance, examples, and limits, see [Upsert data](https://docs.pinecone.io/guides/index-data/upsert-data).
     * Upsert text
     */ async upsertRecordsNamespace(requestParameters, initOverrides) {
        await this.upsertRecordsNamespaceRaw(requestParameters, initOverrides);
    }
    /**
     * Upsert vectors into a namespace. If a new value is upserted for an existing vector ID, it will overwrite the previous value.  For guidance, examples, and limits, see [Upsert data](https://docs.pinecone.io/guides/index-data/upsert-data).
     * Upsert vectors
     */ async upsertVectorsRaw(requestParameters, initOverrides) {
        if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === undefined) {
            throw new runtime.RequiredError('upsertRequest', 'Required parameter requestParameters.upsertRequest was null or undefined when calling upsertVectors.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/vectors/upsert`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.UpsertResponseFromJSON)(jsonValue));
    }
    /**
     * Upsert vectors into a namespace. If a new value is upserted for an existing vector ID, it will overwrite the previous value.  For guidance, examples, and limits, see [Upsert data](https://docs.pinecone.io/guides/index-data/upsert-data).
     * Upsert vectors
     */ async upsertVectors(requestParameters, initOverrides) {
        const response = await this.upsertVectorsRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.VectorOperationsApi = VectorOperationsApi; //# sourceMappingURL=VectorOperationsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/BulkOperationsApi.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/NamespaceOperationsApi.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/VectorOperationsApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/vectorOperationsProvider.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorOperationsProvider = void 0;
const db_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const indexHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
class VectorOperationsProvider {
    constructor(config, indexName, indexHostUrl, additionalHeaders){
        this.config = config;
        this.indexName = indexName;
        this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
        this.additionalHeaders = additionalHeaders;
    }
    async provide() {
        if (this.vectorOperations) {
            return this.vectorOperations;
        }
        // If an indexHostUrl has been manually passed we use that,
        // otherwise we rely on resolving the host from the IndexHostSingleton
        if (this.indexHostUrl) {
            this.vectorOperations = this.buildDataOperationsConfig();
        } else {
            this.indexHostUrl = await indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName);
            this.vectorOperations = this.buildDataOperationsConfig();
        }
        return this.vectorOperations;
    }
    async provideHostUrl() {
        return await indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName);
    }
    buildDataOperationsConfig() {
        const headers = this.additionalHeaders || null;
        const indexConfigurationParameters = {
            basePath: this.indexHostUrl,
            apiKey: this.config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
                'User-Agent': (0, utils_1.buildUserAgent)(this.config),
                'X-Pinecone-Api-Version': db_data_1.X_PINECONE_API_VERSION,
                ...headers
            },
            fetchApi: (0, utils_1.getFetch)(this.config),
            middleware: middleware_1.middleware
        };
        const indexConfiguration = new db_data_1.Configuration(indexConfigurationParameters);
        return new db_data_1.VectorOperationsApi(indexConfiguration);
    }
}
exports.VectorOperationsProvider = VectorOperationsProvider; //# sourceMappingURL=vectorOperationsProvider.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/list.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listPaginated = void 0;
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const ListOptionsProperties = [
    'prefix',
    'limit',
    'paginationToken'
];
const listPaginated = (apiProvider, namespace)=>{
    const validator = (options)=>{
        if (options) {
            (0, validateObjectProperties_1.ValidateObjectProperties)(options, ListOptionsProperties);
        }
        // Don't need to check for empty string prefix or paginationToken, since empty strings evaluate to false
        if (options.limit && options.limit < 0) {
            throw new Error('`limit` property must be greater than 0');
        }
    };
    return async (options)=>{
        if (options) {
            validator(options);
        }
        const listRequest = {
            ...options,
            namespace
        };
        const api = await apiProvider.provide();
        return await api.listVectors(listRequest);
    };
};
exports.listPaginated = listPaginated; //# sourceMappingURL=list.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/upsertRecords.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpsertRecordsCommand = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const db_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)");
class UpsertRecordsCommand {
    constructor(apiProvider, namespace, config){
        this.validator = (records)=>{
            for (const record of records){
                if (!record.id && !record._id) {
                    throw new errors_1.PineconeArgumentError('Every record must include an `id` or `_id` property in order to upsert.');
                }
            }
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
        this.config = config;
    }
    async run(records, maxRetries) {
        const fetch = (0, utils_1.getFetch)(this.config);
        this.validator(records);
        const hostUrl = await this.apiProvider.provideHostUrl();
        const upsertRecordsUrl = `${hostUrl}/records/namespaces/${this.namespace}/upsert`;
        const requestHeaders = {
            'Api-Key': this.config.apiKey,
            'User-Agent': (0, utils_1.buildUserAgent)(this.config),
            'X-Pinecone-Api-Version': db_data_1.X_PINECONE_API_VERSION
        };
        const retryWrapper = new utils_1.RetryOnServerFailure(()=>fetch(upsertRecordsUrl, {
                method: 'POST',
                headers: requestHeaders,
                body: toNdJson(records)
            }), maxRetries);
        const response = await retryWrapper.execute();
        if (response.ok) {
            return;
        } else {
            const err = await (0, errors_1.handleApiError)(new db_data_1.ResponseError(response, 'Response returned an error'), undefined, upsertRecordsUrl);
            throw err;
        }
    }
}
exports.UpsertRecordsCommand = UpsertRecordsCommand;
function toNdJson(data) {
    return data.map((record)=>JSON.stringify(record)).join('\n');
} //# sourceMappingURL=upsertRecords.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/searchRecords.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchRecordsCommand = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
class SearchRecordsCommand {
    constructor(apiProvider, namespace){
        this.validator = (options)=>{
            if (!options.query) {
                throw new errors_1.PineconeArgumentError('You must pass a `query` object to search.');
            }
        };
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(searchOptions, maxRetries) {
        this.validator(searchOptions);
        const api = await this.apiProvider.provide();
        const retryWrapper = new utils_1.RetryOnServerFailure(api.searchRecordsNamespace.bind(api), maxRetries);
        return await retryWrapper.execute({
            searchRecordsRequest: searchOptions,
            namespace: this.namespace
        });
    }
}
exports.SearchRecordsCommand = SearchRecordsCommand; //# sourceMappingURL=searchRecords.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/startImport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StartImportCommand = void 0;
const db_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
class StartImportCommand {
    constructor(apiProvider, namespace){
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(uri, errorMode, integrationId) {
        if (!uri) {
            throw new errors_1.PineconeArgumentError('`uri` field is required and must start with the scheme of a supported storage provider.');
        }
        let error = db_data_1.ImportErrorModeOnErrorEnum.Continue;
        if (errorMode) {
            if (errorMode.toLowerCase() !== 'continue' && errorMode.toLowerCase() !== 'abort') {
                throw new errors_1.PineconeArgumentError('`errorMode` must be one of "Continue" or "Abort"');
            }
            if (errorMode?.toLowerCase() == 'abort') {
                error = db_data_1.ImportErrorModeOnErrorEnum.Abort;
            }
        }
        const req = {
            startImportRequest: {
                uri: uri,
                errorMode: {
                    onError: error
                },
                integrationId: integrationId
            }
        };
        const api = await this.apiProvider.provide();
        return await api.startBulkImport(req);
    }
}
exports.StartImportCommand = StartImportCommand; //# sourceMappingURL=startImport.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/listImports.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListImportsCommand = void 0;
class ListImportsCommand {
    constructor(apiProvider, namespace){
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(limit, paginationToken) {
        const req = {
            limit: limit,
            paginationToken: paginationToken
        };
        const api = await this.apiProvider.provide();
        return await api.listBulkImports(req);
    }
}
exports.ListImportsCommand = ListImportsCommand; //# sourceMappingURL=listImports.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/describeImport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DescribeImportCommand = void 0;
class DescribeImportCommand {
    constructor(apiProvider, namespace){
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(id) {
        const req = {
            id: id
        };
        const api = await this.apiProvider.provide();
        return await api.describeBulkImport(req);
    }
}
exports.DescribeImportCommand = DescribeImportCommand; //# sourceMappingURL=describeImport.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/cancelImport.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancelImportCommand = void 0;
class CancelImportCommand {
    constructor(apiProvider, namespace){
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    async run(id) {
        const req = {
            id: id
        };
        const api = await this.apiProvider.provide();
        return await api.cancelBulkImport(req);
    }
}
exports.CancelImportCommand = CancelImportCommand; //# sourceMappingURL=cancelImport.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/bulkOperationsProvider.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BulkOperationsProvider = void 0;
const db_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const indexHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
class BulkOperationsProvider {
    constructor(config, indexName, indexHostUrl, additionalHeaders){
        this.config = config;
        this.indexName = indexName;
        this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
        this.additionalHeaders = additionalHeaders;
    }
    async provide() {
        if (this.bulkOperations) {
            return this.bulkOperations;
        }
        // If an indexHostUrl has been manually passed we use that,
        // otherwise we rely on resolving the host from the IndexHostSingleton
        if (this.indexHostUrl) {
            this.bulkOperations = this.buildBulkOperationsConfig();
        } else {
            this.indexHostUrl = await indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName);
            this.bulkOperations = this.buildBulkOperationsConfig();
        }
        return this.bulkOperations;
    }
    buildBulkOperationsConfig() {
        const headers = this.additionalHeaders || null;
        const indexConfigurationParameters = {
            basePath: this.indexHostUrl,
            apiKey: this.config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
                'User-Agent': (0, utils_1.buildUserAgent)(this.config),
                'X-Pinecone-Api-Version': db_data_1.X_PINECONE_API_VERSION,
                ...headers
            },
            fetchApi: (0, utils_1.getFetch)(this.config),
            middleware: middleware_1.middleware
        };
        const indexConfiguration = new db_data_1.Configuration(indexConfigurationParameters);
        return new db_data_1.BulkOperationsApi(indexConfiguration);
    }
}
exports.BulkOperationsProvider = BulkOperationsProvider; //# sourceMappingURL=bulkOperationsProvider.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/namespacesOperationsProvider.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NamespaceOperationsProvider = void 0;
const db_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const indexHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
class NamespaceOperationsProvider {
    constructor(config, indexName, indexHostUrl, additionalHeaders){
        this.config = config;
        this.indexName = indexName;
        this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
        this.additionalHeaders = additionalHeaders;
    }
    async provide() {
        if (this.namespaceOperations) {
            return this.namespaceOperations;
        }
        // If an indexHostUrl has been manually passed we use that,
        // otherwise we rely on resolving the host from the IndexHostSingleton
        if (this.indexHostUrl) {
            this.namespaceOperations = this.buildNamespaceOperationsConfig();
        } else {
            this.indexHostUrl = await indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName);
            this.namespaceOperations = this.buildNamespaceOperationsConfig();
        }
        return this.namespaceOperations;
    }
    buildNamespaceOperationsConfig() {
        const headers = this.additionalHeaders || null;
        const indexConfigurationParameters = {
            basePath: this.indexHostUrl,
            apiKey: this.config.apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
                'User-Agent': (0, utils_1.buildUserAgent)(this.config),
                'X-Pinecone-Api-Version': db_data_1.X_PINECONE_API_VERSION,
                ...headers
            },
            fetchApi: (0, utils_1.getFetch)(this.config),
            middleware: middleware_1.middleware
        };
        const indexConfiguration = new db_data_1.Configuration(indexConfigurationParameters);
        return new db_data_1.NamespaceOperationsApi(indexConfiguration);
    }
}
exports.NamespaceOperationsProvider = NamespaceOperationsProvider; //# sourceMappingURL=namespacesOperationsProvider.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/listNamespaces.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listNamespaces = void 0;
const listNamespaces = (apiProvider)=>{
    return async (limit, paginationToken)=>{
        const api = await apiProvider.provide();
        return await api.listNamespacesOperation({
            limit,
            paginationToken
        });
    };
};
exports.listNamespaces = listNamespaces; //# sourceMappingURL=listNamespaces.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/describeNamespace.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeNamespace = void 0;
const describeNamespace = (apiProvider)=>{
    return async (namespace)=>{
        const api = await apiProvider.provide();
        return await api.describeNamespace({
            namespace
        });
    };
};
exports.describeNamespace = describeNamespace; //# sourceMappingURL=describeNamespace.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/deleteNamespace.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteNamespace = void 0;
const deleteNamespace = (apiProvider)=>{
    return async (namespace)=>{
        const api = await apiProvider.provide();
        await api.deleteNamespace({
            namespace
        });
        return;
    };
};
exports.deleteNamespace = deleteNamespace; //# sourceMappingURL=deleteNamespace.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/data/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Index = void 0;
const upsert_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/upsert.js [app-route] (ecmascript)");
const fetch_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/fetch.js [app-route] (ecmascript)");
const update_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/update.js [app-route] (ecmascript)");
const query_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/query.js [app-route] (ecmascript)");
const deleteOne_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteOne.js [app-route] (ecmascript)");
const deleteMany_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteMany.js [app-route] (ecmascript)");
const deleteAll_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteAll.js [app-route] (ecmascript)");
const describeIndexStats_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/describeIndexStats.js [app-route] (ecmascript)");
const vectorOperationsProvider_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/vectorOperationsProvider.js [app-route] (ecmascript)");
const list_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/list.js [app-route] (ecmascript)");
const upsertRecords_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/upsertRecords.js [app-route] (ecmascript)");
const searchRecords_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/searchRecords.js [app-route] (ecmascript)");
const startImport_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/startImport.js [app-route] (ecmascript)");
const listImports_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/listImports.js [app-route] (ecmascript)");
const describeImport_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/describeImport.js [app-route] (ecmascript)");
const cancelImport_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/cancelImport.js [app-route] (ecmascript)");
const bulkOperationsProvider_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/bulk/bulkOperationsProvider.js [app-route] (ecmascript)");
const namespacesOperationsProvider_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/namespacesOperationsProvider.js [app-route] (ecmascript)");
const listNamespaces_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/listNamespaces.js [app-route] (ecmascript)");
const describeNamespace_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/describeNamespace.js [app-route] (ecmascript)");
const deleteNamespace_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/namespaces/deleteNamespace.js [app-route] (ecmascript)");
/**
 * The `Index` class is used to perform data operations (upsert, query, etc)
 * against Pinecone indexes. Typically, it will be instantiated via a `Pinecone`
 * client instance that has already built the required configuration from a
 * combination of sources.
 *
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone()
 *
 * const index = pc.index('index-name')
 * ```
 *
 * ### Targeting an index, with user-defined Metadata types
 *
 * If you are storing metadata alongside your vector values inside your Pinecone records, you can pass a type parameter to `index()` in order to get proper TypeScript typechecking when upserting and querying data.
 *
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone();
 *
 * type MovieMetadata = {
 *   title: string,
 *   runtime: numbers,
 *   genre: 'comedy' | 'horror' | 'drama' | 'action'
 * }
 *
 * // Specify a custom metadata type while targeting the index
 * const index = pc.index<MovieMetadata>('test-index');
 *
 * // Now you get type errors if upserting malformed metadata
 * await index.upsert([{
 *   id: '1234',
 *   values: [
 *     .... // embedding values
 *   ],
 *   metadata: {
 *     genre: 'Gone with the Wind',
 *     runtime: 238,
 *     genre: 'drama',
 *
 *     // @ts-expect-error because category property not in MovieMetadata
 *     category: 'classic'
 *   }
 * }])
 *
 * const results = await index.query({
 *    vector: [
 *     ... // query embedding
 *    ],
 *    filter: { genre: { '$eq': 'drama' }}
 * })
 * const movie = results.matches[0];
 *
 * if (movie.metadata) {
 *   // Since we passed the MovieMetadata type parameter above,
 *   // we can interact with metadata fields without having to
 *   // do any typecasting.
 *   const { title, runtime, genre } = movie.metadata;
 *   console.log(`The best match in drama was ${title}`)
 * }
 * ```
 *
 * @typeParam T - The type of metadata associated with each record.
 */ class Index {
    /**
     * Instantiation of Index is handled by {@link Pinecone}
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const index = pc.index('my-index');
     * ```
     *
     * @constructor
     * @param indexName - The name of the index that will receive operations from this {@link Index} instance.
     * @param config - The configuration from the Pinecone client.
     * @param namespace - The namespace for the index.
     * @param indexHostUrl - An optional override for the host address used for data operations.
     * @param additionalHeaders - An optional object of additional header to send with each request.
     */ constructor(indexName, config, namespace = '__default__', indexHostUrl, additionalHeaders){
        this.config = config;
        this.target = {
            index: indexName,
            namespace: namespace,
            indexHostUrl: indexHostUrl
        };
        // vector & record operations
        const dataOperationsProvider = new vectorOperationsProvider_1.VectorOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
        this._deleteAll = (0, deleteAll_1.deleteAll)(dataOperationsProvider, namespace);
        this._deleteMany = (0, deleteMany_1.deleteMany)(dataOperationsProvider, namespace);
        this._deleteOne = (0, deleteOne_1.deleteOne)(dataOperationsProvider, namespace);
        this._describeIndexStats = (0, describeIndexStats_1.describeIndexStats)(dataOperationsProvider);
        this._listPaginated = (0, list_1.listPaginated)(dataOperationsProvider, namespace);
        this._fetchCommand = new fetch_1.FetchCommand(dataOperationsProvider, namespace);
        this._queryCommand = new query_1.QueryCommand(dataOperationsProvider, namespace);
        this._updateCommand = new update_1.UpdateCommand(dataOperationsProvider, namespace);
        this._upsertCommand = new upsert_1.UpsertCommand(dataOperationsProvider, namespace);
        this._upsertRecordsCommand = new upsertRecords_1.UpsertRecordsCommand(dataOperationsProvider, namespace, config);
        this._searchRecordsCommand = new searchRecords_1.SearchRecordsCommand(dataOperationsProvider, namespace);
        // bulk operations
        const bulkApiProvider = new bulkOperationsProvider_1.BulkOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
        this._startImportCommand = new startImport_1.StartImportCommand(bulkApiProvider, namespace);
        this._listImportsCommand = new listImports_1.ListImportsCommand(bulkApiProvider, namespace);
        this._describeImportCommand = new describeImport_1.DescribeImportCommand(bulkApiProvider, namespace);
        this._cancelImportCommand = new cancelImport_1.CancelImportCommand(bulkApiProvider, namespace);
        // namespace operations
        const namespaceApiProvider = new namespacesOperationsProvider_1.NamespaceOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
        this._listNamespacesCommand = (0, listNamespaces_1.listNamespaces)(namespaceApiProvider);
        this._describeNamespaceCommand = (0, describeNamespace_1.describeNamespace)(namespaceApiProvider);
        this._deleteNamespaceCommand = (0, deleteNamespace_1.deleteNamespace)(namespaceApiProvider);
    }
    /**
     * Delete all records from the targeted namespace. To delete all records from across all namespaces,
     * delete the index using {@link Pinecone.deleteIndex} and create a new one using {@link Pinecone.createIndex}.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.describeIndexStats();
     * // {
     * //  namespaces: {
     * //    '': { recordCount: 10 },
     * //   foo: { recordCount: 1 }
     * //   },
     * //   dimension: 8,
     * //   indexFullness: 0,
     * //   totalRecordCount: 11
     * // }
     *
     * await index.deleteAll();
     *
     * // Records from the default namespace '' are now deleted. Records in other namespaces are not modified.
     *
     * await index.describeIndexStats();
     * // {
     * //  namespaces: {
     * //   foo: { recordCount: 1 }
     * //   },
     * //   dimension: 8,
     * //   indexFullness: 0,
     * //   totalRecordCount: 1
     * // }
     * ```
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the delete is completed.
     */ deleteAll() {
        return this._deleteAll();
    }
    /**
     * Delete records from the index by either an array of ids, or a filter object.
     * See [Filtering with metadata](https://docs.pinecone.io/docs/metadata-filtering#deleting-vectors-by-metadata-filter)
     * for more on deleting records with filters.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.deleteMany(['record-1', 'record-2']);
     *
     * // or
     * await index.deleteMany({ genre: 'classical' });
     * ```
     * @param options - An array of record id values or a filter object.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the delete is completed.
     */ deleteMany(options) {
        return this._deleteMany(options);
    }
    /**
     * Delete a record from the index by id.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.deleteOne('record-1');
     * ```
     * @param id - The id of the record to delete.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the delete is completed.
     */ deleteOne(id) {
        return this._deleteOne(id);
    }
    /**
     * Describes the index's statistics such as total number of records, records per namespace, and the index's dimension size.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.describeIndexStats();
     * // {
     * //  namespaces: {
     * //    '': { recordCount: 10 }
     * //    foo: { recordCount: 2000 },
     * //    bar: { recordCount: 2000 }
     * //   },
     * //   dimension: 1536,
     * //   indexFullness: 0,
     * //   totalRecordCount: 4010
     * // }
     * ```
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves with the {@link IndexStatsDescription} value when the operation is completed.
     */ describeIndexStats() {
        return this._describeIndexStats();
    }
    /**
     * The `listPaginated` operation finds vectors based on an id prefix within a single namespace.
     * It returns matching ids in a paginated form, with a pagination token to fetch the next page of results.
     * This id list can then be passed to fetch or delete options to perform operations on the matching records.
     * See [Get record IDs](https://docs.pinecone.io/docs/get-record-ids) for guidance and examples.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const index = pc.index('my-index').namespace('my-namespace');
     *
     * const results = await index.listPaginated({ prefix: 'doc1#' });
     * console.log(results);
     * // {
     * //   vectors: [
     * //     { id: 'doc1#01' }, { id: 'doc1#02' }, { id: 'doc1#03' },
     * //     { id: 'doc1#04' }, { id: 'doc1#05' },  { id: 'doc1#06' },
     * //     { id: 'doc1#07' }, { id: 'doc1#08' }, { id: 'doc1#09' },
     * //     ...
     * //   ],
     * //   pagination: {
     * //     next: 'eyJza2lwX3Bhc3QiOiJwcmVUZXN0LS04MCIsInByZWZpeCI6InByZVRlc3QifQ=='
     * //   },
     * //   namespace: 'my-namespace',
     * //   usage: { readUnits: 1 }
     * // }
     *
     * // Fetch the next page of results
     * await index.listPaginated({ prefix: 'doc1#', paginationToken: results.pagination.next});
     * ```
     *
     * >  **Note:**
     * >
     * > `listPaginated` is supported only for serverless indexes.
     *
     * @param options - The {@link ListOptions} for the operation.
     * @returns - A promise that resolves with the {@link ListResponse} when the operation is completed.
     * @throws {@link Errors.PineconeConnectionError} when invalid environment, project id, or index name is configured.
     * @throws {@link Errors.PineconeArgumentError} when invalid arguments are passed.
     */ listPaginated(options) {
        return this._listPaginated(options);
    }
    /**
     * Returns an {@link Index} targeting the specified namespace. By default, all operations take place inside the default namespace `''`.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * // Create an Index client instance scoped to operate on a
     * // single namespace
     * const ns = pc.index('my-index').namespace('my-namespace');
     *
     * // Now operations against this intance only affect records in
     * // the targeted namespace
     * ns.upsert([
     *   // ... records to upsert in namespace 'my-namespace'
     * ])
     *
     * ns.query({
     *   // ... query records in namespace 'my-namespace'
     * })
     * ```
     * This `namespace()` method will inherit custom metadata types if you are chaining the call off an {@link Index} client instance that is typed with a user-specified metadata type. See {@link Pinecone.index} for more info.
     *
     * @param namespace - The namespace to target within the index. All operations performed with the returned client instance will be scoped only to the targeted namespace.
     * @returns An {@link Index} object that can be used to perform data operations scoped to the specified namespace.
     */ namespace(namespace) {
        return new Index(this.target.index, this.config, namespace, this.target.indexHostUrl);
    }
    /**
     * Upsert records to the index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.upsert([{
     *  id: 'record-1',
     *  values: [0.176, 0.345, 0.263],
     * },{
     *  id: 'record-2',
     *  values: [0.176, 0.345, 0.263],
     * }])
     * ```
     *
     * @param data - An array of {@link PineconeRecord} objects to upsert.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the upsert is completed.
     */ async upsert(data) {
        return await this._upsertCommand.run(data, this.config.maxRetries);
    }
    /**
     * Fetch records from the index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.fetch(['record-1', 'record-2']);
     * ```
     * @param options - The {@link FetchOptions} for the operation.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves with the {@link FetchResponse} when the fetch is completed.
     */ async fetch(options) {
        return await this._fetchCommand.run(options);
    }
    /**
     * Query records from the index. Query is used to find the `topK` records in the index whose vector values are most
     * similar to the vector values of the query according to the distance metric you have configured for your index.
     * See [Query data](https://docs.pinecone.io/docs/query-data) for more on querying.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-index');
     *
     * await index.query({ topK: 3, id: 'record-1'});
     *
     * // or
     * await index.query({ topK: 3, vector: [0.176, 0.345, 0.263] });
     * ```
     *
     * @param options - The {@link QueryOptions} for the operation.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves with the {@link QueryResponse} when the query is completed.
     */ async query(options) {
        return await this._queryCommand.run(options);
    }
    /**
     * Update a record in the index by id.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('imdb-movies');
     *
     * await index.update({
     *   id: '18593',
     *   metadata: { genre: 'romance' },
     * });
     * ```
     *
     * @param options - The {@link UpdateOptions} for the operation.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the update is completed.
     */ async update(options) {
        return await this._updateCommand.run(options, this.config.maxRetries);
    }
    /**
     * Upsert integrated records into a specific namespace within an index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const namespace = pc.index('integrated-index').namespace('my-namespace');
     *
     * await namespace.upsertRecords([
     *   {
     *     id: 'rec1',
     *     chunk_text:
     *       "Apple's first product, the Apple I, was released in 1976 and was hand-built by co-founder Steve Wozniak.",
     *     category: 'product',
     *   },
     *   {
     *     id: 'rec2',
     *     chunk_text:
     *       'Apples are a great source of dietary fiber, which supports digestion and helps maintain a healthy gut.',
     *     category: 'nutrition',
     *   },
     *   {
     *     id: 'rec3',
     *     chunk_text:
     *       'Apples originated in Central Asia and have been cultivated for thousands of years, with over 7,500 varieties available today.',
     *     category: 'cultivation',
     *   },
     *   {
     *     id: 'rec4',
     *     chunk_text:
     *       'In 2001, Apple released the iPod, which transformed the music industry by making portable music widely accessible.',
     *     category: 'product',
     *   },
     *   {
     *     id: 'rec5',
     *     chunk_text:
     *       'Apple went public in 1980, making history with one of the largest IPOs at that time.',
     *     category: 'milestone',
     *   },
     *   {
     *     id: 'rec6',
     *     chunk_text:
     *       'Rich in vitamin C and other antioxidants, apples contribute to immune health and may reduce the risk of chronic diseases.',
     *     category: 'nutrition',
     *   },
     *   {
     *     id: 'rec7',
     *     chunk_text:
     *       "Known for its design-forward products, Apple's branding and market strategy have greatly influenced the technology sector and popularized minimalist design worldwide.",
     *     category: 'influence',
     *   },
     *   {
     *     id: 'rec8',
     *     chunk_text:
     *       'The high fiber content in apples can also help regulate blood sugar levels, making them a favorable snack for people with diabetes.',
     *     category: 'nutrition',
     *   },
     * ]);
     * ```
     *
     * @param data - An array of {@link IntegratedRecord} objects to upsert.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns a promise that resolves when the operation is complete.
     */ async upsertRecords(data) {
        return await this._upsertRecordsCommand.run(data, this.config.maxRetries);
    }
    /**
     * Search a specific namespace for records within an index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const namespace = pc.index('integrated-index').namespace('my-namespace');
     *
     * const response = await namespace.searchRecords({
     *   query: {
     *     inputs: { text: 'disease prevention' }, topK: 4 },
     *     rerank: {
     *       model: 'bge-reranker-v2-m3',
     *       topN: 2,
     *       rankFields: ['chunk_text'],
     *     },
     *   fields: ['category', 'chunk_text'],
     * });
     * console.log(response);
     * // {
     * //   "result": {
     * //     "hits": [
     * //       {
     * //         "id": "rec6",
     * //         "score": 0.1318424493074417,
     * //         "fields": {
     * //           "category": "nutrition",
     * //           "chunk_text": "Rich in vitamin C and other antioxidants, apples contribute to immune health and may reduce the risk of chronic diseases."
     * //         }
     * //       },
     * //       {
     * //         "id": "rec2",
     * //         "score": 0.004867417272180319,
     * //         "fields": {
     * //           "category": "nutrition",
     * //           "chunk_text": "Apples are a great source of dietary fiber, which supports digestion and helps maintain a healthy gut."
     * //         }
     * //       }
     * //     ]
     * //   },
     * //   "usage": {
     * //     "readUnits": 1,
     * //     "embedTotalTokens": 8,
     * //     "rerankUnits": 1
     * //   }
     * // }
     * ```
     *
     * @param options - The {@link SearchRecordsOptions} for the operation.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns a promise that resolves to {@link SearchRecordsResponse} when the operation is complete.
     */ async searchRecords(options) {
        return await this._searchRecordsCommand.run(options);
    }
    /**
     * Start an asynchronous import of vectors from object storage into a Pinecone Serverless index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.startImport('s3://my-bucket/my-data'));
     *
     * // {"id":"1"}
     * ```
     *
     * @param uri - (Required) The URI prefix under which the data to import is available. All data within this prefix
     * will be listed then imported into the target index. Currently only `s3://` URIs are supported.
     * @param integration - (Optional) The name of the storage integration that should be used to access the data.
     * Defaults to None.
     * @param errorMode - (Optional) Defaults to "Continue". If set to "Continue", the import operation will continue
     * even if some records fail to import. To inspect failures in "Continue" mode, send a request to {@link listImports}. Pass
     * "Abort" to stop the import operation if any records fail to import.
     */ async startImport(uri, errorMode, integration) {
        return await this._startImportCommand.run(uri, errorMode, integration);
    }
    /**
     * List all recent and ongoing import operations.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.listImports());
     *
     * // {
     * //  data: [
     * //    {
     * //      id: '1',
     * //      uri: 's3://dev-bulk-import-datasets-pub/10-records-dim-10',
     * //      status: 'Completed',
     * //      createdAt: 2024-09-17T16:59:57.973Z,
     * //      finishedAt: 2024-09-17T17:00:12.809Z,
     * //      percentComplete: 100,
     * //      recordsImported: 20,
     * //      error: undefined
     * //    }
     * //  ],
     * //  pagination: undefined  // Example is only 1 item, so no pag. token given.
     * // }
     * ```
     *
     * @param limit - (Optional) Max number of import operations to return per page.
     * @param paginationToken - (Optional) Pagination token to continue a previous listing operation.
     */ async listImports(limit, paginationToken) {
        return await this._listImportsCommand.run(limit, paginationToken);
    }
    /**
     * Return details of a specific import operation.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.describeImport('import-id'));
     *
     * // {
     * //  id: '1',
     * //  uri: 's3://dev-bulk-import-datasets-pub/10-records-dim-10',
     * //  status: 'Completed',
     * //  createdAt: 2024-09-17T16:59:57.973Z,
     * //  finishedAt: 2024-09-17T17:00:12.809Z,
     * //  percentComplete: 100,
     * //  recordsImported: 20,
     * //  error: undefined
     * // }
     * ```
     *
     * @param id - The id of the import operation to describe.
     */ async describeImport(id) {
        return await this._describeImportCommand.run(id);
    }
    /**
     * Cancel a specific import operation.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.cancelImport('import-id'));
     *
     * // {}
     * ```
     *
     * @param id - The id of the import operation to cancel.
     */ async cancelImport(id) {
        return await this._cancelImportCommand.run(id);
    }
    /**
     * Returns a list of namespaces within the index.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.listNamespaces(10));
     *
     * // {
     * //   namespaces: [
     * //     { name: 'ns-1', recordCount: '1' },
     * //     { name: 'ns-2', recordCount: '1' }
     * //   ],
     * //   pagination: undefined
     * // }
     * ```
     *
     * @param limit - (Optional) Max number of import operations to return per page.
     * @param paginationToken - (Optional) Pagination token to continue a previous listing operation.
     */ async listNamespaces(limit, paginationToken) {
        return await this._listNamespacesCommand(limit, paginationToken);
    }
    /**
     * Returns the details of a specific namespace.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * console.log(await index.describeNamespace('ns-1'));
     *
     * // { name: 'ns-1', recordCount: '1' }
     * ```
     *
     * @param namespace - The namespace to describe.
     */ async describeNamespace(namespace) {
        return await this._describeNamespaceCommand(namespace);
    }
    /**
     * Deletes a specific namespace from the index, including all records within it.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const index = pc.index('my-serverless-index');
     * await index.deleteNamespace('ns-1');
     * ```
     *
     * @param namespace - The namespace to delete.
     */ async deleteNamespace(namespace) {
        return await this._deleteNamespaceCommand(namespace);
    }
}
exports.Index = Index; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://api.pinecone.io".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/DenseEmbedding.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DenseEmbeddingToJSON = exports.DenseEmbeddingFromJSONTyped = exports.DenseEmbeddingFromJSON = exports.instanceOfDenseEmbedding = void 0;
/**
 * Check if a given object implements the DenseEmbedding interface.
 */ function instanceOfDenseEmbedding(value) {
    let isInstance = true;
    isInstance = isInstance && "values" in value;
    isInstance = isInstance && "vectorType" in value;
    return isInstance;
}
exports.instanceOfDenseEmbedding = instanceOfDenseEmbedding;
function DenseEmbeddingFromJSON(json) {
    return DenseEmbeddingFromJSONTyped(json, false);
}
exports.DenseEmbeddingFromJSON = DenseEmbeddingFromJSON;
function DenseEmbeddingFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'values': json['values'],
        'vectorType': json['vector_type']
    };
}
exports.DenseEmbeddingFromJSONTyped = DenseEmbeddingFromJSONTyped;
function DenseEmbeddingToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'values': value.values,
        'vector_type': value.vectorType
    };
}
exports.DenseEmbeddingToJSON = DenseEmbeddingToJSON; //# sourceMappingURL=DenseEmbedding.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequestInputsInner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbedRequestInputsInnerToJSON = exports.EmbedRequestInputsInnerFromJSONTyped = exports.EmbedRequestInputsInnerFromJSON = exports.instanceOfEmbedRequestInputsInner = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the EmbedRequestInputsInner interface.
 */ function instanceOfEmbedRequestInputsInner(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfEmbedRequestInputsInner = instanceOfEmbedRequestInputsInner;
function EmbedRequestInputsInnerFromJSON(json) {
    return EmbedRequestInputsInnerFromJSONTyped(json, false);
}
exports.EmbedRequestInputsInnerFromJSON = EmbedRequestInputsInnerFromJSON;
function EmbedRequestInputsInnerFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'text': !(0, runtime_1.exists)(json, 'text') ? undefined : json['text']
    };
}
exports.EmbedRequestInputsInnerFromJSONTyped = EmbedRequestInputsInnerFromJSONTyped;
function EmbedRequestInputsInnerToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'text': value.text
    };
}
exports.EmbedRequestInputsInnerToJSON = EmbedRequestInputsInnerToJSON; //# sourceMappingURL=EmbedRequestInputsInner.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbedRequestToJSON = exports.EmbedRequestFromJSONTyped = exports.EmbedRequestFromJSON = exports.instanceOfEmbedRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
const EmbedRequestInputsInner_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequestInputsInner.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the EmbedRequest interface.
 */ function instanceOfEmbedRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "inputs" in value;
    return isInstance;
}
exports.instanceOfEmbedRequest = instanceOfEmbedRequest;
function EmbedRequestFromJSON(json) {
    return EmbedRequestFromJSONTyped(json, false);
}
exports.EmbedRequestFromJSON = EmbedRequestFromJSON;
function EmbedRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'parameters': !(0, runtime_1.exists)(json, 'parameters') ? undefined : json['parameters'],
        'inputs': json['inputs'].map(EmbedRequestInputsInner_1.EmbedRequestInputsInnerFromJSON)
    };
}
exports.EmbedRequestFromJSONTyped = EmbedRequestFromJSONTyped;
function EmbedRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'parameters': value.parameters,
        'inputs': value.inputs.map(EmbedRequestInputsInner_1.EmbedRequestInputsInnerToJSON)
    };
}
exports.EmbedRequestToJSON = EmbedRequestToJSON; //# sourceMappingURL=EmbedRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/SparseEmbedding.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SparseEmbeddingToJSON = exports.SparseEmbeddingFromJSONTyped = exports.SparseEmbeddingFromJSON = exports.instanceOfSparseEmbedding = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the SparseEmbedding interface.
 */ function instanceOfSparseEmbedding(value) {
    let isInstance = true;
    isInstance = isInstance && "sparseValues" in value;
    isInstance = isInstance && "sparseIndices" in value;
    isInstance = isInstance && "vectorType" in value;
    return isInstance;
}
exports.instanceOfSparseEmbedding = instanceOfSparseEmbedding;
function SparseEmbeddingFromJSON(json) {
    return SparseEmbeddingFromJSONTyped(json, false);
}
exports.SparseEmbeddingFromJSON = SparseEmbeddingFromJSON;
function SparseEmbeddingFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'sparseValues': json['sparse_values'],
        'sparseIndices': json['sparse_indices'],
        'sparseTokens': !(0, runtime_1.exists)(json, 'sparse_tokens') ? undefined : json['sparse_tokens'],
        'vectorType': json['vector_type']
    };
}
exports.SparseEmbeddingFromJSONTyped = SparseEmbeddingFromJSONTyped;
function SparseEmbeddingToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'sparse_values': value.sparseValues,
        'sparse_indices': value.sparseIndices,
        'sparse_tokens': value.sparseTokens,
        'vector_type': value.vectorType
    };
}
exports.SparseEmbeddingToJSON = SparseEmbeddingToJSON; //# sourceMappingURL=SparseEmbedding.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/Embedding.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbeddingToJSON = exports.EmbeddingFromJSONTyped = exports.EmbeddingFromJSON = void 0;
const DenseEmbedding_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/DenseEmbedding.js [app-route] (ecmascript)");
const SparseEmbedding_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/SparseEmbedding.js [app-route] (ecmascript)");
function EmbeddingFromJSON(json) {
    return EmbeddingFromJSONTyped(json, false);
}
exports.EmbeddingFromJSON = EmbeddingFromJSON;
function EmbeddingFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    switch(json['vector_type']){
        case 'dense':
            return {
                ...(0, DenseEmbedding_1.DenseEmbeddingFromJSONTyped)(json, true),
                vectorType: 'dense'
            };
        case 'sparse':
            return {
                ...(0, SparseEmbedding_1.SparseEmbeddingFromJSONTyped)(json, true),
                vectorType: 'sparse'
            };
        default:
            throw new Error(`No variant of Embedding exists with 'vectorType=${json['vectorType']}'`);
    }
}
exports.EmbeddingFromJSONTyped = EmbeddingFromJSONTyped;
function EmbeddingToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    switch(value['vectorType']){
        case 'dense':
            return (0, DenseEmbedding_1.DenseEmbeddingToJSON)(value);
        case 'sparse':
            return (0, SparseEmbedding_1.SparseEmbeddingToJSON)(value);
        default:
            throw new Error(`No variant of Embedding exists with 'vectorType=${value['vectorType']}'`);
    }
}
exports.EmbeddingToJSON = EmbeddingToJSON; //# sourceMappingURL=Embedding.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsListUsage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbeddingsListUsageToJSON = exports.EmbeddingsListUsageFromJSONTyped = exports.EmbeddingsListUsageFromJSON = exports.instanceOfEmbeddingsListUsage = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the EmbeddingsListUsage interface.
 */ function instanceOfEmbeddingsListUsage(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfEmbeddingsListUsage = instanceOfEmbeddingsListUsage;
function EmbeddingsListUsageFromJSON(json) {
    return EmbeddingsListUsageFromJSONTyped(json, false);
}
exports.EmbeddingsListUsageFromJSON = EmbeddingsListUsageFromJSON;
function EmbeddingsListUsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'totalTokens': !(0, runtime_1.exists)(json, 'total_tokens') ? undefined : json['total_tokens']
    };
}
exports.EmbeddingsListUsageFromJSONTyped = EmbeddingsListUsageFromJSONTyped;
function EmbeddingsListUsageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'total_tokens': value.totalTokens
    };
}
exports.EmbeddingsListUsageToJSON = EmbeddingsListUsageToJSON; //# sourceMappingURL=EmbeddingsListUsage.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EmbeddingsListToJSON = exports.EmbeddingsListFromJSONTyped = exports.EmbeddingsListFromJSON = exports.instanceOfEmbeddingsList = void 0;
const Embedding_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/Embedding.js [app-route] (ecmascript)");
const EmbeddingsListUsage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsListUsage.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the EmbeddingsList interface.
 */ function instanceOfEmbeddingsList(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "vectorType" in value;
    isInstance = isInstance && "data" in value;
    isInstance = isInstance && "usage" in value;
    return isInstance;
}
exports.instanceOfEmbeddingsList = instanceOfEmbeddingsList;
function EmbeddingsListFromJSON(json) {
    return EmbeddingsListFromJSONTyped(json, false);
}
exports.EmbeddingsListFromJSON = EmbeddingsListFromJSON;
function EmbeddingsListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'vectorType': json['vector_type'],
        'data': json['data'].map(Embedding_1.EmbeddingFromJSON),
        'usage': (0, EmbeddingsListUsage_1.EmbeddingsListUsageFromJSON)(json['usage'])
    };
}
exports.EmbeddingsListFromJSONTyped = EmbeddingsListFromJSONTyped;
function EmbeddingsListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'vector_type': value.vectorType,
        'data': value.data.map(Embedding_1.EmbeddingToJSON),
        'usage': (0, EmbeddingsListUsage_1.EmbeddingsListUsageToJSON)(value.usage)
    };
}
exports.EmbeddingsListToJSON = EmbeddingsListToJSON; //# sourceMappingURL=EmbeddingsList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponseError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ErrorResponseErrorCodeEnum = {
    Ok: 'OK',
    Unknown: 'UNKNOWN',
    InvalidArgument: 'INVALID_ARGUMENT',
    DeadlineExceeded: 'DEADLINE_EXCEEDED',
    QuotaExceeded: 'QUOTA_EXCEEDED',
    NotFound: 'NOT_FOUND',
    AlreadyExists: 'ALREADY_EXISTS',
    PermissionDenied: 'PERMISSION_DENIED',
    Unauthenticated: 'UNAUTHENTICATED',
    ResourceExhausted: 'RESOURCE_EXHAUSTED',
    FailedPrecondition: 'FAILED_PRECONDITION',
    Aborted: 'ABORTED',
    OutOfRange: 'OUT_OF_RANGE',
    Unimplemented: 'UNIMPLEMENTED',
    Internal: 'INTERNAL',
    Unavailable: 'UNAVAILABLE',
    DataLoss: 'DATA_LOSS',
    Forbidden: 'FORBIDDEN'
};
/**
 * Check if a given object implements the ErrorResponseError interface.
 */ function instanceOfErrorResponseError(value) {
    let isInstance = true;
    isInstance = isInstance && "code" in value;
    isInstance = isInstance && "message" in value;
    return isInstance;
}
exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
}
exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'code': json['code'],
        'message': json['message'],
        'details': !(0, runtime_1.exists)(json, 'details') ? undefined : json['details']
    };
}
exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
function ErrorResponseErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
        'details': value.details
    };
}
exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON; //# sourceMappingURL=ErrorResponseError.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = void 0;
const ErrorResponseError_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponseError.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ErrorResponse interface.
 */ function instanceOfErrorResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "error" in value;
    return isInstance;
}
exports.instanceOfErrorResponse = instanceOfErrorResponse;
function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
}
exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'status': json['status'],
        'error': (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json['error'])
    };
}
exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
function ErrorResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status': value.status,
        'error': (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value.error)
    };
}
exports.ErrorResponseToJSON = ErrorResponseToJSON; //# sourceMappingURL=ErrorResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoMetric.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoMetricToJSON = exports.ModelInfoMetricFromJSONTyped = exports.ModelInfoMetricFromJSON = exports.ModelInfoMetric = void 0;
/**
 * A distance metric that the embedding model supports for similarity searches.
 * @export
 */ exports.ModelInfoMetric = {
    Cosine: 'cosine',
    Euclidean: 'euclidean',
    Dotproduct: 'dotproduct'
};
function ModelInfoMetricFromJSON(json) {
    return ModelInfoMetricFromJSONTyped(json, false);
}
exports.ModelInfoMetricFromJSON = ModelInfoMetricFromJSON;
function ModelInfoMetricFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.ModelInfoMetricFromJSONTyped = ModelInfoMetricFromJSONTyped;
function ModelInfoMetricToJSON(value) {
    return value;
}
exports.ModelInfoMetricToJSON = ModelInfoMetricToJSON; //# sourceMappingURL=ModelInfoMetric.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterAllowedValuesInner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoSupportedParameterAllowedValuesInnerToJSON = exports.ModelInfoSupportedParameterAllowedValuesInnerFromJSONTyped = exports.ModelInfoSupportedParameterAllowedValuesInnerFromJSON = exports.instanceOfModelInfoSupportedParameterAllowedValuesInner = void 0;
/**
 * Check if a given object implements the ModelInfoSupportedParameterAllowedValuesInner interface.
 */ function instanceOfModelInfoSupportedParameterAllowedValuesInner(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfModelInfoSupportedParameterAllowedValuesInner = instanceOfModelInfoSupportedParameterAllowedValuesInner;
function ModelInfoSupportedParameterAllowedValuesInnerFromJSON(json) {
    return ModelInfoSupportedParameterAllowedValuesInnerFromJSONTyped(json, false);
}
exports.ModelInfoSupportedParameterAllowedValuesInnerFromJSON = ModelInfoSupportedParameterAllowedValuesInnerFromJSON;
function ModelInfoSupportedParameterAllowedValuesInnerFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.ModelInfoSupportedParameterAllowedValuesInnerFromJSONTyped = ModelInfoSupportedParameterAllowedValuesInnerFromJSONTyped;
function ModelInfoSupportedParameterAllowedValuesInnerToJSON(value) {
    return value;
}
exports.ModelInfoSupportedParameterAllowedValuesInnerToJSON = ModelInfoSupportedParameterAllowedValuesInnerToJSON; //# sourceMappingURL=ModelInfoSupportedParameterAllowedValuesInner.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterDefault.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoSupportedParameterDefaultToJSON = exports.ModelInfoSupportedParameterDefaultFromJSONTyped = exports.ModelInfoSupportedParameterDefaultFromJSON = exports.instanceOfModelInfoSupportedParameterDefault = void 0;
/**
 * Check if a given object implements the ModelInfoSupportedParameterDefault interface.
 */ function instanceOfModelInfoSupportedParameterDefault(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfModelInfoSupportedParameterDefault = instanceOfModelInfoSupportedParameterDefault;
function ModelInfoSupportedParameterDefaultFromJSON(json) {
    return ModelInfoSupportedParameterDefaultFromJSONTyped(json, false);
}
exports.ModelInfoSupportedParameterDefaultFromJSON = ModelInfoSupportedParameterDefaultFromJSON;
function ModelInfoSupportedParameterDefaultFromJSONTyped(json, ignoreDiscriminator) {
    return json;
}
exports.ModelInfoSupportedParameterDefaultFromJSONTyped = ModelInfoSupportedParameterDefaultFromJSONTyped;
function ModelInfoSupportedParameterDefaultToJSON(value) {
    return value;
}
exports.ModelInfoSupportedParameterDefaultToJSON = ModelInfoSupportedParameterDefaultToJSON; //# sourceMappingURL=ModelInfoSupportedParameterDefault.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoSupportedParameterToJSON = exports.ModelInfoSupportedParameterFromJSONTyped = exports.ModelInfoSupportedParameterFromJSON = exports.instanceOfModelInfoSupportedParameter = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
const ModelInfoSupportedParameterAllowedValuesInner_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterAllowedValuesInner.js [app-route] (ecmascript)");
const ModelInfoSupportedParameterDefault_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterDefault.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ModelInfoSupportedParameter interface.
 */ function instanceOfModelInfoSupportedParameter(value) {
    let isInstance = true;
    isInstance = isInstance && "parameter" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "valueType" in value;
    isInstance = isInstance && "required" in value;
    return isInstance;
}
exports.instanceOfModelInfoSupportedParameter = instanceOfModelInfoSupportedParameter;
function ModelInfoSupportedParameterFromJSON(json) {
    return ModelInfoSupportedParameterFromJSONTyped(json, false);
}
exports.ModelInfoSupportedParameterFromJSON = ModelInfoSupportedParameterFromJSON;
function ModelInfoSupportedParameterFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'parameter': json['parameter'],
        'type': json['type'],
        'valueType': json['value_type'],
        'required': json['required'],
        'allowedValues': !(0, runtime_1.exists)(json, 'allowed_values') ? undefined : json['allowed_values'].map(ModelInfoSupportedParameterAllowedValuesInner_1.ModelInfoSupportedParameterAllowedValuesInnerFromJSON),
        'min': !(0, runtime_1.exists)(json, 'min') ? undefined : json['min'],
        'max': !(0, runtime_1.exists)(json, 'max') ? undefined : json['max'],
        '_default': !(0, runtime_1.exists)(json, 'default') ? undefined : (0, ModelInfoSupportedParameterDefault_1.ModelInfoSupportedParameterDefaultFromJSON)(json['default'])
    };
}
exports.ModelInfoSupportedParameterFromJSONTyped = ModelInfoSupportedParameterFromJSONTyped;
function ModelInfoSupportedParameterToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'parameter': value.parameter,
        'type': value.type,
        'value_type': value.valueType,
        'required': value.required,
        'allowed_values': value.allowedValues === undefined ? undefined : value.allowedValues.map(ModelInfoSupportedParameterAllowedValuesInner_1.ModelInfoSupportedParameterAllowedValuesInnerToJSON),
        'min': value.min,
        'max': value.max,
        'default': (0, ModelInfoSupportedParameterDefault_1.ModelInfoSupportedParameterDefaultToJSON)(value._default)
    };
}
exports.ModelInfoSupportedParameterToJSON = ModelInfoSupportedParameterToJSON; //# sourceMappingURL=ModelInfoSupportedParameter.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfo.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoToJSON = exports.ModelInfoFromJSONTyped = exports.ModelInfoFromJSON = exports.instanceOfModelInfo = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
const ModelInfoMetric_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoMetric.js [app-route] (ecmascript)");
const ModelInfoSupportedParameter_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameter.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ModelInfo interface.
 */ function instanceOfModelInfo(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "shortDescription" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "supportedParameters" in value;
    return isInstance;
}
exports.instanceOfModelInfo = instanceOfModelInfo;
function ModelInfoFromJSON(json) {
    return ModelInfoFromJSONTyped(json, false);
}
exports.ModelInfoFromJSON = ModelInfoFromJSON;
function ModelInfoFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'shortDescription': json['short_description'],
        'type': json['type'],
        'vectorType': !(0, runtime_1.exists)(json, 'vector_type') ? undefined : json['vector_type'],
        'defaultDimension': !(0, runtime_1.exists)(json, 'default_dimension') ? undefined : json['default_dimension'],
        'modality': !(0, runtime_1.exists)(json, 'modality') ? undefined : json['modality'],
        'maxSequenceLength': !(0, runtime_1.exists)(json, 'max_sequence_length') ? undefined : json['max_sequence_length'],
        'maxBatchSize': !(0, runtime_1.exists)(json, 'max_batch_size') ? undefined : json['max_batch_size'],
        'providerName': !(0, runtime_1.exists)(json, 'provider_name') ? undefined : json['provider_name'],
        'supportedDimensions': !(0, runtime_1.exists)(json, 'supported_dimensions') ? undefined : json['supported_dimensions'],
        'supportedMetrics': !(0, runtime_1.exists)(json, 'supported_metrics') ? undefined : json['supported_metrics'].map(ModelInfoMetric_1.ModelInfoMetricFromJSON),
        'supportedParameters': json['supported_parameters'].map(ModelInfoSupportedParameter_1.ModelInfoSupportedParameterFromJSON)
    };
}
exports.ModelInfoFromJSONTyped = ModelInfoFromJSONTyped;
function ModelInfoToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'short_description': value.shortDescription,
        'type': value.type,
        'vector_type': value.vectorType,
        'default_dimension': value.defaultDimension,
        'modality': value.modality,
        'max_sequence_length': value.maxSequenceLength,
        'max_batch_size': value.maxBatchSize,
        'provider_name': value.providerName,
        'supported_dimensions': value.supportedDimensions,
        'supported_metrics': value.supportedMetrics === undefined ? undefined : value.supportedMetrics.map(ModelInfoMetric_1.ModelInfoMetricToJSON),
        'supported_parameters': value.supportedParameters.map(ModelInfoSupportedParameter_1.ModelInfoSupportedParameterToJSON)
    };
}
exports.ModelInfoToJSON = ModelInfoToJSON; //# sourceMappingURL=ModelInfo.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoList.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModelInfoListToJSON = exports.ModelInfoListFromJSONTyped = exports.ModelInfoListFromJSON = exports.instanceOfModelInfoList = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
const ModelInfo_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfo.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ModelInfoList interface.
 */ function instanceOfModelInfoList(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfModelInfoList = instanceOfModelInfoList;
function ModelInfoListFromJSON(json) {
    return ModelInfoListFromJSONTyped(json, false);
}
exports.ModelInfoListFromJSON = ModelInfoListFromJSON;
function ModelInfoListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'models': !(0, runtime_1.exists)(json, 'models') ? undefined : json['models'].map(ModelInfo_1.ModelInfoFromJSON)
    };
}
exports.ModelInfoListFromJSONTyped = ModelInfoListFromJSONTyped;
function ModelInfoListToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'models': value.models === undefined ? undefined : value.models.map(ModelInfo_1.ModelInfoToJSON)
    };
}
exports.ModelInfoListToJSON = ModelInfoListToJSON; //# sourceMappingURL=ModelInfoList.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RankedDocument.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RankedDocumentToJSON = exports.RankedDocumentFromJSONTyped = exports.RankedDocumentFromJSON = exports.instanceOfRankedDocument = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RankedDocument interface.
 */ function instanceOfRankedDocument(value) {
    let isInstance = true;
    isInstance = isInstance && "index" in value;
    isInstance = isInstance && "score" in value;
    return isInstance;
}
exports.instanceOfRankedDocument = instanceOfRankedDocument;
function RankedDocumentFromJSON(json) {
    return RankedDocumentFromJSONTyped(json, false);
}
exports.RankedDocumentFromJSON = RankedDocumentFromJSON;
function RankedDocumentFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'index': json['index'],
        'score': json['score'],
        'document': !(0, runtime_1.exists)(json, 'document') ? undefined : json['document']
    };
}
exports.RankedDocumentFromJSONTyped = RankedDocumentFromJSONTyped;
function RankedDocumentToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'index': value.index,
        'score': value.score,
        'document': value.document
    };
}
exports.RankedDocumentToJSON = RankedDocumentToJSON; //# sourceMappingURL=RankedDocument.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RerankRequestToJSON = exports.RerankRequestFromJSONTyped = exports.RerankRequestFromJSON = exports.instanceOfRerankRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RerankRequest interface.
 */ function instanceOfRerankRequest(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "query" in value;
    isInstance = isInstance && "documents" in value;
    return isInstance;
}
exports.instanceOfRerankRequest = instanceOfRerankRequest;
function RerankRequestFromJSON(json) {
    return RerankRequestFromJSONTyped(json, false);
}
exports.RerankRequestFromJSON = RerankRequestFromJSON;
function RerankRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'query': json['query'],
        'topN': !(0, runtime_1.exists)(json, 'top_n') ? undefined : json['top_n'],
        'returnDocuments': !(0, runtime_1.exists)(json, 'return_documents') ? undefined : json['return_documents'],
        'rankFields': !(0, runtime_1.exists)(json, 'rank_fields') ? undefined : json['rank_fields'],
        'documents': json['documents'],
        'parameters': !(0, runtime_1.exists)(json, 'parameters') ? undefined : json['parameters']
    };
}
exports.RerankRequestFromJSONTyped = RerankRequestFromJSONTyped;
function RerankRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'query': value.query,
        'top_n': value.topN,
        'return_documents': value.returnDocuments,
        'rank_fields': value.rankFields,
        'documents': value.documents,
        'parameters': value.parameters
    };
}
exports.RerankRequestToJSON = RerankRequestToJSON; //# sourceMappingURL=RerankRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResultUsage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RerankResultUsageToJSON = exports.RerankResultUsageFromJSONTyped = exports.RerankResultUsageFromJSON = exports.instanceOfRerankResultUsage = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RerankResultUsage interface.
 */ function instanceOfRerankResultUsage(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfRerankResultUsage = instanceOfRerankResultUsage;
function RerankResultUsageFromJSON(json) {
    return RerankResultUsageFromJSONTyped(json, false);
}
exports.RerankResultUsageFromJSON = RerankResultUsageFromJSON;
function RerankResultUsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'rerankUnits': !(0, runtime_1.exists)(json, 'rerank_units') ? undefined : json['rerank_units']
    };
}
exports.RerankResultUsageFromJSONTyped = RerankResultUsageFromJSONTyped;
function RerankResultUsageToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'rerank_units': value.rerankUnits
    };
}
exports.RerankResultUsageToJSON = RerankResultUsageToJSON; //# sourceMappingURL=RerankResultUsage.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RerankResultToJSON = exports.RerankResultFromJSONTyped = exports.RerankResultFromJSON = exports.instanceOfRerankResult = void 0;
const RankedDocument_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RankedDocument.js [app-route] (ecmascript)");
const RerankResultUsage_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResultUsage.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the RerankResult interface.
 */ function instanceOfRerankResult(value) {
    let isInstance = true;
    isInstance = isInstance && "model" in value;
    isInstance = isInstance && "data" in value;
    isInstance = isInstance && "usage" in value;
    return isInstance;
}
exports.instanceOfRerankResult = instanceOfRerankResult;
function RerankResultFromJSON(json) {
    return RerankResultFromJSONTyped(json, false);
}
exports.RerankResultFromJSON = RerankResultFromJSON;
function RerankResultFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'model': json['model'],
        'data': json['data'].map(RankedDocument_1.RankedDocumentFromJSON),
        'usage': (0, RerankResultUsage_1.RerankResultUsageFromJSON)(json['usage'])
    };
}
exports.RerankResultFromJSONTyped = RerankResultFromJSONTyped;
function RerankResultToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'model': value.model,
        'data': value.data.map(RankedDocument_1.RankedDocumentToJSON),
        'usage': (0, RerankResultUsage_1.RerankResultUsageToJSON)(value.usage)
    };
}
exports.RerankResultToJSON = RerankResultToJSON; //# sourceMappingURL=RerankResult.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/DenseEmbedding.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequestInputsInner.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/Embedding.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsListUsage.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponseError.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfo.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoList.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoMetric.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameter.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterAllowedValuesInner.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ModelInfoSupportedParameterDefault.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RankedDocument.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResult.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResultUsage.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/SparseEmbedding.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/InferenceApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Inference API
 * Pinecone is a vector database that makes it easy to search and retrieve billions of high-dimensional vectors.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InferenceApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class InferenceApi extends runtime.BaseAPI {
    /**
     * Generate vector embeddings for input data. This endpoint uses Pinecone\'s [hosted embedding models](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models).
     * Generate vectors
     */ async embedRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/embed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.EmbedRequestToJSON)(requestParameters.embedRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.EmbeddingsListFromJSON)(jsonValue));
    }
    /**
     * Generate vector embeddings for input data. This endpoint uses Pinecone\'s [hosted embedding models](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models).
     * Generate vectors
     */ async embed(requestParameters = {}, initOverrides) {
        const response = await this.embedRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Get a description of a model hosted by Pinecone.   You can use hosted models as an integrated part of Pinecone operations or for standalone embedding and reranking. For more details, see [Vector embedding](https://docs.pinecone.io/guides/index-data/indexing-overview#vector-embedding) and [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * Describe a model
     */ async getModelRaw(requestParameters, initOverrides) {
        if (requestParameters.modelName === null || requestParameters.modelName === undefined) {
            throw new runtime.RequiredError('modelName', 'Required parameter requestParameters.modelName was null or undefined when calling getModel.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/models/{model_name}`.replace(`{${"model_name"}}`, encodeURIComponent(String(requestParameters.modelName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ModelInfoFromJSON)(jsonValue));
    }
    /**
     * Get a description of a model hosted by Pinecone.   You can use hosted models as an integrated part of Pinecone operations or for standalone embedding and reranking. For more details, see [Vector embedding](https://docs.pinecone.io/guides/index-data/indexing-overview#vector-embedding) and [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * Describe a model
     */ async getModel(requestParameters, initOverrides) {
        const response = await this.getModelRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List the embedding and reranking models hosted by Pinecone.   You can use hosted models as an integrated part of Pinecone operations or for standalone embedding and reranking. For more details, see [Vector embedding](https://docs.pinecone.io/guides/index-data/indexing-overview#vector-embedding) and [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * List available models
     */ async listModelsRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }
        if (requestParameters.vectorType !== undefined) {
            queryParameters['vector_type'] = requestParameters.vectorType;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/models`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ModelInfoListFromJSON)(jsonValue));
    }
    /**
     * List the embedding and reranking models hosted by Pinecone.   You can use hosted models as an integrated part of Pinecone operations or for standalone embedding and reranking. For more details, see [Vector embedding](https://docs.pinecone.io/guides/index-data/indexing-overview#vector-embedding) and [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * List available models
     */ async listModels(requestParameters = {}, initOverrides) {
        const response = await this.listModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Rerank results according to their relevance to a query.  For guidance and examples, see [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * Rerank documents
     */ async rerankRaw(requestParameters, initOverrides) {
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/rerank`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.RerankRequestToJSON)(requestParameters.rerankRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.RerankResultFromJSON)(jsonValue));
    }
    /**
     * Rerank results according to their relevance to a query.  For guidance and examples, see [Rerank results](https://docs.pinecone.io/guides/search/rerank-results).
     * Rerank documents
     */ async rerank(requestParameters = {}, initOverrides) {
        const response = await this.rerankRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.InferenceApi = InferenceApi; //# sourceMappingURL=InferenceApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/InferenceApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/inferenceOperationsBuilder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.inferenceOperationsBuilder = void 0;
const inference_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
const inferenceOperationsBuilder = (config)=>{
    const { apiKey } = config;
    const controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || 'https://api.pinecone.io';
    const headers = config.additionalHeaders || null;
    const apiConfig = {
        basePath: controllerPath,
        apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: {
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': inference_1.X_PINECONE_API_VERSION,
            ...headers
        },
        fetchApi: (0, utils_1.getFetch)(config),
        middleware: middleware_1.middleware
    };
    return new inference_1.InferenceApi(new inference_1.Configuration(apiConfig));
};
exports.inferenceOperationsBuilder = inferenceOperationsBuilder; //# sourceMappingURL=inferenceOperationsBuilder.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/embed.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.embed = void 0;
const embed = (infApi)=>{
    return async (model, inputs, params)=>{
        const typedAndFormattedInputs = inputs.map((str)=>{
            return {
                text: str
            };
        });
        if (params && params.inputType) {
            // Rename `inputType` to `input_type`
            params.input_type = params.inputType;
            delete params.inputType;
        }
        const typedRequest = {
            embedRequest: {
                model: model,
                inputs: typedAndFormattedInputs,
                parameters: params
            }
        };
        return await infApi.embed(typedRequest);
    };
};
exports.embed = embed; //# sourceMappingURL=embed.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/rerank.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rerank = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const rerank = (infApi)=>{
    return async (model, query, documents, options = {})=>{
        if (documents.length == 0) {
            throw new errors_1.PineconeArgumentError('You must pass at least one document to rerank');
        }
        if (query.length == 0) {
            throw new errors_1.PineconeArgumentError('You must pass a query to rerank');
        }
        if (model.length == 0) {
            throw new errors_1.PineconeArgumentError('You must pass the name of a supported reranking model in order to rerank' + ' documents. See https://docs.pinecone.io/models for supported models.');
        }
        const { topN = documents.length, returnDocuments = true, parameters = {} } = options;
        let { rankFields = [
            'text'
        ] } = options;
        // Validate and standardize documents to ensure they are in object format
        const newDocuments = documents.map((doc)=>typeof doc === 'string' ? {
                text: doc
            } : doc);
        if (!options.rankFields) {
            if (!newDocuments.every((doc)=>typeof doc === 'object' && doc.text)) {
                throw new errors_1.PineconeArgumentError('Documents must be a list of strings or objects containing the "text" field');
            }
        }
        if (options.rankFields) {
            rankFields = options.rankFields;
        }
        const req = {
            rerankRequest: {
                model: model,
                query: query,
                documents: newDocuments,
                topN: topN,
                returnDocuments: returnDocuments,
                rankFields: rankFields,
                parameters: parameters
            }
        };
        return await infApi.rerank(req);
    };
};
exports.rerank = rerank; //# sourceMappingURL=rerank.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/getModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getModel = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const getModel = (infApi)=>{
    return async (modelName)=>{
        if (!modelName) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `modelName` in order to get a model');
        }
        return await infApi.getModel({
            modelName
        });
    };
};
exports.getModel = getModel; //# sourceMappingURL=getModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/listModels.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listModels = void 0;
const listModels = (infApi)=>{
    return async (options)=>{
        return await infApi.listModels(options);
    };
};
exports.listModels = listModels; //# sourceMappingURL=listModels.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/inference.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Inference = void 0;
const inferenceOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/inferenceOperationsBuilder.js [app-route] (ecmascript)");
const embed_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/embed.js [app-route] (ecmascript)");
const rerank_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/rerank.js [app-route] (ecmascript)");
const getModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/getModel.js [app-route] (ecmascript)");
const listModels_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/listModels.js [app-route] (ecmascript)");
/* The Inference class uses the Inference API to generate embeddings, rerank documents, and work with models.  */ class Inference {
    constructor(config){
        this.config = config;
        const inferenceApi = (0, inferenceOperationsBuilder_1.inferenceOperationsBuilder)(this.config);
        this._embed = (0, embed_1.embed)(inferenceApi);
        this._rerank = (0, rerank_1.rerank)(inferenceApi);
        this._listModels = (0, listModels_1.listModels)(inferenceApi);
        this._getModel = (0, getModel_1.getModel)(inferenceApi);
    }
    /**
     * Generates embeddings for the provided inputs using the specified model and (optional) parameters.
     *
     * @example
     * ````typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const inputs = ['Who created the first computer?'];
     * const model = 'multilingual-e5-large';
     * const parameters = {
     *   inputType: 'passage',
     *   truncate: 'END',
     * };
     * const embeddings = await pc.inference.embed(model, inputs, parameters);
     * console.log(embeddings);
     * // {
     * //   model: 'multilingual-e5-large',
     * //   vectorType: 'dense',
     * //   data: [ { values: [Array], vectorType: 'dense' } ],
     * //   usage: { totalTokens: 10 }
     * // }
     * ```
     *
     * @param model - The model to use for generating embeddings.
     * @param inputs - A list of items to generate embeddings for.
     * @param params - A dictionary of parameters to use when generating embeddings.
     * @returns A promise that resolves to {@link EmbeddingsList}.
     * */ embed(model, inputs, params) {
        return this._embed(model, inputs, params);
    }
    /**
     * Rerank documents against a query with a reranking model. Each document is ranked in descending relevance order
     * against the query provided.
     *
     * @example
     * ````typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const rerankingModel = 'bge-reranker-v2-m3';
     * const myQuery = 'What are some good Turkey dishes for Thanksgiving?';
     *
     * // Option 1: Documents as an array of strings
     * const myDocsStrings = [
     *   'I love turkey sandwiches with pastrami',
     *   'A lemon brined Turkey with apple sausage stuffing is a classic Thanksgiving main',
     *   'My favorite Thanksgiving dish is pumpkin pie',
     *   'Turkey is a great source of protein',
     * ];
     *
     * // Option 1 response
     * const response = await pc.inference.rerank(
     *   rerankingModel,
     *   myQuery,
     *   myDocsStrings
     * );
     * console.log(response);
     * // {
     * // model: 'bge-reranker-v2-m3',
     * // data: [
     * //   { index: 1, score: 0.5633179, document: [Object] },
     * //   { index: 2, score: 0.02013874, document: [Object] },
     * //   { index: 3, score: 0.00035419367, document: [Object] },
     * //   { index: 0, score: 0.00021485926, document: [Object] }
     * // ],
     * // usage: { rerankUnits: 1 }
     * // }
     *
     * // Option 2: Documents as an array of objects
     * const myDocsObjs = [
     *   {
     *     title: 'Turkey Sandwiches',
     *     body: 'I love turkey sandwiches with pastrami',
     *   },
     *   {
     *     title: 'Lemon Turkey',
     *     body: 'A lemon brined Turkey with apple sausage stuffing is a classic Thanksgiving main',
     *   },
     *   {
     *     title: 'Thanksgiving',
     *     body: 'My favorite Thanksgiving dish is pumpkin pie',
     *   },
     *   { title: 'Protein Sources', body: 'Turkey is a great source of protein' },
     * ];
     *
     * // Option 2: Options object declaring which custom key to rerank on
     * // Note: If no custom key is passed via `rankFields`, each doc must contain a `text` key, and that will act as the default)
     * const rerankOptions = {
     *   topN: 3,
     *   returnDocuments: false,
     *   rankFields: ['body'],
     *   parameters: {
     *     inputType: 'passage',
     *     truncate: 'END',
     *   },
     * };
     *
     * // Option 2 response
     * const response = await pc.inference.rerank(
     *   rerankingModel,
     *   myQuery,
     *   myDocsObjs,
     *   rerankOptions
     * );
     * console.log(response);
     * // {
     * // model: 'bge-reranker-v2-m3',
     * // data: [
     * //   { index: 1, score: 0.5633179, document: undefined },
     * //   { index: 2, score: 0.02013874, document: undefined },
     * //   { index: 3, score: 0.00035419367, document: undefined },
     * // ],
     * // usage: { rerankUnits: 1 }
     * //}
     * ```
     *
     * @param model - (Required) The model to use for reranking. Currently, the only available model is "[bge-reranker-v2-m3](https://docs.pinecone.io/models/bge-reranker-v2-m3)"}.
     * @param query - (Required) The query to rerank documents against.
     * @param documents - (Required) An array of documents to rerank. The array can either be an array of strings or
     * an array of objects.
     * @param options - (Optional) Additional options to send with the reranking request. See {@link RerankOptions} for more details.
     * */ async rerank(model, query, documents, options) {
        return this._rerank(model, query, documents, options);
    }
    /**
     * List available models hosted by Pinecone.
     *
     * @example
     * ````typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const models = await pc.inference.listModels();
     * console.log(models);
     * // {
     * //   models: [
     * //     {
     * //       model: 'llama-text-embed-v2',
     * //       shortDescription: 'A high performance dense embedding model optimized for multilingual and cross-lingual text question-answering retrieval with support for long documents (up to 2048 tokens) and dynamic embedding size (Matryoshka Embeddings).',
     * //       type: 'embed',
     * //       vectorType: 'dense',
     * //       defaultDimension: 1024,
     * //       modality: 'text',
     * //       maxSequenceLength: 2048,
     * //       maxBatchSize: 96,
     * //       providerName: 'NVIDIA',
     * //       supportedDimensions: [Array],
     * //       supportedMetrics: [Array],
     * //       supportedParameters: [Array]
     * //     },
     * //     ...
     * //     {
     * //       model: 'pinecone-rerank-v0',
     * //       shortDescription: 'A state of the art reranking model that out-performs competitors on widely accepted benchmarks. It can handle chunks up to 512 tokens (1-2 paragraphs)',
     * //       type: 'rerank',
     * //       vectorType: undefined,
     * //       defaultDimension: undefined,
     * //       modality: 'text',
     * //       maxSequenceLength: 512,
     * //       maxBatchSize: 100,
     * //       providerName: 'Pinecone',
     * //       supportedDimensions: undefined,
     * //       supportedMetrics: undefined,
     * //       supportedParameters: [Array]
     * //     }
     * //   ]
     * // }
     * ```
     *
     * @param options - (Optional) A {@link ListModelsOptions} object to filter the models returned.
     * @returns A promise that resolves to {@link ModelInfoList}.
     * */ async listModels(options) {
        return this._listModels(options);
    }
    /**
     * Get the information for a model hosted by Pinecone.
     *
     * @example
     * ````typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const model = await pc.inference.getModel('pinecone-sparse-english-v0');
     * console.log(model);
     * // {
     * //   model: 'pinecone-sparse-english-v0',
     * //   shortDescription: 'A sparse embedding model for converting text to sparse vectors for keyword or hybrid semantic/keyword search. Built on the innovations of the DeepImpact architecture.',
     * //   type: 'embed',
     * //   vectorType: 'sparse',
     * //   defaultDimension: undefined,
     * //   modality: 'text',
     * //   maxSequenceLength: 512,
     * //   maxBatchSize: 96,
     * //   providerName: 'Pinecone',
     * //   supportedDimensions: undefined,
     * //   supportedMetrics: [ 'DotProduct' ],
     * //   supportedParameters: [
     * //     {
     * //       parameter: 'input_type',
     * //       type: 'one_of',
     * //       valueType: 'string',
     * //       required: true,
     * //       allowedValues: [Array],
     * //       min: undefined,
     * //       max: undefined,
     * //       _default: undefined
     * //     },
     * //     {
     * //       parameter: 'truncate',
     * //       type: 'one_of',
     * //       valueType: 'string',
     * //       required: false,
     * //       allowedValues: [Array],
     * //       min: undefined,
     * //       max: undefined,
     * //       _default: 'END'
     * //     },
     * //     {
     * //       parameter: 'return_tokens',
     * //       type: 'any',
     * //       valueType: 'boolean',
     * //       required: false,
     * //       allowedValues: undefined,
     * //       min: undefined,
     * //       max: undefined,
     * //       _default: false
     * //     }
     * //   ]
     * // }
     * ```
     *
     * @param modelName - The model name you would like to describe.
     * @returns A promise that resolves to {@link ModelInfo}.
     * */ async getModel(modelName) {
        return this._getModel(modelName);
    }
}
exports.Inference = Inference; //# sourceMappingURL=inference.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/inference/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listModels = exports.getModel = exports.rerank = exports.embed = exports.inferenceOperationsBuilder = exports.Inference = void 0;
var inference_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/inference.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Inference", {
    enumerable: true,
    get: function() {
        return inference_1.Inference;
    }
});
var inferenceOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/inferenceOperationsBuilder.js [app-route] (ecmascript)");
Object.defineProperty(exports, "inferenceOperationsBuilder", {
    enumerable: true,
    get: function() {
        return inferenceOperationsBuilder_1.inferenceOperationsBuilder;
    }
});
var embed_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/embed.js [app-route] (ecmascript)");
Object.defineProperty(exports, "embed", {
    enumerable: true,
    get: function() {
        return embed_1.embed;
    }
});
var rerank_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/rerank.js [app-route] (ecmascript)");
Object.defineProperty(exports, "rerank", {
    enumerable: true,
    get: function() {
        return rerank_1.rerank;
    }
});
var getModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/getModel.js [app-route] (ecmascript)");
Object.defineProperty(exports, "getModel", {
    enumerable: true,
    get: function() {
        return getModel_1.getModel;
    }
});
var listModels_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/listModels.js [app-route] (ecmascript)");
Object.defineProperty(exports, "listModels", {
    enumerable: true,
    get: function() {
        return listModels_1.listModels;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = void 0;
exports.BASE_PATH = "https://unknown".replace(/\/+$/, "");
class Configuration {
    constructor(configuration = {}){
        this.configuration = configuration;
    }
    set config(configuration) {
        this.configuration = configuration;
    }
    get basePath() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
    }
    get fetchApi() {
        return this.configuration.fetchApi;
    }
    get middleware() {
        return this.configuration.middleware || [];
    }
    get queryParamsStringify() {
        return this.configuration.queryParamsStringify || querystring;
    }
    get username() {
        return this.configuration.username;
    }
    get password() {
        return this.configuration.password;
    }
    get apiKey() {
        const apiKey = this.configuration.apiKey;
        if (apiKey) {
            return typeof apiKey === 'function' ? apiKey : ()=>apiKey;
        }
        return undefined;
    }
    get accessToken() {
        const accessToken = this.configuration.accessToken;
        if (accessToken) {
            return typeof accessToken === 'function' ? accessToken : async ()=>accessToken;
        }
        return undefined;
    }
    get headers() {
        return this.configuration.headers;
    }
    get credentials() {
        return this.configuration.credentials;
    }
}
exports.Configuration = Configuration;
exports.DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */ class BaseAPI {
    constructor(configuration = exports.DefaultConfig){
        this.configuration = configuration;
        this.fetchApi = async (url, init)=>{
            let fetchParams = {
                url,
                init
            };
            for (const middleware of this.middleware){
                if (middleware.pre) {
                    fetchParams = await middleware.pre({
                        fetch: this.fetchApi,
                        ...fetchParams
                    }) || fetchParams;
                }
            }
            let response = undefined;
            try {
                response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
            } catch (e) {
                for (const middleware of this.middleware){
                    if (middleware.onError) {
                        response = await middleware.onError({
                            fetch: this.fetchApi,
                            url: fetchParams.url,
                            init: fetchParams.init,
                            error: e,
                            response: response ? response.clone() : undefined
                        }) || response;
                    }
                }
                if (response === undefined) {
                    if (e instanceof Error) {
                        throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');
                    } else {
                        throw e;
                    }
                }
            }
            for (const middleware of this.middleware){
                if (middleware.post) {
                    response = await middleware.post({
                        fetch: this.fetchApi,
                        url: fetchParams.url,
                        init: fetchParams.init,
                        response: response.clone()
                    }) || response;
                }
            }
            return response;
        };
        this.middleware = configuration.middleware;
    }
    withMiddleware(...middlewares) {
        const next = this.clone();
        next.middleware = next.middleware.concat(...middlewares);
        return next;
    }
    withPreMiddleware(...preMiddlewares) {
        const middlewares = preMiddlewares.map((pre)=>({
                pre
            }));
        return this.withMiddleware(...middlewares);
    }
    withPostMiddleware(...postMiddlewares) {
        const middlewares = postMiddlewares.map((post)=>({
                post
            }));
        return this.withMiddleware(...middlewares);
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context, initOverrides) {
        const { url, init } = await this.createFetchParams(context, initOverrides);
        const response = await this.fetchApi(url, init);
        if (response && response.status >= 200 && response.status < 300) {
            return response;
        }
        throw new ResponseError(response, 'Response returned an error code');
    }
    async createFetchParams(context, initOverrides) {
        let url = this.configuration.basePath + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            // this is done to avoid urls ending with a "?" character which buggy webservers
            // do not handle correctly sometimes.
            url += '?' + this.configuration.queryParamsStringify(context.query);
        }
        const headers = Object.assign({}, this.configuration.headers, context.headers);
        Object.keys(headers).forEach((key)=>headers[key] === undefined ? delete headers[key] : {});
        const initOverrideFn = typeof initOverrides === "function" ? initOverrides : async ()=>initOverrides;
        const initParams = {
            method: context.method,
            headers,
            body: context.body,
            credentials: this.configuration.credentials
        };
        const overriddenInit = {
            ...initParams,
            ...await initOverrideFn({
                init: initParams,
                context
            })
        };
        let body;
        if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
            body = overriddenInit.body;
        } else if (this.isJsonMime(headers['Content-Type'])) {
            body = JSON.stringify(overriddenInit.body);
        } else {
            body = overriddenInit.body;
        }
        const init = {
            ...overriddenInit,
            body
        };
        return {
            url,
            init
        };
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */ clone() {
        const constructor = this.constructor;
        const next = new constructor(this.configuration);
        next.middleware = this.middleware.slice();
        return next;
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg){
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg){
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
exports.exists = exists;
function querystring(params, prefix = '') {
    return Object.keys(params).map((key)=>querystringSingleKey(key, params[key], prefix)).filter((part)=>part.length > 0).join('&');
}
exports.querystring = querystring;
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        const multiValue = value.map((singleValue)=>encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
        return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key)=>({
            ...acc,
            [key]: fn(data[key])
        }), {});
}
exports.mapValues = mapValues;
function canConsumeForm(consumes) {
    for (const consume of consumes){
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
exports.canConsumeForm = canConsumeForm;
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue)=>jsonValue){
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw){
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
}
exports.TextApiResponse = TextApiResponse; //# sourceMappingURL=runtime.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/AssistantFileModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantFileModelToJSON = exports.AssistantFileModelFromJSONTyped = exports.AssistantFileModelFromJSON = exports.instanceOfAssistantFileModel = exports.AssistantFileModelStatusEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.AssistantFileModelStatusEnum = {
    Processing: 'Processing',
    Available: 'Available',
    Deleting: 'Deleting',
    ProcessingFailed: 'ProcessingFailed'
};
/**
 * Check if a given object implements the AssistantFileModel interface.
 */ function instanceOfAssistantFileModel(value) {
    let isInstance = true;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "id" in value;
    return isInstance;
}
exports.instanceOfAssistantFileModel = instanceOfAssistantFileModel;
function AssistantFileModelFromJSON(json) {
    return AssistantFileModelFromJSONTyped(json, false);
}
exports.AssistantFileModelFromJSON = AssistantFileModelFromJSON;
function AssistantFileModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'name': json['name'],
        'id': json['id'],
        'metadata': !(0, runtime_1.exists)(json, 'metadata') ? undefined : json['metadata'],
        'createdOn': !(0, runtime_1.exists)(json, 'created_on') ? undefined : new Date(json['created_on']),
        'updatedOn': !(0, runtime_1.exists)(json, 'updated_on') ? undefined : new Date(json['updated_on']),
        'status': !(0, runtime_1.exists)(json, 'status') ? undefined : json['status'],
        'percentDone': !(0, runtime_1.exists)(json, 'percent_done') ? undefined : json['percent_done'],
        'signedUrl': !(0, runtime_1.exists)(json, 'signed_url') ? undefined : json['signed_url'],
        'errorMessage': !(0, runtime_1.exists)(json, 'error_message') ? undefined : json['error_message']
    };
}
exports.AssistantFileModelFromJSONTyped = AssistantFileModelFromJSONTyped;
function AssistantFileModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'name': value.name,
        'id': value.id,
        'metadata': value.metadata,
        'created_on': value.createdOn === undefined ? undefined : value.createdOn.toISOString(),
        'updated_on': value.updatedOn === undefined ? undefined : value.updatedOn.toISOString(),
        'status': value.status,
        'percent_done': value.percentDone,
        'signed_url': value.signedUrl,
        'error_message': value.errorMessage
    };
}
exports.AssistantFileModelToJSON = AssistantFileModelToJSON; //# sourceMappingURL=AssistantFileModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextOptionsModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextOptionsModelToJSON = exports.ContextOptionsModelFromJSONTyped = exports.ContextOptionsModelFromJSON = exports.instanceOfContextOptionsModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ContextOptionsModel interface.
 */ function instanceOfContextOptionsModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfContextOptionsModel = instanceOfContextOptionsModel;
function ContextOptionsModelFromJSON(json) {
    return ContextOptionsModelFromJSONTyped(json, false);
}
exports.ContextOptionsModelFromJSON = ContextOptionsModelFromJSON;
function ContextOptionsModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'topK': !(0, runtime_1.exists)(json, 'top_k') ? undefined : json['top_k'],
        'snippetSize': !(0, runtime_1.exists)(json, 'snippet_size') ? undefined : json['snippet_size']
    };
}
exports.ContextOptionsModelFromJSONTyped = ContextOptionsModelFromJSONTyped;
function ContextOptionsModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'top_k': value.topK,
        'snippet_size': value.snippetSize
    };
}
exports.ContextOptionsModelToJSON = ContextOptionsModelToJSON; //# sourceMappingURL=ContextOptionsModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageModelToJSON = exports.MessageModelFromJSONTyped = exports.MessageModelFromJSON = exports.instanceOfMessageModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the MessageModel interface.
 */ function instanceOfMessageModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfMessageModel = instanceOfMessageModel;
function MessageModelFromJSON(json) {
    return MessageModelFromJSONTyped(json, false);
}
exports.MessageModelFromJSON = MessageModelFromJSON;
function MessageModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'role': !(0, runtime_1.exists)(json, 'role') ? undefined : json['role'],
        'content': !(0, runtime_1.exists)(json, 'content') ? undefined : json['content']
    };
}
exports.MessageModelFromJSONTyped = MessageModelFromJSONTyped;
function MessageModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'role': value.role,
        'content': value.content
    };
}
exports.MessageModelToJSON = MessageModelToJSON; //# sourceMappingURL=MessageModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/Chat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatToJSON = exports.ChatFromJSONTyped = exports.ChatFromJSON = exports.instanceOfChat = exports.ChatModelEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const ContextOptionsModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextOptionsModel.js [app-route] (ecmascript)");
const MessageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ChatModelEnum = {
    Gpt4o: 'gpt-4o',
    Gpt41: 'gpt-4.1',
    O4Mini: 'o4-mini',
    Claude35Sonnet: 'claude-3-5-sonnet',
    Claude37Sonnet: 'claude-3-7-sonnet',
    Gemini25Pro: 'gemini-2.5-pro'
};
/**
 * Check if a given object implements the Chat interface.
 */ function instanceOfChat(value) {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;
    return isInstance;
}
exports.instanceOfChat = instanceOfChat;
function ChatFromJSON(json) {
    return ChatFromJSONTyped(json, false);
}
exports.ChatFromJSON = ChatFromJSON;
function ChatFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'messages': json['messages'].map(MessageModel_1.MessageModelFromJSON),
        'stream': !(0, runtime_1.exists)(json, 'stream') ? undefined : json['stream'],
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model'],
        'temperature': !(0, runtime_1.exists)(json, 'temperature') ? undefined : json['temperature'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter'],
        'jsonResponse': !(0, runtime_1.exists)(json, 'json_response') ? undefined : json['json_response'],
        'includeHighlights': !(0, runtime_1.exists)(json, 'include_highlights') ? undefined : json['include_highlights'],
        'contextOptions': !(0, runtime_1.exists)(json, 'context_options') ? undefined : (0, ContextOptionsModel_1.ContextOptionsModelFromJSON)(json['context_options'])
    };
}
exports.ChatFromJSONTyped = ChatFromJSONTyped;
function ChatToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'messages': value.messages.map(MessageModel_1.MessageModelToJSON),
        'stream': value.stream,
        'model': value.model,
        'temperature': value.temperature,
        'filter': value.filter,
        'json_response': value.jsonResponse,
        'include_highlights': value.includeHighlights,
        'context_options': (0, ContextOptionsModel_1.ContextOptionsModelToJSON)(value.contextOptions)
    };
}
exports.ChatToJSON = ChatToJSON; //# sourceMappingURL=Chat.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInnerDelta.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaToJSON = exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSONTyped = exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSON = exports.instanceOfChatCompletionAssistant200ResponseChoicesInnerDelta = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ChatCompletionAssistant200ResponseChoicesInnerDelta interface.
 */ function instanceOfChatCompletionAssistant200ResponseChoicesInnerDelta(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChatCompletionAssistant200ResponseChoicesInnerDelta = instanceOfChatCompletionAssistant200ResponseChoicesInnerDelta;
function ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSON(json) {
    return ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSONTyped(json, false);
}
exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSON = ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSON;
function ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'role': !(0, runtime_1.exists)(json, 'role') ? undefined : json['role'],
        'content': !(0, runtime_1.exists)(json, 'content') ? undefined : json['content']
    };
}
exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSONTyped = ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSONTyped;
function ChatCompletionAssistant200ResponseChoicesInnerDeltaToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'role': value.role,
        'content': value.content
    };
}
exports.ChatCompletionAssistant200ResponseChoicesInnerDeltaToJSON = ChatCompletionAssistant200ResponseChoicesInnerDeltaToJSON; //# sourceMappingURL=ChatCompletionAssistant200ResponseChoicesInnerDelta.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInner.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionAssistant200ResponseChoicesInnerToJSON = exports.ChatCompletionAssistant200ResponseChoicesInnerFromJSONTyped = exports.ChatCompletionAssistant200ResponseChoicesInnerFromJSON = exports.instanceOfChatCompletionAssistant200ResponseChoicesInner = exports.ChatCompletionAssistant200ResponseChoicesInnerFinishReasonEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const ChatCompletionAssistant200ResponseChoicesInnerDelta_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInnerDelta.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ChatCompletionAssistant200ResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
};
/**
 * Check if a given object implements the ChatCompletionAssistant200ResponseChoicesInner interface.
 */ function instanceOfChatCompletionAssistant200ResponseChoicesInner(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChatCompletionAssistant200ResponseChoicesInner = instanceOfChatCompletionAssistant200ResponseChoicesInner;
function ChatCompletionAssistant200ResponseChoicesInnerFromJSON(json) {
    return ChatCompletionAssistant200ResponseChoicesInnerFromJSONTyped(json, false);
}
exports.ChatCompletionAssistant200ResponseChoicesInnerFromJSON = ChatCompletionAssistant200ResponseChoicesInnerFromJSON;
function ChatCompletionAssistant200ResponseChoicesInnerFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'finishReason': !(0, runtime_1.exists)(json, 'finish_reason') ? undefined : json['finish_reason'],
        'index': !(0, runtime_1.exists)(json, 'index') ? undefined : json['index'],
        'delta': !(0, runtime_1.exists)(json, 'delta') ? undefined : (0, ChatCompletionAssistant200ResponseChoicesInnerDelta_1.ChatCompletionAssistant200ResponseChoicesInnerDeltaFromJSON)(json['delta'])
    };
}
exports.ChatCompletionAssistant200ResponseChoicesInnerFromJSONTyped = ChatCompletionAssistant200ResponseChoicesInnerFromJSONTyped;
function ChatCompletionAssistant200ResponseChoicesInnerToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'finish_reason': value.finishReason,
        'index': value.index,
        'delta': (0, ChatCompletionAssistant200ResponseChoicesInnerDelta_1.ChatCompletionAssistant200ResponseChoicesInnerDeltaToJSON)(value.delta)
    };
}
exports.ChatCompletionAssistant200ResponseChoicesInnerToJSON = ChatCompletionAssistant200ResponseChoicesInnerToJSON; //# sourceMappingURL=ChatCompletionAssistant200ResponseChoicesInner.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200Response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionAssistant200ResponseToJSON = exports.ChatCompletionAssistant200ResponseFromJSONTyped = exports.ChatCompletionAssistant200ResponseFromJSON = exports.instanceOfChatCompletionAssistant200Response = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const ChatCompletionAssistant200ResponseChoicesInner_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInner.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ChatCompletionAssistant200Response interface.
 */ function instanceOfChatCompletionAssistant200Response(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChatCompletionAssistant200Response = instanceOfChatCompletionAssistant200Response;
function ChatCompletionAssistant200ResponseFromJSON(json) {
    return ChatCompletionAssistant200ResponseFromJSONTyped(json, false);
}
exports.ChatCompletionAssistant200ResponseFromJSON = ChatCompletionAssistant200ResponseFromJSON;
function ChatCompletionAssistant200ResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id'],
        'choices': !(0, runtime_1.exists)(json, 'choices') ? undefined : json['choices'].map(ChatCompletionAssistant200ResponseChoicesInner_1.ChatCompletionAssistant200ResponseChoicesInnerFromJSON),
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model']
    };
}
exports.ChatCompletionAssistant200ResponseFromJSONTyped = ChatCompletionAssistant200ResponseFromJSONTyped;
function ChatCompletionAssistant200ResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'choices': value.choices === undefined ? undefined : value.choices.map(ChatCompletionAssistant200ResponseChoicesInner_1.ChatCompletionAssistant200ResponseChoicesInnerToJSON),
        'model': value.model
    };
}
exports.ChatCompletionAssistant200ResponseToJSON = ChatCompletionAssistant200ResponseToJSON; //# sourceMappingURL=ChatCompletionAssistant200Response.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChoiceModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChoiceModelToJSON = exports.ChoiceModelFromJSONTyped = exports.ChoiceModelFromJSON = exports.instanceOfChoiceModel = exports.ChoiceModelFinishReasonEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const MessageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ChoiceModelFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
};
/**
 * Check if a given object implements the ChoiceModel interface.
 */ function instanceOfChoiceModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChoiceModel = instanceOfChoiceModel;
function ChoiceModelFromJSON(json) {
    return ChoiceModelFromJSONTyped(json, false);
}
exports.ChoiceModelFromJSON = ChoiceModelFromJSON;
function ChoiceModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'finishReason': !(0, runtime_1.exists)(json, 'finish_reason') ? undefined : json['finish_reason'],
        'index': !(0, runtime_1.exists)(json, 'index') ? undefined : json['index'],
        'message': !(0, runtime_1.exists)(json, 'message') ? undefined : (0, MessageModel_1.MessageModelFromJSON)(json['message'])
    };
}
exports.ChoiceModelFromJSONTyped = ChoiceModelFromJSONTyped;
function ChoiceModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'finish_reason': value.finishReason,
        'index': value.index,
        'message': (0, MessageModel_1.MessageModelToJSON)(value.message)
    };
}
exports.ChoiceModelToJSON = ChoiceModelToJSON; //# sourceMappingURL=ChoiceModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/UsageModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsageModelToJSON = exports.UsageModelFromJSONTyped = exports.UsageModelFromJSON = exports.instanceOfUsageModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the UsageModel interface.
 */ function instanceOfUsageModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfUsageModel = instanceOfUsageModel;
function UsageModelFromJSON(json) {
    return UsageModelFromJSONTyped(json, false);
}
exports.UsageModelFromJSON = UsageModelFromJSON;
function UsageModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'promptTokens': !(0, runtime_1.exists)(json, 'prompt_tokens') ? undefined : json['prompt_tokens'],
        'completionTokens': !(0, runtime_1.exists)(json, 'completion_tokens') ? undefined : json['completion_tokens'],
        'totalTokens': !(0, runtime_1.exists)(json, 'total_tokens') ? undefined : json['total_tokens']
    };
}
exports.UsageModelFromJSONTyped = UsageModelFromJSONTyped;
function UsageModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'prompt_tokens': value.promptTokens,
        'completion_tokens': value.completionTokens,
        'total_tokens': value.totalTokens
    };
}
exports.UsageModelToJSON = UsageModelToJSON; //# sourceMappingURL=UsageModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatCompletionModelToJSON = exports.ChatCompletionModelFromJSONTyped = exports.ChatCompletionModelFromJSON = exports.instanceOfChatCompletionModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const ChoiceModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChoiceModel.js [app-route] (ecmascript)");
const UsageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/UsageModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ChatCompletionModel interface.
 */ function instanceOfChatCompletionModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChatCompletionModel = instanceOfChatCompletionModel;
function ChatCompletionModelFromJSON(json) {
    return ChatCompletionModelFromJSONTyped(json, false);
}
exports.ChatCompletionModelFromJSON = ChatCompletionModelFromJSON;
function ChatCompletionModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id'],
        'choices': !(0, runtime_1.exists)(json, 'choices') ? undefined : json['choices'].map(ChoiceModel_1.ChoiceModelFromJSON),
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model'],
        'usage': !(0, runtime_1.exists)(json, 'usage') ? undefined : (0, UsageModel_1.UsageModelFromJSON)(json['usage'])
    };
}
exports.ChatCompletionModelFromJSONTyped = ChatCompletionModelFromJSONTyped;
function ChatCompletionModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'choices': value.choices === undefined ? undefined : value.choices.map(ChoiceModel_1.ChoiceModelToJSON),
        'model': value.model,
        'usage': (0, UsageModel_1.UsageModelToJSON)(value.usage)
    };
}
exports.ChatCompletionModelToJSON = ChatCompletionModelToJSON; //# sourceMappingURL=ChatCompletionModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/HighlightModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HighlightModelToJSON = exports.HighlightModelFromJSONTyped = exports.HighlightModelFromJSON = exports.instanceOfHighlightModel = void 0;
/**
 * Check if a given object implements the HighlightModel interface.
 */ function instanceOfHighlightModel(value) {
    let isInstance = true;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "content" in value;
    return isInstance;
}
exports.instanceOfHighlightModel = instanceOfHighlightModel;
function HighlightModelFromJSON(json) {
    return HighlightModelFromJSONTyped(json, false);
}
exports.HighlightModelFromJSON = HighlightModelFromJSON;
function HighlightModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'type': json['type'],
        'content': json['content']
    };
}
exports.HighlightModelFromJSONTyped = HighlightModelFromJSONTyped;
function HighlightModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'type': value.type,
        'content': value.content
    };
}
exports.HighlightModelToJSON = HighlightModelToJSON; //# sourceMappingURL=HighlightModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ReferenceModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReferenceModelToJSON = exports.ReferenceModelFromJSONTyped = exports.ReferenceModelFromJSON = exports.instanceOfReferenceModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const AssistantFileModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/AssistantFileModel.js [app-route] (ecmascript)");
const HighlightModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/HighlightModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ReferenceModel interface.
 */ function instanceOfReferenceModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfReferenceModel = instanceOfReferenceModel;
function ReferenceModelFromJSON(json) {
    return ReferenceModelFromJSONTyped(json, false);
}
exports.ReferenceModelFromJSON = ReferenceModelFromJSON;
function ReferenceModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'file': !(0, runtime_1.exists)(json, 'file') ? undefined : (0, AssistantFileModel_1.AssistantFileModelFromJSON)(json['file']),
        'pages': !(0, runtime_1.exists)(json, 'pages') ? undefined : json['pages'],
        'highlight': !(0, runtime_1.exists)(json, 'highlight') ? undefined : (0, HighlightModel_1.HighlightModelFromJSON)(json['highlight'])
    };
}
exports.ReferenceModelFromJSONTyped = ReferenceModelFromJSONTyped;
function ReferenceModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'file': (0, AssistantFileModel_1.AssistantFileModelToJSON)(value.file),
        'pages': value.pages,
        'highlight': (0, HighlightModel_1.HighlightModelToJSON)(value.highlight)
    };
}
exports.ReferenceModelToJSON = ReferenceModelToJSON; //# sourceMappingURL=ReferenceModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/CitationModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CitationModelToJSON = exports.CitationModelFromJSONTyped = exports.CitationModelFromJSON = exports.instanceOfCitationModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const ReferenceModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ReferenceModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the CitationModel interface.
 */ function instanceOfCitationModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfCitationModel = instanceOfCitationModel;
function CitationModelFromJSON(json) {
    return CitationModelFromJSONTyped(json, false);
}
exports.CitationModelFromJSON = CitationModelFromJSON;
function CitationModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'position': !(0, runtime_1.exists)(json, 'position') ? undefined : json['position'],
        'references': !(0, runtime_1.exists)(json, 'references') ? undefined : json['references'].map(ReferenceModel_1.ReferenceModelFromJSON)
    };
}
exports.CitationModelFromJSONTyped = CitationModelFromJSONTyped;
function CitationModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'position': value.position,
        'references': value.references === undefined ? undefined : value.references.map(ReferenceModel_1.ReferenceModelToJSON)
    };
}
exports.CitationModelToJSON = CitationModelToJSON; //# sourceMappingURL=CitationModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChatModelToJSON = exports.ChatModelFromJSONTyped = exports.ChatModelFromJSON = exports.instanceOfChatModel = exports.ChatModelFinishReasonEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const CitationModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/CitationModel.js [app-route] (ecmascript)");
const MessageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)");
const UsageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/UsageModel.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ChatModelFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
};
/**
 * Check if a given object implements the ChatModel interface.
 */ function instanceOfChatModel(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfChatModel = instanceOfChatModel;
function ChatModelFromJSON(json) {
    return ChatModelFromJSONTyped(json, false);
}
exports.ChatModelFromJSON = ChatModelFromJSON;
function ChatModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id'],
        'finishReason': !(0, runtime_1.exists)(json, 'finish_reason') ? undefined : json['finish_reason'],
        'message': !(0, runtime_1.exists)(json, 'message') ? undefined : (0, MessageModel_1.MessageModelFromJSON)(json['message']),
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model'],
        'citations': !(0, runtime_1.exists)(json, 'citations') ? undefined : json['citations'].map(CitationModel_1.CitationModelFromJSON),
        'usage': !(0, runtime_1.exists)(json, 'usage') ? undefined : (0, UsageModel_1.UsageModelFromJSON)(json['usage'])
    };
}
exports.ChatModelFromJSONTyped = ChatModelFromJSONTyped;
function ChatModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'finish_reason': value.finishReason,
        'message': (0, MessageModel_1.MessageModelToJSON)(value.message),
        'model': value.model,
        'citations': value.citations === undefined ? undefined : value.citations.map(CitationModel_1.CitationModelToJSON),
        'usage': (0, UsageModel_1.UsageModelToJSON)(value.usage)
    };
}
exports.ChatModelToJSON = ChatModelToJSON; //# sourceMappingURL=ChatModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/SnippetModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SnippetModelToJSON = exports.SnippetModelFromJSONTyped = exports.SnippetModelFromJSON = exports.instanceOfSnippetModel = exports.SnippetModelTypeEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.SnippetModelTypeEnum = {
    Text: 'text'
};
/**
 * Check if a given object implements the SnippetModel interface.
 */ function instanceOfSnippetModel(value) {
    let isInstance = true;
    isInstance = isInstance && "content" in value;
    isInstance = isInstance && "score" in value;
    isInstance = isInstance && "reference" in value;
    return isInstance;
}
exports.instanceOfSnippetModel = instanceOfSnippetModel;
function SnippetModelFromJSON(json) {
    return SnippetModelFromJSONTyped(json, false);
}
exports.SnippetModelFromJSON = SnippetModelFromJSON;
function SnippetModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'type': !(0, runtime_1.exists)(json, 'type') ? undefined : json['type'],
        'content': json['content'],
        'score': json['score'],
        'reference': json['reference']
    };
}
exports.SnippetModelFromJSONTyped = SnippetModelFromJSONTyped;
function SnippetModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'type': value.type,
        'content': value.content,
        'score': value.score,
        'reference': value.reference
    };
}
exports.SnippetModelToJSON = SnippetModelToJSON; //# sourceMappingURL=SnippetModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextModel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextModelToJSON = exports.ContextModelFromJSONTyped = exports.ContextModelFromJSON = exports.instanceOfContextModel = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const SnippetModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/SnippetModel.js [app-route] (ecmascript)");
const UsageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/UsageModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ContextModel interface.
 */ function instanceOfContextModel(value) {
    let isInstance = true;
    isInstance = isInstance && "snippets" in value;
    isInstance = isInstance && "usage" in value;
    return isInstance;
}
exports.instanceOfContextModel = instanceOfContextModel;
function ContextModelFromJSON(json) {
    return ContextModelFromJSONTyped(json, false);
}
exports.ContextModelFromJSON = ContextModelFromJSON;
function ContextModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'id': !(0, runtime_1.exists)(json, 'id') ? undefined : json['id'],
        'snippets': json['snippets'].map(SnippetModel_1.SnippetModelFromJSON),
        'usage': (0, UsageModel_1.UsageModelFromJSON)(json['usage'])
    };
}
exports.ContextModelFromJSONTyped = ContextModelFromJSONTyped;
function ContextModelToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'id': value.id,
        'snippets': value.snippets.map(SnippetModel_1.SnippetModelToJSON),
        'usage': (0, UsageModel_1.UsageModelToJSON)(value.usage)
    };
}
exports.ContextModelToJSON = ContextModelToJSON; //# sourceMappingURL=ContextModel.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextRequestToJSON = exports.ContextRequestFromJSONTyped = exports.ContextRequestFromJSON = exports.instanceOfContextRequest = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const MessageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ContextRequest interface.
 */ function instanceOfContextRequest(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfContextRequest = instanceOfContextRequest;
function ContextRequestFromJSON(json) {
    return ContextRequestFromJSONTyped(json, false);
}
exports.ContextRequestFromJSON = ContextRequestFromJSON;
function ContextRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'query': !(0, runtime_1.exists)(json, 'query') ? undefined : json['query'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter'],
        'messages': !(0, runtime_1.exists)(json, 'messages') ? undefined : json['messages'].map(MessageModel_1.MessageModelFromJSON),
        'topK': !(0, runtime_1.exists)(json, 'top_k') ? undefined : json['top_k'],
        'snippetSize': !(0, runtime_1.exists)(json, 'snippet_size') ? undefined : json['snippet_size']
    };
}
exports.ContextRequestFromJSONTyped = ContextRequestFromJSONTyped;
function ContextRequestToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'query': value.query,
        'filter': value.filter,
        'messages': value.messages === undefined ? undefined : value.messages.map(MessageModel_1.MessageModelToJSON),
        'top_k': value.topK,
        'snippet_size': value.snippetSize
    };
}
exports.ContextRequestToJSON = ContextRequestToJSON; //# sourceMappingURL=ContextRequest.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ErrorResponseError.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.ErrorResponseErrorCodeEnum = {
    Ok: 'OK',
    Unknown: 'UNKNOWN',
    InvalidArgument: 'INVALID_ARGUMENT',
    DeadlineExceeded: 'DEADLINE_EXCEEDED',
    QuotaExceeded: 'QUOTA_EXCEEDED',
    NotFound: 'NOT_FOUND',
    AlreadyExists: 'ALREADY_EXISTS',
    PermissionDenied: 'PERMISSION_DENIED',
    Unauthenticated: 'UNAUTHENTICATED',
    ResourceExhausted: 'RESOURCE_EXHAUSTED',
    FailedPrecondition: 'FAILED_PRECONDITION',
    Aborted: 'ABORTED',
    OutOfRange: 'OUT_OF_RANGE',
    Unimplemented: 'UNIMPLEMENTED',
    Internal: 'INTERNAL',
    Unavailable: 'UNAVAILABLE',
    DataLoss: 'DATA_LOSS',
    Forbidden: 'FORBIDDEN'
};
/**
 * Check if a given object implements the ErrorResponseError interface.
 */ function instanceOfErrorResponseError(value) {
    let isInstance = true;
    isInstance = isInstance && "code" in value;
    isInstance = isInstance && "message" in value;
    return isInstance;
}
exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
}
exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'code': json['code'],
        'message': json['message'],
        'details': !(0, runtime_1.exists)(json, 'details') ? undefined : json['details']
    };
}
exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
function ErrorResponseErrorToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'code': value.code,
        'message': value.message,
        'details': value.details
    };
}
exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON; //# sourceMappingURL=ErrorResponseError.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ErrorResponse.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = void 0;
const ErrorResponseError_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ErrorResponseError.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ErrorResponse interface.
 */ function instanceOfErrorResponse(value) {
    let isInstance = true;
    isInstance = isInstance && "status" in value;
    isInstance = isInstance && "error" in value;
    return isInstance;
}
exports.instanceOfErrorResponse = instanceOfErrorResponse;
function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
}
exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'status': json['status'],
        'error': (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json['error'])
    };
}
exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
function ErrorResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'status': value.status,
        'error': (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value.error)
    };
}
exports.ErrorResponseToJSON = ErrorResponseToJSON; //# sourceMappingURL=ErrorResponse.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ListFiles200Response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ListFiles200ResponseToJSON = exports.ListFiles200ResponseFromJSONTyped = exports.ListFiles200ResponseFromJSON = exports.instanceOfListFiles200Response = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const AssistantFileModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/AssistantFileModel.js [app-route] (ecmascript)");
/**
 * Check if a given object implements the ListFiles200Response interface.
 */ function instanceOfListFiles200Response(value) {
    let isInstance = true;
    return isInstance;
}
exports.instanceOfListFiles200Response = instanceOfListFiles200Response;
function ListFiles200ResponseFromJSON(json) {
    return ListFiles200ResponseFromJSONTyped(json, false);
}
exports.ListFiles200ResponseFromJSON = ListFiles200ResponseFromJSON;
function ListFiles200ResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'files': !(0, runtime_1.exists)(json, 'files') ? undefined : json['files'].map(AssistantFileModel_1.AssistantFileModelFromJSON)
    };
}
exports.ListFiles200ResponseFromJSONTyped = ListFiles200ResponseFromJSONTyped;
function ListFiles200ResponseToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'files': value.files === undefined ? undefined : value.files.map(AssistantFileModel_1.AssistantFileModelToJSON)
    };
}
exports.ListFiles200ResponseToJSON = ListFiles200ResponseToJSON; //# sourceMappingURL=ListFiles200Response.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/SearchCompletions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchCompletionsToJSON = exports.SearchCompletionsFromJSONTyped = exports.SearchCompletionsFromJSON = exports.instanceOfSearchCompletions = exports.SearchCompletionsModelEnum = void 0;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)");
const MessageModel_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)");
/**
 * @export
 */ exports.SearchCompletionsModelEnum = {
    Gpt4o: 'gpt-4o',
    Gpt41: 'gpt-4.1',
    O4Mini: 'o4-mini',
    Claude35Sonnet: 'claude-3-5-sonnet',
    Claude37Sonnet: 'claude-3-7-sonnet',
    Gemini25Pro: 'gemini-2.5-pro'
};
/**
 * Check if a given object implements the SearchCompletions interface.
 */ function instanceOfSearchCompletions(value) {
    let isInstance = true;
    isInstance = isInstance && "messages" in value;
    return isInstance;
}
exports.instanceOfSearchCompletions = instanceOfSearchCompletions;
function SearchCompletionsFromJSON(json) {
    return SearchCompletionsFromJSONTyped(json, false);
}
exports.SearchCompletionsFromJSON = SearchCompletionsFromJSON;
function SearchCompletionsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
        return json;
    }
    return {
        'messages': json['messages'].map(MessageModel_1.MessageModelFromJSON),
        'stream': !(0, runtime_1.exists)(json, 'stream') ? undefined : json['stream'],
        'model': !(0, runtime_1.exists)(json, 'model') ? undefined : json['model'],
        'temperature': !(0, runtime_1.exists)(json, 'temperature') ? undefined : json['temperature'],
        'filter': !(0, runtime_1.exists)(json, 'filter') ? undefined : json['filter']
    };
}
exports.SearchCompletionsFromJSONTyped = SearchCompletionsFromJSONTyped;
function SearchCompletionsToJSON(value) {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        'messages': value.messages.map(MessageModel_1.MessageModelToJSON),
        'stream': value.stream,
        'model': value.model,
        'temperature': value.temperature,
        'filter': value.filter
    };
}
exports.SearchCompletionsToJSON = SearchCompletionsToJSON; //# sourceMappingURL=SearchCompletions.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/AssistantFileModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/Chat.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200Response.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInner.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionAssistant200ResponseChoicesInnerDelta.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatCompletionModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChatModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ChoiceModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/CitationModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextOptionsModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ContextRequest.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ErrorResponse.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ErrorResponseError.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/HighlightModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ListFiles200Response.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/MessageModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/ReferenceModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/SearchCompletions.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/SnippetModel.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/UsageModel.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/apis/ManageAssistantsApi.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* tslint:disable */ /* eslint-disable */ /**
 * Pinecone Assistant Data Plane API
 * Pinecone Assistant Engine is a context engine to store and retrieve relevant knowledge from millions of documents at scale. This API supports interactions with assistants.
 *
 * The version of the OpenAPI document: 2025-04
 * Contact: support@pinecone.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DescribeFileIncludeUrlEnum = exports.ManageAssistantsApi = void 0;
const runtime = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)"));
const index_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/index.js [app-route] (ecmascript)");
/**
 *
 */ class ManageAssistantsApi extends runtime.BaseAPI {
    /**
     * Chat with an assistant and get back citations in structured form.   This is the recommended way to chat with an assistant, as it offers more functionality and control over the assistant\'s responses and references than the OpenAI-compatible chat interface.  For guidance and examples, see [Chat with an assistant](https://docs.pinecone.io/guides/assistant/chat-with-assistant).
     * Chat with an assistant
     */ async chatAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling chatAssistant.');
        }
        if (requestParameters.chat === null || requestParameters.chat === undefined) {
            throw new runtime.RequiredError('chat', 'Required parameter requestParameters.chat was null or undefined when calling chatAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/chat/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ChatToJSON)(requestParameters.chat)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ChatModelFromJSON)(jsonValue));
    }
    /**
     * Chat with an assistant and get back citations in structured form.   This is the recommended way to chat with an assistant, as it offers more functionality and control over the assistant\'s responses and references than the OpenAI-compatible chat interface.  For guidance and examples, see [Chat with an assistant](https://docs.pinecone.io/guides/assistant/chat-with-assistant).
     * Chat with an assistant
     */ async chatAssistant(requestParameters, initOverrides) {
        const response = await this.chatAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Chat with an assistant. This endpoint is based on the OpenAI Chat Completion API, a commonly used and adopted API.   It is useful if you need inline citations or OpenAI-compatible responses, but has limited functionality compared to the standard chat interface.  For guidance and examples, see [Chat with an assistant](https://docs.pinecone.io/guides/assistant/chat-with-assistant).
     * Chat through an OpenAI-compatible interface
     */ async chatCompletionAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling chatCompletionAssistant.');
        }
        if (requestParameters.searchCompletions === null || requestParameters.searchCompletions === undefined) {
            throw new runtime.RequiredError('searchCompletions', 'Required parameter requestParameters.searchCompletions was null or undefined when calling chatCompletionAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/chat/{assistant_name}/chat/completions`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.SearchCompletionsToJSON)(requestParameters.searchCompletions)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ChatCompletionModelFromJSON)(jsonValue));
    }
    /**
     * Chat with an assistant. This endpoint is based on the OpenAI Chat Completion API, a commonly used and adopted API.   It is useful if you need inline citations or OpenAI-compatible responses, but has limited functionality compared to the standard chat interface.  For guidance and examples, see [Chat with an assistant](https://docs.pinecone.io/guides/assistant/chat-with-assistant).
     * Chat through an OpenAI-compatible interface
     */ async chatCompletionAssistant(requestParameters, initOverrides) {
        const response = await this.chatCompletionAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Retrieve context snippets from an assistant to use as part of RAG or any agentic flow.  For guidance and examples, see [Retrieve context snippets](https://docs.pinecone.io/guides/assistant/retrieve-context-snippets).
     * Retrieve context from an assistant
     */ async contextAssistantRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling contextAssistant.');
        }
        if (requestParameters.contextRequest === null || requestParameters.contextRequest === undefined) {
            throw new runtime.RequiredError('contextRequest', 'Required parameter requestParameters.contextRequest was null or undefined when calling contextAssistant.');
        }
        const queryParameters = {};
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/chat/{assistant_name}/context`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: (0, index_1.ContextRequestToJSON)(requestParameters.contextRequest)
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ContextModelFromJSON)(jsonValue));
    }
    /**
     * Retrieve context snippets from an assistant to use as part of RAG or any agentic flow.  For guidance and examples, see [Retrieve context snippets](https://docs.pinecone.io/guides/assistant/retrieve-context-snippets).
     * Retrieve context from an assistant
     */ async contextAssistant(requestParameters, initOverrides) {
        const response = await this.contextAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Delete an uploaded file from an assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#delete-a-file).
     * Delete an uploaded file
     */ async deleteFileRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling deleteFile.');
        }
        if (requestParameters.assistantFileId === null || requestParameters.assistantFileId === undefined) {
            throw new runtime.RequiredError('assistantFileId', 'Required parameter requestParameters.assistantFileId was null or undefined when calling deleteFile.');
        }
        const queryParameters = {};
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/files/{assistant_name}/{assistant_file_id}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))).replace(`{${"assistant_file_id"}}`, encodeURIComponent(String(requestParameters.assistantFileId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.VoidApiResponse(response);
    }
    /**
     * Delete an uploaded file from an assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#delete-a-file).
     * Delete an uploaded file
     */ async deleteFile(requestParameters, initOverrides) {
        await this.deleteFileRaw(requestParameters, initOverrides);
    }
    /**
     * Get the status and metadata of a file uploaded to an assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#get-the-status-of-a-file).
     * Describe a file upload
     */ async describeFileRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling describeFile.');
        }
        if (requestParameters.assistantFileId === null || requestParameters.assistantFileId === undefined) {
            throw new runtime.RequiredError('assistantFileId', 'Required parameter requestParameters.assistantFileId was null or undefined when calling describeFile.');
        }
        const queryParameters = {};
        if (requestParameters.includeUrl !== undefined) {
            queryParameters['include_url'] = requestParameters.includeUrl;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/files/{assistant_name}/{assistant_file_id}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))).replace(`{${"assistant_file_id"}}`, encodeURIComponent(String(requestParameters.assistantFileId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.AssistantFileModelFromJSON)(jsonValue));
    }
    /**
     * Get the status and metadata of a file uploaded to an assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#get-the-status-of-a-file).
     * Describe a file upload
     */ async describeFile(requestParameters, initOverrides) {
        const response = await this.describeFileRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * List all files in an assistant, with an option to filter files with metadata.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#list-files-in-an-assistant).
     * List Files
     */ async listFilesRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling listFiles.');
        }
        const queryParameters = {};
        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const response = await this.request({
            path: `/files/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.ListFiles200ResponseFromJSON)(jsonValue));
    }
    /**
     * List all files in an assistant, with an option to filter files with metadata.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#list-files-in-an-assistant).
     * List Files
     */ async listFiles(requestParameters, initOverrides) {
        const response = await this.listFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }
    /**
     * Upload a file to the specified assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#upload-a-local-file).
     * Upload file to assistant
     */ async uploadFileRaw(requestParameters, initOverrides) {
        if (requestParameters.assistantName === null || requestParameters.assistantName === undefined) {
            throw new runtime.RequiredError('assistantName', 'Required parameter requestParameters.assistantName was null or undefined when calling uploadFile.');
        }
        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file', 'Required parameter requestParameters.file was null or undefined when calling uploadFile.');
        }
        const queryParameters = {};
        if (requestParameters.metadata !== undefined) {
            queryParameters['metadata'] = requestParameters.metadata;
        }
        const headerParameters = {};
        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key"); // ApiKeyAuth authentication
        }
        const consumes = [
            {
                contentType: 'multipart/form-data'
            }
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }
        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file);
        }
        const response = await this.request({
            path: `/files/{assistant_name}`.replace(`{${"assistant_name"}}`, encodeURIComponent(String(requestParameters.assistantName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams
        }, initOverrides);
        return new runtime.JSONApiResponse(response, (jsonValue)=>(0, index_1.AssistantFileModelFromJSON)(jsonValue));
    }
    /**
     * Upload a file to the specified assistant.  For guidance and examples, see [Manage files](https://docs.pinecone.io/guides/assistant/manage-files#upload-a-local-file).
     * Upload file to assistant
     */ async uploadFile(requestParameters, initOverrides) {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }
}
exports.ManageAssistantsApi = ManageAssistantsApi;
/**
 * @export
 */ exports.DescribeFileIncludeUrlEnum = {
    True: 'true',
    False: 'false'
}; //# sourceMappingURL=ManageAssistantsApi.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/apis/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/apis/ManageAssistantsApi.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/api_version.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.X_PINECONE_API_VERSION = void 0;
exports.X_PINECONE_API_VERSION = '2025-04'; //# sourceMappingURL=api_version.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/* tslint:disable */ /* eslint-disable */ __exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/runtime.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/apis/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/models/index.js [app-route] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/api_version.js [app-route] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/types.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FinishReasonEnum = exports.UploadFileOptionsType = exports.ContextOptionsType = exports.ChatCompletionOptionsType = exports.ChatOptionsType = exports.ChatModelEnum = exports.AssistantFileStatusEnum = exports.ListFilesOptionsType = void 0;
exports.ListFilesOptionsType = [
    'filter'
];
/**
 * Enum representing the possible statuses of an assistant file.
 *
 * - `Processing`: The file is currently being processed and is not yet available.
 * - `Available`: The file has been processed and is ready for use.
 * - `Deleting`: The file is in the process of being deleted.
 * - `ProcessingFailed`: There was an error encountered will processing.
 */ exports.AssistantFileStatusEnum = {
    Processing: 'Processing',
    Available: 'Available',
    Deleting: 'Deleting',
    ProcessingFailed: 'ProcessingFailed'
};
/**
 * An enum representing the models that can be used for chatting with an assistant. The default is 'gpt-4o'.
 */ exports.ChatModelEnum = {
    Gpt4o: 'gpt-4o',
    Claude35Sonnet: 'claude-3-5-sonnet'
};
exports.ChatOptionsType = [
    'messages',
    'model',
    'temperature',
    'filter',
    'jsonResponse',
    'includeHighlights',
    'topK',
    'contextOptions'
];
exports.ChatCompletionOptionsType = [
    'messages',
    'model',
    'temperature',
    'filter'
];
exports.ContextOptionsType = [
    'query',
    'filter',
    'messages',
    'topK'
];
exports.UploadFileOptionsType = [
    'path',
    'metadata'
];
/**
 * Enum representing the reasons why a response generation may finish.
 *
 * - `Stop`: The response was completed normally.
 * - `Length`: The response was truncated due to length constraints.
 * - `ContentFilter`: The response was stopped by a content filter.
 * - `FunctionCall`: The response generation was interrupted by a function call.
 */ exports.FinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
}; //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.modelValidation = exports.messagesValidation = exports.validateChatOptions = exports.chat = void 0;
const assistant_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/types.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const chat = (assistantName, apiProvider)=>{
    return async (options)=>{
        (0, exports.validateChatOptions)(options);
        const api = await apiProvider.provideData();
        const messages = (0, exports.messagesValidation)(options);
        const model = (0, exports.modelValidation)(options);
        const request = {
            assistantName: assistantName,
            chat: {
                messages: messages,
                stream: false,
                model: model,
                filter: options.filter,
                jsonResponse: options.jsonResponse,
                includeHighlights: options.includeHighlights,
                contextOptions: {
                    // use topK from contextOptions if provided, otherwise use topK from options
                    topK: options.contextOptions?.topK || options.topK,
                    snippetSize: options.contextOptions?.snippetSize
                }
            }
        };
        const retryWrapper = new utils_1.RetryOnServerFailure(()=>api.chatAssistant(request));
        return await retryWrapper.execute();
    };
};
exports.chat = chat;
const validateChatOptions = (options)=>{
    if (!options || !options.messages) {
        throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`messages`) to chat with an assistant.');
    }
    (0, validateObjectProperties_1.ValidateObjectProperties)(options, types_1.ChatOptionsType);
    if (options.model) {
        if (!Object.values(assistant_data_1.ChatModelEnum).includes(options.model)) {
            throw new errors_1.PineconeArgumentError(`Invalid model: "${options.model}". Must be one of: ${Object.values(assistant_data_1.ChatModelEnum).map((model)=>`"${model}"`).join(', ')}.`);
        }
    }
};
exports.validateChatOptions = validateChatOptions;
/**
 * Validates the messages passed to the Assistant.
 *
 * @param options - A {@link ChatRequest} object containing the messages to send to the Assistant.
 * @throws An Error `role` key is not one of `user` or `assistant`.
 * @throws An Error if the message object does not have exactly two keys: `role` and `content`.
 * @returns An array of {@link MessageModel} objects containing the messages to send to the Assistant.
 */ const messagesValidation = (options)=>{
    let messages = [];
    // If messages are passed as a list of strings:
    if (options.messages && typeof options.messages[0] == 'string') {
        // role defaults to user if not specified
        messages = options.messages.map((message)=>{
            return {
                role: 'user',
                content: message
            };
        });
    }
    // If messages are passed as a list of objects:
    if (Array.isArray(options.messages) && typeof options.messages[0] === 'object') {
        if (options.messages[0]['role']) {
            if (options.messages[0]['role'].toLowerCase() !== 'user' && options.messages[0]['role'].toLowerCase() !== 'assistant') {
                throw new Error('No role specified in message object. Must be one of "user" or "assistant"');
            }
        }
        // Extract unique keys from all messages
        const keys = Array.from(new Set(options.messages.flatMap((message)=>Object.keys(message))));
        if (keys.length !== 2) {
            throw new Error('Message object must have exactly two keys: "role" and "content"');
        }
        // Cast messages after validating keys
        return messages = options.messages;
    }
    return messages;
};
exports.messagesValidation = messagesValidation;
/**
 * Validates the model passed to the Assistant.
 *
 * @param options - A {@link ChatRequest} object containing the model to use for the Assistant.
 * @throws An Error if the model is not one of the available models as outlined in {@link ChatModelEnum}.
 */ const modelValidation = (options)=>{
    const allowedModels = Object.values(assistant_data_1.ChatModelEnum);
    // Make sure passed string for 'model' matches one of the Enum values; default to Gpt4o
    let model = assistant_data_1.ChatModelEnum.Gpt4o;
    if (options.model) {
        if (!allowedModels.includes(options.model)) {
            throw new Error(`Invalid model specified. Must be one of ${allowedModels.map((m)=>`"${m}"`).join(', ')}:`);
        } else {
            model = options.model;
        }
    }
    return model;
};
exports.modelValidation = modelValidation; //# sourceMappingURL=chat.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatCompletion.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chatCompletion = void 0;
const chat_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chat.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const chatCompletion = (assistantName, apiProvider)=>{
    return async (options)=>{
        (0, chat_1.validateChatOptions)(options);
        const api = await apiProvider.provideData();
        const messages = (0, chat_1.messagesValidation)(options);
        const model = (0, chat_1.modelValidation)(options);
        const request = {
            assistantName: assistantName,
            searchCompletions: {
                messages: messages,
                stream: false,
                model: model,
                filter: options.filter
            }
        };
        const retryWrapper = new utils_1.RetryOnServerFailure(()=>api.chatCompletionAssistant(request));
        return await retryWrapper.execute();
    };
};
exports.chatCompletion = chatCompletion; //# sourceMappingURL=chatCompletion.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chatStream = void 0;
const assistant_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const chat_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chat.js [app-route] (ecmascript)");
const chatStream = (assistantName, apiProvider, config)=>{
    return async (options)=>{
        const fetch = (0, utils_1.getFetch)(config);
        (0, chat_1.validateChatOptions)(options);
        const hostUrl = await apiProvider.provideHostUrl();
        const chatUrl = `${hostUrl}/chat/${assistantName}`;
        const requestHeaders = {
            'Api-Key': config.apiKey,
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': assistant_data_1.X_PINECONE_API_VERSION
        };
        // format context options
        let contextOptions = undefined;
        if (options.contextOptions?.topK || options.contextOptions?.snippetSize) {
            contextOptions = {
                top_k: options.contextOptions?.topK || options.topK,
                snippet_size: options.contextOptions?.snippetSize
            };
        } else if (options.topK) {
            contextOptions = {
                top_k: options.topK
            };
        }
        // we call the API directly via fetch, so we need to snake_case the keys (normally generated code handles this)
        const response = await fetch(chatUrl, {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify({
                messages: (0, chat_1.messagesValidation)(options),
                stream: true,
                model: (0, chat_1.modelValidation)(options),
                filter: options.filter,
                json_response: options.jsonResponse,
                include_highlights: options.includeHighlights,
                context_options: contextOptions
            })
        });
        if (response.ok && response.body) {
            const nodeReadable = node_stream_1.Readable.fromWeb(response.body);
            return new utils_1.ChatStream(nodeReadable);
        } else {
            const err = await (0, errors_1.handleApiError)(new assistant_data_1.ResponseError(response, 'Response returned an error'), undefined, chatUrl);
            throw err;
        }
    };
};
exports.chatStream = chatStream; //# sourceMappingURL=chatStream.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatCompletionStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chatCompletionStream = void 0;
const assistant_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const node_stream_1 = __turbopack_context__.r("[externals]/node:stream [external] (node:stream, cjs)");
const chat_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chat.js [app-route] (ecmascript)");
const chatCompletionStream = (assistantName, apiProvider, config)=>{
    return async (options)=>{
        const fetch = (0, utils_1.getFetch)(config);
        (0, chat_1.validateChatOptions)(options);
        const hostUrl = await apiProvider.provideHostUrl();
        const chatUrl = `${hostUrl}/chat/${assistantName}/chat/completions`;
        const requestHeaders = {
            'Api-Key': config.apiKey,
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': assistant_data_1.X_PINECONE_API_VERSION
        };
        const response = await fetch(chatUrl, {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify({
                messages: (0, chat_1.messagesValidation)(options),
                stream: true,
                model: (0, chat_1.modelValidation)(options),
                filter: options.filter
            })
        });
        if (response.ok && response.body) {
            const nodeReadable = node_stream_1.Readable.fromWeb(response.body);
            return new utils_1.ChatStream(nodeReadable);
        } else {
            const err = await (0, errors_1.handleApiError)(new assistant_data_1.ResponseError(response, 'Response returned an error'), undefined, chatUrl);
            throw err;
        }
    };
};
exports.chatCompletionStream = chatCompletionStream; //# sourceMappingURL=chatCompletionStream.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/listFiles.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.listFiles = void 0;
/**
 * Lists files (with optional filter) uploaded to an Assistant.
 *
 * @example
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone();
 * const assistantName = 'test1';
 * const assistant = pc.Assistant(assistantName);
 * const files = await assistant.listFiles({filter: {metadata: {key: 'value'}}});
 * console.log(files);
 * // {
 * //  files: [
 * //    {
 * //      name: 'test-file.txt',
 * //      id: '1a56ddd0-c6d8-4295-80c0-9bfd6f5cb87b',
 * //      metadata: [Object],
 * //      createdOn: 2025-01-06T19:14:21.969Z,
 * //      updatedOn: 2025-01-06T19:14:36.925Z,
 * //      status: 'Available',
 * //      percentDone: 1,
 * //      signedUrl: undefined,
 * //      errorMessage: undefined
 * //    }
 * //  ]
 * // }
 * ```
 * @param assistantName - The name of the Assistant that the files are uploaded to.
 * @param api - The API object to use to send the request.
 */ const listFiles = (assistantName, apiProvider)=>{
    return async (options)=>{
        const api = await apiProvider.provideData();
        const request = {
            assistantName: assistantName,
            filter: options.filter
        };
        return await api.listFiles(request);
    };
};
exports.listFiles = listFiles; //# sourceMappingURL=listFiles.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/describeFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.describeFile = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
/**
 * Describes a file uploaded to an Assistant.
 *
 * @example
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone();
 * const assistantName = 'test1';
 * const assistant = pc.Assistant(assistantName);
 * const files = await assistant.listFiles();
 * let fileId: string;
 * if (files.files) {
 *     fileId = files.files[0].id;
 * } else {
 *     fileId = '';
 * }
 * const resp = await assistant.describeFile({fileId: fileId})
 * console.log(resp);
 * // {
 * //  name: 'test-file.txt',
 * //  id: '1a56ddd0-c6d8-4295-80c0-9bfd6f5cb87b',
 * //  metadata: undefined,
 * //  createdOn: 2025-01-06T19:14:21.969Z,
 * //  updatedOn: 2025-01-06T19:14:36.925Z,
 * //  status: 'Available',
 * //  percentDone: 1,
 * //  signedUrl: undefined,
 * //   errorMessage: undefined
 * // }
 * ```
 *
 * @param assistantName - The name of the Assistant that the file is uploaded to.
 * @param api - The API object to use to send the request.
 * @returns A promise that resolves to a {@link AssistantFile} object containing the file details.
 */ const describeFile = (assistantName, apiProvider)=>{
    return async (fileId, includeUrl)=>{
        if (!fileId) {
            throw new errors_1.PineconeArgumentError('You must pass the fileId of a file to describe.');
        }
        const api = await apiProvider.provideData();
        const request = {
            assistantName: assistantName,
            assistantFileId: fileId,
            includeUrl: includeUrl.toString()
        };
        return await api.describeFile(request);
    };
};
exports.describeFile = describeFile; //# sourceMappingURL=describeFile.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/deleteFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.deleteFile = void 0;
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
/**
 * Deletes a file uploaded to an Assistant by ID.
 *
 * @example
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone();
 * const assistantName = 'test1';
 * const assistant = pc.Assistant(assistantName);
 * const files = await assistant.listFiles();
 * let fileId: string;
 * if (files.files) {
 *    fileId = files.files[0].id;
 *    await assistant.deleteFile({fileId: fileId});
 *  }
 * ```
 *
 * @param assistantName - The name of the Assistant to delete the file from.
 * @param api - The Pinecone API object.
 */ const deleteFile = (assistantName, apiProvider)=>{
    return async (fileId)=>{
        if (!fileId) {
            throw new errors_1.PineconeArgumentError('You must pass the fileId of a file to delete.');
        }
        const api = await apiProvider.provideData();
        const request = {
            assistantName: assistantName,
            assistantFileId: fileId
        };
        return await api.deleteFile(request);
    };
};
exports.deleteFile = deleteFile; //# sourceMappingURL=deleteFile.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/uploadFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uploadFile = void 0;
const assistant_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const fs_1 = __importDefault(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
const uploadFile = (assistantName, apiProvider, config)=>{
    return async (options)=>{
        const fetch = (0, utils_1.getFetch)(config);
        validateUploadFileOptions(options);
        const fileBuffer = fs_1.default.readFileSync(options.path);
        const fileName = path_1.default.basename(options.path);
        const mimeType = getMimeType(fileName);
        const fileBlob = new Blob([
            fileBuffer
        ], {
            type: mimeType
        });
        const formData = new FormData();
        formData.append('file', fileBlob, fileName);
        const hostUrl = await apiProvider.provideHostUrl();
        let filesUrl = `${hostUrl}/files/${assistantName}`;
        const requestHeaders = {
            'Api-Key': config.apiKey,
            'User-Agent': (0, utils_1.buildUserAgent)(config),
            'X-Pinecone-Api-Version': assistant_data_1.X_PINECONE_API_VERSION
        };
        if (options.metadata) {
            const encodedMetadata = encodeURIComponent(JSON.stringify(options.metadata));
            filesUrl += `?metadata=${encodedMetadata}`;
        }
        const response = await fetch(filesUrl, {
            method: 'POST',
            headers: requestHeaders,
            body: formData
        });
        if (response.ok) {
            const assistantFileModel = new assistant_data_1.JSONApiResponse(response, (jsonValue)=>(0, assistant_data_1.AssistantFileModelFromJSON)(jsonValue)).value();
            return assistantFileModel;
        } else {
            const err = await (0, errors_1.handleApiError)(new assistant_data_1.ResponseError(response, 'Response returned an error'), undefined, filesUrl);
            throw err;
        }
    };
};
exports.uploadFile = uploadFile;
const validateUploadFileOptions = (options)=>{
    if (!options || !options.path) {
        throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`path`) to upload a file.');
    }
};
// get mime types for accepted file types
function getMimeType(filePath) {
    const extensionToMimeType = {
        pdf: 'application/pdf',
        json: 'application/json',
        txt: 'text/plain',
        md: 'text/markdown',
        docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    };
    // Extract file extension and ensure it's lowercase
    const parts = filePath.split('.');
    if (parts.length < 2) {
        return 'application/octet-stream'; // Default for files without extensions
    }
    const ext = parts.pop();
    const extension = ext ? ext.toLowerCase() : '';
    // Return the MIME type or a default value for unsupported types
    return extensionToMimeType[extension];
} //# sourceMappingURL=uploadFile.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/asstDataOperationsProvider.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AsstDataOperationsProvider = void 0;
const assistant_data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/assistant_data/index.js [app-route] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/index.js [app-route] (ecmascript)");
const middleware_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/middleware.js [app-route] (ecmascript)");
const assistantHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/assistantHostSingleton.js [app-route] (ecmascript)");
class AsstDataOperationsProvider {
    constructor(config, asstName, asstHostUrl, additionalHeaders){
        this.config = config;
        this.asstName = asstName;
        this.asstHostUrl = (0, utils_1.normalizeUrl)(asstHostUrl);
        this.additionalHeaders = additionalHeaders;
    }
    async provideData() {
        if (this.asstDataOperations) {
            return this.asstDataOperations;
        } else {
            this.asstHostUrl = await assistantHostSingleton_1.AssistantHostSingleton.getHostUrl(this.config, this.asstName);
            this.asstDataOperations = this.buildAsstDataOperationsConfig();
        }
        return this.asstDataOperations;
    }
    async provideHostUrl() {
        if (this.asstHostUrl) {
            return this.asstHostUrl;
        } else {
            this.asstHostUrl = await assistantHostSingleton_1.AssistantHostSingleton.getHostUrl(this.config, this.asstName);
        }
        return this.asstHostUrl;
    }
    buildAsstDataOperationsConfig() {
        const { apiKey } = this.config;
        const hostUrl = this.asstHostUrl;
        const headers = this.additionalHeaders || null;
        const apiConfig = {
            basePath: hostUrl,
            apiKey,
            queryParamsStringify: utils_1.queryParamsStringify,
            headers: {
                'User-Agent': (0, utils_1.buildUserAgent)(this.config),
                'X-Pinecone-Api-Version': assistant_data_1.X_PINECONE_API_VERSION,
                ...headers
            },
            fetchApi: (0, utils_1.getFetch)(this.config),
            middleware: middleware_1.middleware
        };
        return new assistant_data_1.ManageAssistantsApi(new assistant_data_1.Configuration(apiConfig));
    }
}
exports.AsstDataOperationsProvider = AsstDataOperationsProvider; //# sourceMappingURL=asstDataOperationsProvider.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/context.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.context = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/types.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
/**
 * Retrieves [the context snippets](https://docs.pinecone.io/guides/assistant/understanding-context-snippets) used
 * by an Assistant during the retrieval process.
 *
 * @example
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 * const pc = new Pinecone();
 * const assistantName = 'test1';
 * const assistant = pc.Assistant(assistantName);
 * const response = await assistant.context({query: "What is the capital of France?"});
 * console.log(response);
 * // {
 * //  snippets: [
 * //    {
 * //      type: 'text',
 * //      content: 'The capital of France is Paris.',
 * //      score: 0.9978925,
 * //      reference: [Object]
 * //    },
 * //  ],
 * //  usage: { promptTokens: 527, completionTokens: 0, totalTokens: 527 }
 * // }
 * ```
 *
 * @param assistantName - The name of the Assistant to retrieve the context snippets from.
 * @param api - The Pinecone API object.
 * @throws An error if a query is not provided.
 * @returns A promise that resolves to a {@link ContextModel} object containing the context snippets.
 */ const context = (assistantName, apiProvider)=>{
    return async (options)=>{
        validateContextOptions(options);
        const api = await apiProvider.provideData();
        const request = {
            assistantName: assistantName,
            contextRequest: {
                query: options.query,
                filter: options.filter,
                messages: options.messages,
                topK: options.topK,
                snippetSize: options.snippetSize
            }
        };
        return await api.contextAssistant(request);
    };
};
exports.context = context;
const validateContextOptions = (options)=>{
    if (!options || !options.query && !options.messages) {
        throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`query`, or `messages`) to retrieve context snippets.');
    }
    (0, validateObjectProperties_1.ValidateObjectProperties)(options, types_1.ContextOptionsType);
}; //# sourceMappingURL=context.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/assistant/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Assistant = exports.ChatStream = void 0;
const chat_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chat.js [app-route] (ecmascript)");
const chatCompletion_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatCompletion.js [app-route] (ecmascript)");
const chatStream_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatStream.js [app-route] (ecmascript)");
const chatCompletionStream_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/chatCompletionStream.js [app-route] (ecmascript)");
const listFiles_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/listFiles.js [app-route] (ecmascript)");
const describeFile_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/describeFile.js [app-route] (ecmascript)");
const deleteFile_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/deleteFile.js [app-route] (ecmascript)");
const uploadFile_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/uploadFile.js [app-route] (ecmascript)");
const asstDataOperationsProvider_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/asstDataOperationsProvider.js [app-route] (ecmascript)");
const context_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/data/context.js [app-route] (ecmascript)");
var chatStream_2 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/chatStream.js [app-route] (ecmascript)");
Object.defineProperty(exports, "ChatStream", {
    enumerable: true,
    get: function() {
        return chatStream_2.ChatStream;
    }
});
/**
 * The `Assistant` class holds the data plane methods for interacting with
 *  [Assistants](https://docs.pinecone.io/guides/assistant/understanding-assistant).
 *
 *  This class can be instantiated through a {@link Pinecone} object, and is used to interact with a specific assistant.
 *
 *  @example
 *  ```typescript
 *  import { Pinecone } from '@pinecone-database/pinecone';
 *  const pc = new Pinecone();
 *  const assistant = pc.assistant('assistant-name');
 *  ```
 */ class Assistant {
    /**
     * Creates an instance of the `Assistant` class.
     *
     * @param assistantName - The name of the assistant.
     * @param config - The Pinecone configuration object containing an API key and other configuration parameters
     * needed for API calls.
     *
     * @throws An error if no assistant name is provided.
     */ constructor(assistantName, config){
        if (!assistantName) {
            throw new Error('No assistant name provided');
        }
        this.config = config;
        const asstDataOperationsProvider = new asstDataOperationsProvider_1.AsstDataOperationsProvider(this.config, assistantName);
        this.assistantName = assistantName;
        this._chat = (0, chat_1.chat)(this.assistantName, asstDataOperationsProvider);
        this._chatStream = (0, chatStream_1.chatStream)(this.assistantName, asstDataOperationsProvider, this.config);
        this._chatCompletion = (0, chatCompletion_1.chatCompletion)(this.assistantName, asstDataOperationsProvider);
        this._chatCompletionStream = (0, chatCompletionStream_1.chatCompletionStream)(this.assistantName, asstDataOperationsProvider, this.config);
        this._listFiles = (0, listFiles_1.listFiles)(this.assistantName, asstDataOperationsProvider);
        this._describeFile = (0, describeFile_1.describeFile)(this.assistantName, asstDataOperationsProvider);
        this._uploadFile = (0, uploadFile_1.uploadFile)(this.assistantName, asstDataOperationsProvider, this.config);
        this._deleteFile = (0, deleteFile_1.deleteFile)(this.assistantName, asstDataOperationsProvider);
        this._context = (0, context_1.context)(this.assistantName, asstDataOperationsProvider);
    }
    // --------- Chat methods ---------
    /**
     * Sends a message to the assistant and receives a response. Retries the request if the server fails.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const chatResp = await assistant.chat({messages: [{role: 'user', content: "What is the capital of France?"}]});
     * // {
     * //  id: '000000000000000023e7fb015be9d0ad',
     * //  finishReason: 'stop',
     * //  message: {
     * //    role: 'assistant',
     * //    content: 'The capital of France is Paris.'
     * //  },
     * //  model: 'gpt-4o-2024-05-13',
     * //  citations: [ { position: 209, references: [Array] } ],
     * //  usage: { promptTokens: 493, completionTokens: 38, totalTokens: 531 }
     * // }
     * ```
     *
     * @param options - A {@link ChatOptions} object containing the message and optional parameters to send to the
     * assistant.
     * @returns A promise that resolves to a {@link ChatModel} object containing the response from the assistant.
     */ chat(options) {
        return this._chat(options);
    }
    /**
     * Sends a message to the assistant and receives a streamed response as {@link ChatStream<StreamedChatResponse>}. Retries the request if the server fails.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const chatStream = await assistant.chatStream({ messages: [{ role: 'user', content: 'What is the capital of France?'}]});
     *
     * // stream the response and log each chunk
     * for await (const chunk of newStream) {
     *   console.log(chunk);
     * }
     * // each chunk will have a variable shape depending on the type:
     * // { type:"message_start", id:"response_id", model:"gpt-4o-2024-05-13", role:"assistant"}
     * // { type:"content_chunk", id:"response_id", model:"gpt-4o-2024-05-13", delta:{ content:"The"}}
     * // { type:"content_chunk", id:"response_id", model:"gpt-4o-2024-05-13", delta:{ content:" test"}}
     * // { type:"message_end", id:"response_id", model:"gpt-4o-2024-05-13", finishReason:"stop",usage:{ promptTokens:371,completionTokens:48,totalTokens:419}}
     * ```
     *
     * @param options - A {@link ChatOptions} object containing the message and optional parameters to send to the
     * assistant.
     * @returns A promise that resolves to a {@link ChatStream<StreamedChatResponse>}.
     */ chatStream(options) {
        return this._chatStream(options);
    }
    /**
     * Sends a message to the assistant and receives a response that is compatible with
     * [OpenAI's Chat Completion API](https://platform.openai.com/docs/guides/text-generation. Retries the request if the server fails.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const chatCompletion = await assistant.chatCompletion({ messages: [{ role: 'user', content: 'What is the capital of France?' }]});
     * console.log(chatCompletion);
     * // {
     * //  id: "response_id",
     * //  choices: [
     * //  {
     * //    finishReason: "stop",
     * //    index: 0,
     * //    message: {
     * //      role: "assistant",
     * //      content: "The data mentioned is described as \"some temporary data\"  [1].\n\nReferences:\n1. [test-chat.txt](https://storage.googleapis.com/knowledge-prod-files/your_file_resource) \n"
     * //    }
     * //   }
     * //  ],
     * //  model: "gpt-4o-2024-05-13",
     * //  usage: {
     * //    promptTokens: 371,
     * //    completionTokens: 19,
     * //    totalTokens: 390
     * //  }
     * // }
     * ```
     *
     * @param options - A {@link ChatCompletionOptions} object containing the message and optional parameters to send
     * to an assistant.
     * @returns A promise that resolves to a {@link ChatCompletionModel} object containing the response from the assistant.
     */ chatCompletion(options) {
        return this._chatCompletion(options);
    }
    /**
     * Sends a message to the assistant and receives a streamed response as {@link ChatStream<StreamedChatCompletionResponse>}. Response is compatible with
     * [OpenAI's Chat Completion API](https://platform.openai.com/docs/guides/text-generation. Retries the request if the server fails.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const chatStream = await assistant.chatCompletionStream({messages: [{role: 'user', content: "What is the capital of France?"}]});
     *
     * // stream the response and log each chunk
     * for await (const chunk of newStream) {
     *   if (chunk.choices.length > 0 && chunk.choices[0].delta.content) {
     *     process.stdout.write(chunk.choices[0].delta.content);
     *   }
     * }
     * // { id: 'response_id', choices: [{ index: 0, delta: { role: 'assistant' }, finishReason: null }], model: 'gpt-4o-2024-05-13', usage: null }
     * // { id: 'response_id', choices: [{ index: 0, delta: { content: 'The' }}, finishReason: null }], model: 'gpt-4o-2024-05-13', usage: null }
     * // { id: 'response_id', choices: [{ index: 0, delta: { content: ' test' }}, finishReason: null }], model: 'gpt-4o-2024-05-13', usage: null }
     * // { id: 'response_id', choices: [], model: 'gpt-4o-2024-05-13', usage: { promptTokens: 371, completionTokens: 48, totalTokens: 419 }}
     * ```
     *
     * @param options - A {@link ChatCompletionOptions} object containing the message and optional parameters to send
     * to an assistant.
     * @returns A promise that resolves to a {@link ChatStream<StreamedChatCompletionResponse>}.
     */ chatCompletionStream(options) {
        return this._chatCompletionStream(options);
    }
    // --------- File methods ---------
    /**
     * Lists files (with optional filter) uploaded to an assistant.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const files = await assistant.listFiles({filter: {metadata: {key: 'value'}}});
     * console.log(files);
     * // {
     * //  files: [
     * //    {
     * //      name: 'temp-file.txt',
     * //      id: '1a56ddd0-c6d8-4295-80c0-9bfd6f5cb87b',
     * //      metadata: undefined,
     * //      createdOn: 2025-01-06T19:14:21.969Z,
     * //      updatedOn: 2025-01-06T19:14:36.925Z,
     * //      status: 'Available',
     * //      percentDone: 1,
     * //      signedUrl: undefined,
     * //      errorMessage: undefined
     * //    }
     * //  ]
     * // }
     * ```
     *
     * @param options - A {@link ListFilesOptions} object containing optional parameters to filter the list of files.
     * @returns A promise that resolves to a {@link AssistantFilesList} object containing a list of files.
     */ listFiles(options) {
        if (!options) {
            options = {};
        }
        return this._listFiles(options);
    }
    /**
     * Describes a file uploaded to an assistant.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const files = await assistant.listFiles();
     * let fileId: string;
     * if (files.files) {
     *     fileId = files.files[0].id;
     * } else {
     *     fileId = '';
     * }
     * const resp = await assistant.describeFile({fileId: fileId})
     * console.log(resp);
     * // {
     * //  name: 'test-file.txt',
     * //  id: '1a56ddd0-c6d8-4295-80c0-9bfd6f5cb87b',
     * //  metadata: undefined,
     * //  createdOn: 2025-01-06T19:14:21.969Z,
     * //  updatedOn: 2025-01-06T19:14:36.925Z,
     * //  status: 'Available',
     * //  percentDone: 1,
     * //  signedUrl: undefined,
     * //   errorMessage: undefined
     * // }
     * ```
     *
     * @param fileId - The ID of the file to describe.
     * @param includeUrl - Whether to include the signed URL in the response. Defaults to true.
     * @returns A promise that resolves to a {@link AssistantFileModel} object containing the file details.
     */ describeFile(fileId, includeUrl = true) {
        return this._describeFile(fileId, includeUrl);
    }
    /**
     * Uploads a file to an assistant.
     *
     * Note: This method does *not* use the generated code from the OpenAPI spec.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * await assistant.uploadFile({path: "test-file.txt", metadata: {"test-key": "test-value"}})
     * // {
     * //  name: 'test-file.txt',
     * //  id: '921ad74c-2421-413a-8c86-fca81ceabc5c',
     * //  metadata: { 'test-key': 'test-value' },
     * //  createdOn: Invalid Date,  // Note: these dates resolve in seconds
     * //  updatedOn: Invalid Date,
     * //  status: 'Processing',
     * //  percentDone: null,
     * //  signedUrl: null,
     * //  errorMessage: null
     * // }
     * ```
     *
     * @param options - A {@link UploadFile} object containing the file path and optional metadata.
     * @returns A promise that resolves to a {@link AssistantFileModel} object containing the file details.
     */ uploadFile(options) {
        return this._uploadFile(options);
    }
    /**
     * Deletes a file uploaded to an assistant by ID.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const files = await assistant.listFiles();
     * let fileId: string;
     * if (files.files) {
     *    fileId = files.files[0].id;
     *    await assistant.deleteFile({fileId: fileId});
     *  }
     * ```
     *
     * @param options - A {@link DeleteFile} object containing the file ID to delete.
     * @returns A promise that resolves to void on success.
     */ deleteFile(fileId) {
        return this._deleteFile(fileId);
    }
    /**
     * Retrieves [the context snippets](https://docs.pinecone.io/guides/assistant/understanding-context-snippets) used
     * by an assistant during the retrieval process.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistantName = 'test1';
     * const assistant = pc.assistant(assistantName);
     * const response = await assistant.context({query: "What is the capital of France?"});
     * console.log(response);
     * // {
     * //  snippets: [
     * //    {
     * //      type: 'text',
     * //      content: 'The capital of France is Paris.',
     * //      score: 0.9978925,
     * //      reference: [Object]
     * //    },
     * //  ],
     * //  usage: { promptTokens: 527, completionTokens: 0, totalTokens: 527 }
     * // }
     * ```
     *
     * @param options
     * @returns A promise that resolves to a {@link Context} object containing the context snippets.
     */ context(options) {
        return this._context(options);
    }
}
exports.Assistant = Assistant; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/pinecone.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pinecone = void 0;
const control_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/control/index.js [app-route] (ecmascript)");
const control_2 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/index.js [app-route] (ecmascript)");
const assistantHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/assistantHostSingleton.js [app-route] (ecmascript)");
const indexHostSingleton_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js [app-route] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)");
const data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/index.js [app-route] (ecmascript)");
const inference_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/index.js [app-route] (ecmascript)");
const environment_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/environment.js [app-route] (ecmascript)");
const validateObjectProperties_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/utils/validateObjectProperties.js [app-route] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/vectors/types.js [app-route] (ecmascript)");
const asstControlOperationsBuilder_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/control/asstControlOperationsBuilder.js [app-route] (ecmascript)");
const assistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/index.js [app-route] (ecmascript)");
/**
 * The `Pinecone` class is the main entrypoint to this sdk. You will use
 * instances of it to create and manage indexes as well as perform data
 * operations on those indexes after they are created.
 *
 * ### Initializing the client
 *
 * There is one piece of configuration required to use the Pinecone client: an API key. This value can be passed using environment variables or in code through a configuration object. Find your API key in the console dashboard at [https://app.pinecone.io](https://app.pinecone.io)
 *
 * ### Using environment variables
 *
 * The environment variables used to configure the client are the following:
 *
 * ```bash
 * export PINECONE_API_KEY="your_api_key"
 * export PINECONE_CONTROLLER_HOST="your_controller_host"
 * ```
 *
 * When these environment variables are set, the client constructor does not require any additional arguments.
 *
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 *
 * const pc = new Pinecone();
 * ```
 *
 * ### Using a configuration object
 *
 * If you prefer to pass configuration in code, the constructor accepts a config object containing the `apiKey` and `environment` values. This
 * could be useful if your application needs to interact with multiple projects, each with a different configuration.
 *
 * ```typescript
 * import { Pinecone } from '@pinecone-database/pinecone';
 *
 * const pc = new Pinecone({
 *   apiKey: 'your_api_key',
 * });
 *
 * ```
 *
 * See {@link PineconeConfiguration} for a full description of available configuration options.
 */ class Pinecone {
    /**
     * @example
     * ```
     * import { Pinecone } from '@pinecone-database/pinecone';
     *
     * const pc = new Pinecone({
     *  apiKey: 'my-api-key',
     * });
     * ```
     *
     * @constructor
     * @param options - The configuration options for the Pinecone client: {@link PineconeConfiguration}.
     */ constructor(options){
        if (options === undefined) {
            options = this._readEnvironmentConfig();
        }
        if (!options.apiKey) {
            throw new errors_1.PineconeConfigurationError('The client configuration must have required property: apiKey.');
        }
        (0, validateObjectProperties_1.ValidateObjectProperties)(options, types_1.PineconeConfigurationProperties);
        this.config = options;
        this._checkForBrowser();
        const api = (0, control_1.indexOperationsBuilder)(this.config);
        const asstControlApi = (0, asstControlOperationsBuilder_1.asstControlOperationsBuilder)(this.config);
        this._configureIndex = (0, control_1.configureIndex)(api);
        this._createCollection = (0, control_1.createCollection)(api);
        this._createIndex = (0, control_1.createIndex)(api);
        this._createIndexForModel = (0, control_1.createIndexForModel)(api);
        this._describeCollection = (0, control_1.describeCollection)(api);
        this._deleteCollection = (0, control_1.deleteCollection)(api);
        this._describeIndex = (0, control_1.describeIndex)(api);
        this._deleteIndex = (0, control_1.deleteIndex)(api);
        this._listCollections = (0, control_1.listCollections)(api);
        this._listIndexes = (0, control_1.listIndexes)(api);
        this._createAssistant = (0, control_2.createAssistant)(asstControlApi);
        this._deleteAssistant = (0, control_2.deleteAssistant)(asstControlApi);
        this._updateAssistant = (0, control_2.updateAssistant)(asstControlApi);
        this._describeAssistant = (0, control_2.describeAssistant)(asstControlApi);
        this._listAssistants = (0, control_2.listAssistants)(asstControlApi);
        this._createBackup = (0, control_1.createBackup)(api);
        this._createIndexFromBackup = (0, control_1.createIndexFromBackup)(api);
        this._describeBackup = (0, control_1.describeBackup)(api);
        this._describeRestoreJob = (0, control_1.describeRestoreJob)(api);
        this._deleteBackup = (0, control_1.deleteBackup)(api);
        this._listBackups = (0, control_1.listBackups)(api);
        this._listRestoreJobs = (0, control_1.listRestoreJobs)(api);
        this.inference = new inference_1.Inference(this.config);
    }
    /**
     * @internal
     * This method is used by {@link Pinecone.constructor} to read configuration from environment variables.
     *
     * It looks for the following environment variables:
     * - `PINECONE_API_KEY`
     * - `PINECONE_CONTROLLER_HOST`
     *
     * @returns A {@link PineconeConfiguration} object populated with values found in environment variables.
     */ _readEnvironmentConfig() {
        if (typeof process === 'undefined' || !process || !process.env) {
            throw new errors_1.PineconeEnvironmentVarsNotSupportedError('Your execution environment does not support reading environment variables from process.env, so a' + ' configuration object is required when calling new Pinecone().');
        }
        const environmentConfig = {};
        const requiredEnvVarMap = {
            apiKey: 'PINECONE_API_KEY'
        };
        const missingVars = [];
        for (const [key, envVar] of Object.entries(requiredEnvVarMap)){
            const value = process.env[envVar] || '';
            if (!value) {
                missingVars.push(envVar);
            }
            environmentConfig[key] = value;
        }
        if (missingVars.length > 0) {
            throw new errors_1.PineconeConfigurationError(`Since you called 'new Pinecone()' with no configuration object, we attempted to find client configuration in environment variables but the required environment variables were not set. Missing variables: ${missingVars.join(', ')}.`);
        }
        const optionalEnvVarMap = {
            controllerHostUrl: 'PINECONE_CONTROLLER_HOST'
        };
        for (const [key, envVar] of Object.entries(optionalEnvVarMap)){
            const value = process.env[envVar];
            if (value !== undefined) {
                environmentConfig[key] = value;
            }
        }
        return environmentConfig;
    }
    /**
     * Describe a Pinecone index
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const indexModel = await pc.describeIndex('my-index')
     * console.log(indexModel)
     * // {
     * //     name: 'sample-index-1',
     * //     dimension: 3,
     * //     metric: 'cosine',
     * //     host: 'sample-index-1-1390950.svc.apw5-4e34-81fa.pinecone.io',
     * //     spec: {
     * //           pod: undefined,
     * //           serverless: {
     * //               cloud: 'aws',
     * //               region: 'us-west-2'
     * //           }
     * //     },
     * //     status: {
     * //           ready: true,
     * //           state: 'Ready'
     * //     }
     * // }
     * ```
     *
     * @param indexName - The name of the index to describe.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves to {@link IndexModel}.
     */ async describeIndex(indexName) {
        const indexModel = await this._describeIndex(indexName);
        // For any describeIndex calls we want to update the IndexHostSingleton cache.
        // This prevents unneeded calls to describeIndex for resolving the host for vector operations.
        if (indexModel.host) {
            indexHostSingleton_1.IndexHostSingleton._set(this.config, indexName, indexModel.host);
        }
        return Promise.resolve(indexModel);
    }
    /**
     * List all Pinecone indexes
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const indexList = await pc.listIndexes()
     * console.log(indexList)
     * // {
     * //     indexes: [
     * //       {
     * //         name: "sample-index-1",
     * //         dimension: 3,
     * //         metric: "cosine",
     * //         host: "sample-index-1-1234567.svc.apw5-2e18-32fa.pinecone.io",
     * //         spec: {
     * //           serverless: {
     * //             cloud: "aws",
     * //             region: "us-west-2"
     * //           }
     * //         },
     * //         status: {
     * //           ready: true,
     * //           state: "Ready"
     * //         }
     * //       },
     * //       {
     * //         name: "sample-index-2",
     * //         dimension: 3,
     * //         metric: "cosine",
     * //         host: "sample-index-2-1234567.svc.apw2-5e76-83fa.pinecone.io",
     * //         spec: {
     * //           serverless: {
     * //             cloud: "aws",
     * //             region: "us-west-2"
     * //           }
     * //         },
     * //         status: {
     * //           ready: true,
     * //           state: "Ready"
     * //         }
     * //       }
     * //     ]
     * //   }
     * ```
     *
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves to {@link IndexList}.
     */ async listIndexes() {
        const indexList = await this._listIndexes();
        // For any listIndexes calls we want to update the IndexHostSingleton cache.
        // This prevents unneeded calls to describeIndex for resolving the host for index operations.
        if (indexList.indexes && indexList.indexes.length > 0) {
            for(let i = 0; i < indexList.indexes.length; i++){
                const index = indexList.indexes[i];
                indexHostSingleton_1.IndexHostSingleton._set(this.config, index.name, index.host);
            }
        }
        return Promise.resolve(indexList);
    }
    /**
     * Creates a new index.
     *
     * @example
     * The minimum required configuration to create an index is the index `name`, `dimension`, and `spec`.
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     *
     * const pc = new Pinecone();
     *
     * await pc.createIndex({ name: 'my-index', dimension: 128, spec: { serverless: { cloud: 'aws', region: 'us-west-2' }}})
     * ```
     *
     * @example
     * The `spec` object defines how the index should be deployed. For serverless indexes, you define only the cloud and region where the index should be hosted.
     * For pod-based indexes, you define the environment where the index should be hosted, the pod type and size to use, and other index characteristics.
     * In a different example, you can create a pod-based index by specifying the `pod` spec object with the `environment`, `pods`, `podType`, and `metric` properties.
     * For more information on creating indexes, see [Understanding indexes](https://docs.pinecone.io/guides/indexes/understanding-indexes).
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.createIndex({
     *  name: 'my-index',
     *  dimension: 1536,
     *  metric: 'cosine',
     *  spec: {
     *    pod: {
     *      environment: 'us-west-2-gcp',
     *      pods: 1,
     *      podType: 'p1.x1'
     *    }
     *   },
     *  tags: { 'team': 'data-science' }
     * })
     * ```
     *
     * @example
     * If you would like to create the index only if it does not already exist, you can use the `suppressConflicts` boolean option.
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.createIndex({
     *   name: 'my-index',
     *   dimension: 1536,
     *   spec: {
     *     serverless: {
     *       cloud: 'aws',
     *       region: 'us-west-2'
     *     }
     *   },
     *   suppressConflicts: true,
     *   tags: { 'team': 'data-science' }
     * })
     * ```
     *
     * @example
     * If you plan to begin upserting immediately after index creation is complete, you should use the `waitUntilReady` option. Otherwise, the index may not be ready to receive data operations when you attempt to upsert.
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.createIndex({
     *  name: 'my-index',
     *   spec: {
     *     serverless: {
     *       cloud: 'aws',
     *       region: 'us-west-2'
     *     }
     *   },
     *  waitUntilReady: true,
     *  tags: { 'team': 'data-science' }
     * });
     *
     * const records = [
     *   // PineconeRecord objects with your embedding values
     * ]
     * await pc.index('my-index').upsert(records)
     * ```
     *
     * @example
     * By default all metadata fields are indexed when records are upserted with metadata, but if you want to improve performance you can specify the specific fields you want to index. This example is showing a few hypothetical metadata fields, but the values you'd use depend on what metadata you plan to store with records in your Pinecone index.
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.createIndex({
     *   name: 'my-index',
     *   dimension: 1536,
     *   spec: {
     *     serverless: {
     *       cloud: 'aws',
     *       region: 'us-west-2',
     *       metadataConfig: { 'indexed' : ['productName', 'productDescription'] }
     *     }
     *   },
     *  tags: { 'team': 'data-science' }
     * })
     * ```
     *
     * @param options - The {@link CreateIndexOptions} for creating the index.
     * @see [Distance metrics](https://docs.pinecone.io/docs/indexes#distance-metrics)
     * @see [Pod types and sizes](https://docs.pinecone.io/docs/indexes#pods-pod-types-and-pod-sizes)
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeBadRequestError} when index creation fails due to invalid parameters being specified or other problem such as project quotas limiting the creation of any additional indexes.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @throws {@link Errors.PineconeConflictError} when attempting to create an index using a name that already exists in your project.
     * @returns A promise that resolves to {@link IndexModel} when the request to create the index is completed. Note that the index is not immediately ready to use. You can use the {@link describeIndex} function to check the status of the index.
     */ createIndex(options) {
        return this._createIndex(options);
    }
    /**
     * Creates a new integrated index which allows working with integrated inference capabilities.
     * @see [Upsert and search with integrated inference](https://docs.pinecone.io/guides/inference/integrated-inference)
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.createIndexForModel({
     *   name: 'integrated-index',
     *   cloud: 'aws',
     *   region: 'us-east-1',
     *   embed: {
     *     model: 'multilingual-e5-large',
     *     fieldMap: { text: 'chunk_text' },
     *   },
     *   waitUntilReady: true,
     * });
     * ```
     *
     * @param options - The {@link CreateIndexForModelOptions} for creating the index.
     * @see [Distance metrics](https://docs.pinecone.io/docs/indexes#distance-metrics)
     * @see [Pod types and sizes](https://docs.pinecone.io/docs/indexes#pods-pod-types-and-pod-sizes)
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeBadRequestError} when index creation fails due to invalid parameters being specified or other problem such as project quotas limiting the creation of any additional indexes.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @throws {@link Errors.PineconeConflictError} when attempting to create an index using a name that already exists in your project.
     * @returns A promise that resolves to {@link IndexModel} when the request to create the index is completed. Note that the index is not immediately ready to use. You can use the {@link describeIndex} function to check the status of the index.
     */ createIndexForModel(options) {
        return this._createIndexForModel(options);
    }
    /**
     * Deletes an index
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.deleteIndex('my-index')
     * ```
     *
     * @param indexName - The name of the index to delete.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @returns A promise that resolves when the request to delete the index is completed.
     */ async deleteIndex(indexName) {
        await this._deleteIndex(indexName);
        // When an index is deleted, we need to evict the host from the IndexHostSingleton cache.
        indexHostSingleton_1.IndexHostSingleton._delete(this.config, indexName);
        return Promise.resolve();
    }
    /**
     * Configure an index
     *
     * Use this method to update configuration on an existing index. For both pod-based and serverless indexes you can update
     * the deletionProtection status of an index and/or change any index tags. For pod-based index you can also
     * configure the number of replicas and pod type.
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.configureIndex('my-index', {
     *   deletionProtection: 'enabled',
     *   spec:{ pod:{ replicas: 2, podType: 'p1.x2' }},
     * });
     * ```
     *
     * @param indexName - The name of the index to configure.
     * @param options - The configuration properties you would like to update
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves to {@link IndexModel} when the request to configure the index is completed.
     */ configureIndex(indexName, options) {
        return this._configureIndex(indexName, options, this.config.maxRetries);
    }
    /**
     * Create a new collection from an existing index
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const indexList = await pc.listIndexes()
     * const indexName = indexList.indexes[0].name;
     * await pc.createCollection({
     *  name: 'my-collection',
     *  source: indexName
     * })
     * ```
     *
     * @param options - The collection configuration.
     * @param options.name - The name of the collection. Must be unique within the project and contain alphanumeric and hyphen characters. The name must start and end with alphanumeric characters.
     * @param options.source - The name of the index to use as the source for the collection.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns a promise that resolves to {@link CollectionModel} when the request to create the collection is completed.
     */ createCollection(options) {
        return this._createCollection(options);
    }
    /**
     * List all collections in a project
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.listCollections()
     * ```
     *
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves to {@link CollectionList}.
     */ listCollections() {
        return this._listCollections();
    }
    /**
     * Delete a collection by collection name
     *
     * @example
     * ```
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * const collectionList = await pc.listCollections()
     * const collectionName = collectionList.collections[0].name;
     * await pc.deleteCollection(collectionName)
     * ```
     *
     * @param collectionName - The name of the collection to delete.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves when the request to delete the collection is completed.
     */ deleteCollection(collectionName) {
        return this._deleteCollection(collectionName);
    }
    /**
     * Describe a collection
     *
     * @example
     * ```js
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     *
     * await pc.describeCollection('my-collection')
     * ```
     *
     * @param collectionName - The name of the collection to describe.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A promise that resolves to a {@link CollectionModel}.
     */ describeCollection(collectionName) {
        return this._describeCollection(collectionName);
    }
    /**
     * Creates a new Assistant.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * await pc.createAssistant({name: 'test1'});
     * // {
     * //  name: 'test11',
     * //  instructions: undefined,
     * //  metadata: undefined,
     * //  status: 'Initializing',
     * //  host: 'https://prod-1-data.ke.pinecone.io',
     * //  createdAt: 2025-01-08T22:52:49.652Z,
     * //  updatedAt: 2025-01-08T22:52:49.652Z
     * // }
     * ```
     *
     * @param options - A {@link CreateAssistantOptions} object containing the `name` of the Assistant to be created.
     * Optionally, users can also specify instructions, metadata, and host region. Region must be one of "us" or "eu"
     * and determines where the Assistant will be hosted.
     * @throws Error if the Assistant API is not initialized.
     * @throws Error if an invalid region is provided.
     * @returns A Promise that resolves to an {@link Assistant} model.
     */ async createAssistant(options) {
        const assistant = await this._createAssistant(options);
        if (assistant.host) {
            assistantHostSingleton_1.AssistantHostSingleton._set(this.config, assistant.name, assistant.host);
        }
        return Promise.resolve(assistant);
    }
    /**
     * Deletes an Assistant by name.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * await pc.deleteAssistant('test1');
     * ```
     *
     * @param assistantName - The name of the Assistant to be deleted.
     * @throws Error if the Assistant API is not initialized.
     */ async deleteAssistant(assistantName) {
        await this._deleteAssistant(assistantName);
        assistantHostSingleton_1.AssistantHostSingleton._delete(this.config, assistantName);
        return Promise.resolve();
    }
    /**
     * Retrieves information about an Assistant by name.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const test = await pc.describeAssistant('test1');
     * console.log(test);
     * // {
     * //  name: 'test1',
     * //  instructions: undefined,
     * //  metadata: undefined,
     * //  status: 'Ready',
     * //  host: 'https://prod-1-data.ke.pinecone.io',
     * //  createdAt: 2025-01-08T22:24:50.525Z,
     * //  updatedAt: 2025-01-08T22:24:52.303Z
     * // }
     * ```
     *
     * @param assistantName - The name of the Assistant to retrieve.
     * @throws Error if the Assistant API is not initialized.
     * @returns A Promise that resolves to an {@link Assistant} model.
     */ async describeAssistant(assistantName) {
        const assistant = await this._describeAssistant(assistantName);
        if (assistant.host) {
            assistantHostSingleton_1.AssistantHostSingleton._set(this.config, assistantName, assistant.host);
        }
        return Promise.resolve(assistant);
    }
    /**
     * Retrieves a list of all Assistants for a given Pinecone API key.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const assistants = await pc.listAssistants();
     * console.log(assistants);
     * // {
     * //  assistants: [
     * //    {
     * //      name: 'test2',
     * //      instructions: 'test-instructions',
     * //      metadata: [Object],
     * //      status: 'Ready',
     * //      host: 'https://prod-1-data.ke.pinecone.io',
     * //      createdAt: 2025-01-06T19:14:18.633Z,
     * //      updatedAt: 2025-01-06T19:14:36.977Z
     * //    },
     * //  ]
     * // }
     * ```
     *
     * @throws Error if the Assistant API is not initialized.
     * @returns A Promise that resolves to an object containing an array of {@link Assistant} models.
     */ async listAssistants() {
        const assistantList = await this._listAssistants();
        // For any listAssistants calls we want to update the AssistantHostSingleton cache.
        // This prevents unneeded calls to describeAssistant for resolving the host for assistant operations.
        if (assistantList.assistants && assistantList.assistants.length > 0) {
            for(let i = 0; i < assistantList.assistants.length; i++){
                const assistant = assistantList.assistants[i];
                if (assistant.host) {
                    assistantHostSingleton_1.AssistantHostSingleton._set(this.config, assistant.name, assistant.host);
                }
            }
        }
        return Promise.resolve(assistantList);
    }
    /**
     * Updates an Assistant by name.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * await pc.updateAssistant('test1', { instructions: 'some new  instructions!'});
     * // {
     * //  assistantName: test1,
     * //  instructions: 'some new instructions!',
     * //  metadata: undefined
     * // }
     * ```
     *
     * @param assistantName - The name of the assistant being updated.
     * @param options - An {@link UpdateAssistantOptions} object containing the name of the assistant to be updated and
     * optional instructions and metadata.
     * @throws Error if the Assistant API is not initialized.
     * @returns A Promise that resolves to an {@link UpdateAssistant200Response} object.
     */ updateAssistant(assistantName, options) {
        return this._updateAssistant(assistantName, options);
    }
    /** @internal */ _checkForBrowser() {
        if ((0, environment_1.isBrowser)()) {
            console.warn('The Pinecone SDK is intended for server-side use only. Using the SDK within a browser context can expose your API key(s). If you have deployed the SDK to production in a browser, please rotate your API keys.');
        }
    }
    /**
     * @returns The configuration object that was passed to the Pinecone constructor.
     */ getConfig() {
        return this.config;
    }
    /**
     * Creates a backup of an index.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const backup = await pc.createBackup({ indexName: 'my-index', name: 'my-index-backup-1', description: 'weekly backup' });
     * console.log(backup);
     * // {
     * //   backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //   sourceIndexName: 'my-index',
     * //   sourceIndexId: 'b480770b-600d-4c4e-bf19-799c933ae2bf',
     * //   name: 'my-index-backup-1',
     * //   description: 'weekly backup',
     * //   status: 'Initializing',
     * //   cloud: 'aws',
     * //   region: 'us-east-1',
     * //   dimension: 1024,
     * //   metric: 'cosine',
     * //   recordCount: 500,
     * //   namespaceCount: 4,
     * //   sizeBytes: 78294,
     * //   tags: {},
     * //   createdAt: '2025-05-07T03:11:11.722238160Z'
     * // }
     * ```
     *
     * @param options - A {@link CreateBackupOptions} object containing the indexName to backup, and an optional name
     * and description for the backup.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link BackupModel} object.
     */ createBackup(options) {
        return this._createBackup(options);
    }
    /**
     * Creates an index from an existing backup.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const response = await pc.createIndexFromBackup({ backupId: '11450b9f-96e5-47e5-9186-03f346b1f385', name: 'my-index-restore-1' });
     * console.log(response);
     * // {
     * //   restoreJobId: '4d4c8693-10fd-4204-a57b-1e3e626fca07',
     * //   indexId: 'deb7688b-9f21-4c16-8eb7-f0027abd27fe'
     * // }
     * ```
     *
     * @param options - A {@link CreateIndexFromBackupOptions} object containing the backupId for the backup to restore
     * the index from, and the name of the new index. Optionally, you can provide new tags or deletionProtection values for the index.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link CreateIndexFromBackupResponse} object.
     */ createIndexFromBackup(options) {
        return this._createIndexFromBackup(options);
    }
    /**
     * Describes a backup.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const backup = await pc.describeBackup('11450b9f-96e5-47e5-9186-03f346b1f385');
     * console.log(backup);
     * // {
     * //   backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //   sourceIndexName: 'my-index',
     * //   sourceIndexId: 'b480770b-600d-4c4e-bf19-799c933ae2bf',
     * //   name: 'my-index-backup-1',
     * //   description: 'weekly backup',
     * //   status: 'Initializing',
     * //   cloud: 'aws',
     * //   region: 'us-east-1',
     * //   dimension: 1024,
     * //   metric: 'cosine',
     * //   recordCount: 500,
     * //   namespaceCount: 4,
     * //   sizeBytes: 78294,
     * //   tags: {},
     * //   createdAt: '2025-05-07T03:11:11.722238160Z'
     * // }
     * ```
     *
     * @param options - The backupId of the backup to describe.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link BackupModel} object.
     */ describeBackup(backupName) {
        return this._describeBackup(backupName);
    }
    /**
     * Describes a restore job.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const restoreJob = await pc.describeRestoreJob('4d4c8693-10fd-4204-a57b-1e3e626fca07');
     * console.log(restoreJob);
     * // {
     * //   restoreJobId: '4d4c8693-10fd-4204-a57b-1e3e626fca07',
     * //   backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //   targetIndexName: 'my-index-restore-1',
     * //   targetIndexId: 'deb7688b-9f21-4c16-8eb7-f0027abd27fe',
     * //   status: 'Completed',
     * //   createdAt: 2025-05-07T03:38:37.107Z,
     * //   completedAt: 2025-05-07T03:40:23.687Z,
     * //   percentComplete: 100
     * // }
     * ```
     *
     * @param options - The restoreJobId of the restore job to describe.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link RestoreJobModel} object.
     */ describeRestoreJob(restoreJobId) {
        return this._describeRestoreJob(restoreJobId);
    }
    /**
     * Deletes a backup.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * await pc.deleteBackup('11450b9f-96e5-47e5-9186-03f346b1f385');
     * ```
     *
     * @param options - The backupId of the backup to delete.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves when the request to delete the backup is completed.
     */ deleteBackup(backupName) {
        return this._deleteBackup(backupName);
    }
    /**
     * Lists backups within a project or a specific index. Pass an indexName to list backups for that index,
     * otherwise the operation will return all backups in the project.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const backupsList = await pc.listBackups({ indexName: 'my-index', limit: 2 });
     * console.log(backupsList);
     * // {
     * //   data: [
     * //     {
     * //       backupId: '6a00902c-d118-4ad3-931c-49328c26d558',
     * //       sourceIndexName: 'my-index',
     * //       sourceIndexId: '0888b4d9-0b7b-447e-a403-ab057ceee4d4',
     * //       name: 'my-index-backup-2',
     * //       description: undefined,
     * //       status: 'Ready',
     * //       cloud: 'aws',
     * //       region: 'us-east-1',
     * //       dimension: 5,
     * //       metric: 'cosine',
     * //       recordCount: 200,
     * //       namespaceCount: 2,
     * //       sizeBytes: 67284,
     * //       tags: {},
     * //       createdAt: '2025-05-07T18:34:13.626650Z'
     * //     },
     * //     {
     * //       backupId: '2b362ea3-b7cf-4950-866f-0dff37ab781e',
     * //       sourceIndexName: 'my-index',
     * //       sourceIndexId: '0888b4d9-0b7b-447e-a403-ab057ceee4d4',
     * //       name: 'my-index-backup-1',
     * //       description: undefined,
     * //       status: 'Ready',
     * //       cloud: 'aws',
     * //       region: 'us-east-1',
     * //       dimension: 1024,
     * //       metric: 'cosine',
     * //       recordCount: 500,
     * //       namespaceCount: 4,
     * //       sizeBytes: 78294,
     * //       tags: {},
     * //       createdAt: '2025-05-07T18:33:59.888270Z'
     * //     },
     * //   ],
     * //   pagination: undefined
     * // }
     * ```
     *
     * @param options - A {@link ListBackupsOptions} object containing the optional indexName, limit, and paginationToken values.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link BackupList} object.
     */ listBackups(options) {
        return this._listBackups(options);
    }
    /**
     * Lists restore jobs within a project.
     *
     * @example
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone();
     * const restoreJobsList = await pc.listRestoreJobs({ limit: 3 });
     * console.log(restoreJobsList);
     * // {
     * //   data: [
     * //     {
     * //       restoreJobId: '4d4c8693-10fd-4204-a57b-1e3e626fca07',
     * //       backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //       targetIndexName: 'my-index-restore-1',
     * //       targetIndexId: 'deb7688b-9f21-4c16-8eb7-f0027abd27fe',
     * //       status: 'Completed',
     * //       createdAt: 2025-05-07T03:38:37.107Z,
     * //       completedAt: 2025-05-07T03:40:23.687Z,
     * //       percentComplete: 100
     * //     },
     * //     {
     * //       restoreJobId: 'c60a62e0-63b9-452a-88af-31d89c56c988',
     * //       backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //       targetIndexName: 'my-index-restore-2',
     * //       targetIndexId: 'f2c9a846-799f-4b19-81a4-f3096b3d6114',
     * //       status: 'Completed',
     * //       createdAt: 2025-05-07T21:42:38.971Z,
     * //       completedAt: 2025-05-07T21:43:11.782Z,
     * //       percentComplete: 100
     * //     },
     * //     {
     * //       restoreJobId: '792837b7-8001-47bf-9c11-1859826b9c10',
     * //       backupId: '11450b9f-96e5-47e5-9186-03f346b1f385',
     * //       targetIndexName: 'my-index-restore-3',
     * //       targetIndexId: '620dda62-c999-4dd1-b083-6beb087b31e7',
     * //       status: 'Pending',
     * //       createdAt: 2025-05-07T21:48:39.580Z,
     * //       completedAt: 2025-05-07T21:49:12.084Z,
     * //       percentComplete: 45
     * //     }
     * //   ],
     * //   pagination: undefined
     * // }
     * ```
     *
     * @param options - A {@link ListBackupsOptions} object containing the optional indexName, limit, and paginationToken values.
     * @throws {@link Errors.PineconeArgumentError} when arguments passed to the method fail a runtime validation.
     * @throws {@link Errors.PineconeConnectionError} when network problems or an outage of Pinecone's APIs prevent the request from being completed.
     * @returns A Promise that resolves to a {@link BackupList} object.
     */ listRestoreJobs(options) {
        return this._listRestoreJobs(options);
    }
    /**
     * Targets a specific index for performing data operations.
     *
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     * const pc = new Pinecone()
     *
     * const index = pc.index('index-name')
     * ```
     *
     * #### Targeting an index, with user-defined Metadata types
     *
     * If you are storing metadata alongside your vector values inside your Pinecone records, you can pass a type parameter to `index()` in order to get proper TypeScript typechecking when upserting and querying data.
     *
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     *
     * const pc = new Pinecone();
     *
     * type MovieMetadata = {
     *   title: string,
     *   runtime: numbers,
     *   genre: 'comedy' | 'horror' | 'drama' | 'action'
     * }
     *
     * // Specify a custom metadata type while targeting the index
     * const index = pc.index<MovieMetadata>('test-index');
     *
     * // Now you get type errors if upserting malformed metadata
     * await index.upsert([{
     *   id: '1234',
     *   values: [
     *     .... // embedding values
     *   ],
     *   metadata: {
     *     genre: 'Gone with the Wind',
     *     runtime: 238,
     *     genre: 'drama',
     *
     *     // @ts-expect-error because category property not in MovieMetadata
     *     category: 'classic'
     *   }
     * }])
     *
     * const results = await index.query({
     *    vector: [
     *     ... // query embedding
     *    ],
     *    filter: { genre: { '$eq': 'drama' }}
     * })
     * const movie = results.matches[0];
     *
     * if (movie.metadata) {
     *   // Since we passed the MovieMetadata type parameter above,
     *   // we can interact with metadata fields without having to
     *   // do any typecasting.
     *   const { title, runtime, genre } = movie.metadata;
     *   console.log(`The best match in drama was ${title}`)
     * }
     * ```
     *
     * @typeParam T - The type of metadata associated with each record.
     * @param indexName - The name of the index to target.
     * @param indexHostUrl - An optional host url to use for operations against this index. If not provided, the host url will be resolved by calling {@link describeIndex}.
     * @param additionalHeaders - An optional object containing additional headers to pass with each index request.
     * @typeParam T - The type of the metadata object associated with each record.
     * @returns An {@link Index} object that can be used to perform data operations.
     */ index(indexName, indexHostUrl, additionalHeaders) {
        return new data_1.Index(indexName, this.config, undefined, indexHostUrl, additionalHeaders);
    }
    /**
     * {@inheritDoc index}
     */ // Alias method to match the Python SDK capitalization
    Index(indexName, indexHostUrl, additionalHeaders) {
        return this.index(indexName, indexHostUrl, additionalHeaders);
    }
    /**
     * Targets a specific assistant for performing operations.
     *
     * Once an assistant is targeted, you can perform operations such as uploading files,
     * updating instructions, and chatting.
     *
     * ```typescript
     * import { Pinecone } from '@pinecone-database/pinecone';
     *
     * const pc = new Pinecone();
     * const assistant = pc.Assistant('my-assistant');
     *
     * // Upload a file to the assistant
     * await assistant.uploadFile({
     *   path: 'test-file.txt',
     *   metadata: { description: 'Sample test file' }
     * });
     *
     * // Retrieve assistant details
     * const details = await assistant.describe();
     * console.log('Assistant details:', details);
     *
     * // Update assistant instructions
     * await assistant.update({
     *   instructions: 'Provide concise responses only.',
     * });
     *
     * const chatResp = await assistant.chat({
     *   messages: [{ role: 'user', content: 'What is the capital of France?' }],
     * });
     * console.log(chatResp);
     * // {
     * //  id: '000000000000000023e7fb015be9d0ad',
     * //  finishReason: 'stop',
     * //  message: {
     * //    role: 'assistant',
     * //    content: 'The capital of France is Paris.'
     * //  },
     * //  model: 'gpt-4o-2024-05-13',
     * //  citations: [ { position: 209, references: [Array] } ],
     * //  usage: { promptTokens: 493, completionTokens: 38, totalTokens: 531 }
     * // }
     * ```
     *
     * @param assistantName - The name of the assistant to target.
     * @returns An {@link Assistant} object that can be used to perform assistant-related operations.
     */ assistant(assistantName) {
        return new assistant_1.Assistant(assistantName, this.config);
    }
    /**
     * {@inheritDoc assistant}
     */ // Alias method
    Assistant(assistantName) {
        return this.assistant(assistantName);
    }
}
exports.Pinecone = Pinecone; //# sourceMappingURL=pinecone.js.map
}),
"[project]/node_modules/@pinecone-database/pinecone/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Errors = exports.ChatStream = exports.Assistant = exports.Inference = exports.Index = exports.Pinecone = void 0;
// Class, function exports
var pinecone_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/pinecone.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Pinecone", {
    enumerable: true,
    get: function() {
        return pinecone_1.Pinecone;
    }
});
var data_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/data/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Index", {
    enumerable: true,
    get: function() {
        return data_1.Index;
    }
});
var inference_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/inference/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Inference", {
    enumerable: true,
    get: function() {
        return inference_1.Inference;
    }
});
var assistant_1 = __turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/assistant/index.js [app-route] (ecmascript)");
Object.defineProperty(exports, "Assistant", {
    enumerable: true,
    get: function() {
        return assistant_1.Assistant;
    }
});
Object.defineProperty(exports, "ChatStream", {
    enumerable: true,
    get: function() {
        return assistant_1.ChatStream;
    }
});
exports.Errors = __importStar(__turbopack_context__.r("[project]/node_modules/@pinecone-database/pinecone/dist/errors/index.js [app-route] (ecmascript)")); //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_%40pinecone-database_pinecone_dist_a94e534a._.js.map