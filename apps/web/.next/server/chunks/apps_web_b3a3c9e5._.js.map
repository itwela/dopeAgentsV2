{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/invalidateCache.js"],"sourcesContent":["\"use server\";\nimport { cookies } from \"next/headers\";\nexport async function invalidateCache() {\n    // Dummy cookie, just to set the header which will invalidate\n    // the client Router Cache.\n    cookies().delete(`__convexAuthCookieForRouterCacheInvalidation${Date.now()}`);\n    return null;\n}\n"],"names":[],"mappings":";;;;;;AACA;;;;;AACO,eAAe;IAClB,6DAA6D;IAC7D,2BAA2B;IAC3B,IAAA,0IAAO,IAAG,MAAM,CAAC,CAAC,4CAA4C,EAAE,KAAK,GAAG,IAAI;IAC5E,OAAO;AACX;;;IALsB;;AAAA,+OAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/.next-internal/server/app/api/auth/route/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {invalidateCache as '0072803d9832b581dda5546eaf2c8860da47befa25'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 47, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/client.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ConvexAuthNextjsClientProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call ConvexAuthNextjsClientProvider() from the server but ConvexAuthNextjsClientProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/node_modules/@convex-dev/auth/dist/nextjs/client.js <module evaluation>\",\n    \"ConvexAuthNextjsClientProvider\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,iCAAiC,IAAA,0QAAuB,EACjE;IAAa,MAAM,IAAI,MAAM;AAA4Q,GACzS,8FACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/client.js/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const ConvexAuthNextjsClientProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call ConvexAuthNextjsClientProvider() from the server but ConvexAuthNextjsClientProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/web/node_modules/@convex-dev/auth/dist/nextjs/client.js\",\n    \"ConvexAuthNextjsClientProvider\",\n);\n"],"names":[],"mappings":"AAAA,uEAAuE;;;;;AACvE;;AACO,MAAM,iCAAiC,IAAA,0QAAuB,EACjE;IAAa,MAAM,IAAI,MAAM;AAA4Q,GACzS,0EACA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/cookies.js"],"sourcesContent":["import { cookies, headers } from \"next/headers\";\nexport function getRequestCookies() {\n    return getCookieStore(headers(), cookies());\n}\nexport function getRequestCookiesInMiddleware(request) {\n    return getCookieStore(headers(), request.cookies);\n}\nexport function getResponseCookies(response) {\n    return getCookieStore(headers(), response.cookies);\n}\nfunction getCookieStore(requestHeaders, responseCookies) {\n    const isLocalhost = /localhost:\\d+/.test(requestHeaders.get(\"Host\") ?? \"\");\n    const prefix = isLocalhost ? \"\" : \"__Host-\";\n    const tokenName = prefix + \"__convexAuthJWT\";\n    const refreshTokenName = prefix + \"__convexAuthRefreshToken\";\n    const verifierName = prefix + \"__convexAuthOAuthVerifier\";\n    function getValue(name) {\n        return responseCookies.get(name)?.value ?? null;\n    }\n    const cookieOptions = getCookieOptions(isLocalhost);\n    function setValue(name, value) {\n        if (value === null) {\n            // Only request cookies have a `size` property\n            if (\"size\" in responseCookies) {\n                responseCookies.delete(name);\n            }\n            else {\n                // See https://github.com/vercel/next.js/issues/56632\n                // for why .delete({}) doesn't work:\n                responseCookies.set(name, \"\", {\n                    ...cookieOptions,\n                    expires: 0,\n                });\n            }\n        }\n        else {\n            responseCookies.set(name, value, cookieOptions);\n        }\n    }\n    return {\n        get token() {\n            return getValue(tokenName);\n        },\n        set token(value) {\n            setValue(tokenName, value);\n        },\n        get refreshToken() {\n            return getValue(refreshTokenName);\n        },\n        set refreshToken(value) {\n            setValue(refreshTokenName, value);\n        },\n        get verifier() {\n            return getValue(verifierName);\n        },\n        set verifier(value) {\n            setValue(verifierName, value);\n        },\n    };\n}\nfunction getCookieOptions(isLocalhost) {\n    // Safari does not send headers with `secure: true` on http:// domains including localhost,\n    // so set `secure: false` (https://codedamn.com/news/web-development/safari-cookie-is-not-being-set)\n    return {\n        secure: isLocalhost ? false : true,\n        httpOnly: true,\n        sameSite: \"lax\",\n        path: \"/\",\n    };\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AACO,SAAS;IACZ,OAAO,eAAe,IAAA,4IAAO,KAAI,IAAA,4IAAO;AAC5C;AACO,SAAS,8BAA8B,OAAO;IACjD,OAAO,eAAe,IAAA,4IAAO,KAAI,QAAQ,OAAO;AACpD;AACO,SAAS,mBAAmB,QAAQ;IACvC,OAAO,eAAe,IAAA,4IAAO,KAAI,SAAS,OAAO;AACrD;AACA,SAAS,eAAe,cAAc,EAAE,eAAe;IACnD,MAAM,cAAc,gBAAgB,IAAI,CAAC,eAAe,GAAG,CAAC,WAAW;IACvE,MAAM,SAAS,cAAc,KAAK;IAClC,MAAM,YAAY,SAAS;IAC3B,MAAM,mBAAmB,SAAS;IAClC,MAAM,eAAe,SAAS;IAC9B,SAAS,SAAS,IAAI;QAClB,OAAO,gBAAgB,GAAG,CAAC,OAAO,SAAS;IAC/C;IACA,MAAM,gBAAgB,iBAAiB;IACvC,SAAS,SAAS,IAAI,EAAE,MAAK;QACzB,IAAI,WAAU,MAAM;YAChB,8CAA8C;YAC9C,IAAI,UAAU,iBAAiB;gBAC3B,gBAAgB,MAAM,CAAC;YAC3B,OACK;gBACD,qDAAqD;gBACrD,oCAAoC;gBACpC,gBAAgB,GAAG,CAAC,MAAM,IAAI;oBAC1B,GAAG,aAAa;oBAChB,SAAS;gBACb;YACJ;QACJ,OACK;YACD,gBAAgB,GAAG,CAAC,MAAM,QAAO;QACrC;IACJ;IACA,OAAO;QACH,IAAI,SAAQ;YACR,OAAO,SAAS;QACpB;QACA,IAAI,OAAM,MAAO;YACb,SAAS,WAAW;QACxB;QACA,IAAI,gBAAe;YACf,OAAO,SAAS;QACpB;QACA,IAAI,cAAa,MAAO;YACpB,SAAS,kBAAkB;QAC/B;QACA,IAAI,YAAW;YACX,OAAO,SAAS;QACpB;QACA,IAAI,UAAS,MAAO;YAChB,SAAS,cAAc;QAC3B;IACJ;AACJ;AACA,SAAS,iBAAiB,WAAW;IACjC,2FAA2F;IAC3F,oGAAoG;IACpG,OAAO;QACH,QAAQ,cAAc,QAAQ;QAC9B,UAAU;QACV,UAAU;QACV,MAAM;IACV;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/utils.js"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getRequestCookiesInMiddleware, getResponseCookies, } from \"./cookies.js\";\nexport function jsonResponse(body) {\n    return new NextResponse(JSON.stringify(body), {\n        headers: { \"Content-Type\": \"application/json\" },\n    });\n}\nexport function setAuthCookies(response, tokens) {\n    const responseCookies = getResponseCookies(response);\n    if (tokens === null) {\n        responseCookies.token = null;\n        responseCookies.refreshToken = null;\n    }\n    else {\n        responseCookies.token = tokens.token;\n        responseCookies.refreshToken = tokens.refreshToken;\n    }\n    responseCookies.verifier = null;\n}\n/**\n * Forward on any auth cookies in the request to the next handler.\n *\n * @param request\n * @param tokens\n */\nexport function setAuthCookiesInMiddleware(request, tokens) {\n    const requestCookies = getRequestCookiesInMiddleware(request);\n    if (tokens === null) {\n        requestCookies.token = null;\n        requestCookies.refreshToken = null;\n    }\n    else {\n        requestCookies.token = tokens.token;\n        requestCookies.refreshToken = tokens.refreshToken;\n    }\n}\nexport function isCorsRequest(request) {\n    const origin = request.headers.get(\"Origin\");\n    const originURL = origin ? new URL(origin) : null;\n    return (originURL !== null &&\n        (originURL.host !== request.headers.get(\"Host\") ||\n            originURL.protocol !== new URL(request.url).protocol));\n}\nexport function logVerbose(message, verbose) {\n    if (verbose) {\n        console.debug(`[verbose] ${new Date().toISOString()} [ConvexAuthNextjs] ${message}`);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;;;AACO,SAAS,aAAa,IAAI;IAC7B,OAAO,IAAI,gJAAY,CAAC,KAAK,SAAS,CAAC,OAAO;QAC1C,SAAS;YAAE,gBAAgB;QAAmB;IAClD;AACJ;AACO,SAAS,eAAe,QAAQ,EAAE,MAAM;IAC3C,MAAM,kBAAkB,IAAA,qNAAkB,EAAC;IAC3C,IAAI,WAAW,MAAM;QACjB,gBAAgB,KAAK,GAAG;QACxB,gBAAgB,YAAY,GAAG;IACnC,OACK;QACD,gBAAgB,KAAK,GAAG,OAAO,KAAK;QACpC,gBAAgB,YAAY,GAAG,OAAO,YAAY;IACtD;IACA,gBAAgB,QAAQ,GAAG;AAC/B;AAOO,SAAS,2BAA2B,OAAO,EAAE,MAAM;IACtD,MAAM,iBAAiB,IAAA,gOAA6B,EAAC;IACrD,IAAI,WAAW,MAAM;QACjB,eAAe,KAAK,GAAG;QACvB,eAAe,YAAY,GAAG;IAClC,OACK;QACD,eAAe,KAAK,GAAG,OAAO,KAAK;QACnC,eAAe,YAAY,GAAG,OAAO,YAAY;IACrD;AACJ;AACO,SAAS,cAAc,OAAO;IACjC,MAAM,SAAS,QAAQ,OAAO,CAAC,GAAG,CAAC;IACnC,MAAM,YAAY,SAAS,IAAI,IAAI,UAAU;IAC7C,OAAQ,cAAc,QAClB,CAAC,UAAU,IAAI,KAAK,QAAQ,OAAO,CAAC,GAAG,CAAC,WACpC,UAAU,QAAQ,KAAK,IAAI,IAAI,QAAQ,GAAG,EAAE,QAAQ;AAChE;AACO,SAAS,WAAW,OAAO,EAAE,OAAO;IACvC,IAAI,SAAS;QACT,QAAQ,KAAK,CAAC,CAAC,UAAU,EAAE,IAAI,OAAO,WAAW,GAAG,oBAAoB,EAAE,SAAS;IACvF;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/proxy.js"],"sourcesContent":["import \"server-only\";\nimport { fetchAction } from \"convex/nextjs\";\nimport { getRequestCookies, getResponseCookies } from \"./cookies.js\";\nimport { isCorsRequest, jsonResponse, logVerbose, setAuthCookies, } from \"./utils.js\";\nexport async function proxyAuthActionToConvex(request, options) {\n    const verbose = options?.verbose ?? false;\n    if (request.method !== \"POST\") {\n        return new Response(\"Invalid method\", { status: 405 });\n    }\n    if (isCorsRequest(request)) {\n        return new Response(\"Invalid origin\", { status: 403 });\n    }\n    const { action, args } = await request.json();\n    if (action !== \"auth:signIn\" && action !== \"auth:signOut\") {\n        logVerbose(`Invalid action ${action}, returning 400`, verbose);\n        return new Response(\"Invalid action\", { status: 400 });\n    }\n    let token;\n    if (action === \"auth:signIn\" && args.refreshToken !== undefined) {\n        // The client has a dummy refreshToken, the real one is only\n        // stored in cookies.\n        const refreshToken = getRequestCookies().refreshToken;\n        if (refreshToken === null) {\n            console.error(\"Convex Auth: Unexpected missing refreshToken cookie during client refresh\");\n            return new Response(JSON.stringify({ tokens: null }));\n        }\n        args.refreshToken = refreshToken;\n    }\n    else {\n        // Make sure the proxy is authenticated if the client is,\n        // important for signOut and any other logic working\n        // with existing sessions.\n        token = getRequestCookies().token ?? undefined;\n    }\n    logVerbose(`Fetching action ${action} with args ${JSON.stringify(args)}`, verbose);\n    const untypedResult = await fetchAction(action, args, {\n        url: options?.convexUrl,\n        token,\n    });\n    if (action === \"auth:signIn\") {\n        const result = untypedResult;\n        if (result.redirect !== undefined) {\n            const { redirect } = result;\n            const response = jsonResponse({ redirect });\n            getResponseCookies(response).verifier = result.verifier;\n            logVerbose(`Redirecting to ${redirect}`, verbose);\n            return response;\n        }\n        else if (result.tokens !== undefined) {\n            // The server doesn't share the refresh token with the client\n            // for added security - the client has to use the server\n            // to refresh the access token via cookies.\n            logVerbose(result.tokens === null\n                ? `No tokens returned, clearing auth cookies`\n                : `Setting auth cookies with returned tokens`, verbose);\n            const response = jsonResponse({\n                tokens: result.tokens !== null\n                    ? { token: result.tokens.token, refreshToken: \"dummy\" }\n                    : null,\n            });\n            setAuthCookies(response, result.tokens);\n            return response;\n        }\n        return jsonResponse(result);\n    }\n    else {\n        logVerbose(`Clearing auth cookies`, verbose);\n        const response = jsonResponse(null);\n        setAuthCookies(response, null);\n        return response;\n    }\n}\nexport function shouldProxyAuthAction(request, apiRoute) {\n    // Handle both with and without trailing slash since this could be configured either way.\n    // https://nextjs.org/docs/app/api-reference/next-config-js/trailingSlash\n    const requestUrl = new URL(request.url);\n    if (apiRoute.endsWith(\"/\")) {\n        return (requestUrl.pathname === apiRoute ||\n            requestUrl.pathname === apiRoute.slice(0, -1));\n    }\n    else {\n        return (requestUrl.pathname === apiRoute || requestUrl.pathname === apiRoute + \"/\");\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AACO,eAAe,wBAAwB,OAAO,EAAE,OAAO;IAC1D,MAAM,UAAU,SAAS,WAAW;IACpC,IAAI,QAAQ,MAAM,KAAK,QAAQ;QAC3B,OAAO,IAAI,SAAS,kBAAkB;YAAE,QAAQ;QAAI;IACxD;IACA,IAAI,IAAA,8MAAa,EAAC,UAAU;QACxB,OAAO,IAAI,SAAS,kBAAkB;YAAE,QAAQ;QAAI;IACxD;IACA,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,QAAQ,IAAI;IAC3C,IAAI,WAAW,iBAAiB,WAAW,gBAAgB;QACvD,IAAA,2MAAU,EAAC,CAAC,eAAe,EAAE,OAAO,eAAe,CAAC,EAAE;QACtD,OAAO,IAAI,SAAS,kBAAkB;YAAE,QAAQ;QAAI;IACxD;IACA,IAAI;IACJ,IAAI,WAAW,iBAAiB,KAAK,YAAY,KAAK,WAAW;QAC7D,4DAA4D;QAC5D,qBAAqB;QACrB,MAAM,eAAe,IAAA,oNAAiB,IAAG,YAAY;QACrD,IAAI,iBAAiB,MAAM;YACvB,QAAQ,KAAK,CAAC;YACd,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC;gBAAE,QAAQ;YAAK;QACtD;QACA,KAAK,YAAY,GAAG;IACxB,OACK;QACD,yDAAyD;QACzD,oDAAoD;QACpD,0BAA0B;QAC1B,QAAQ,IAAA,oNAAiB,IAAG,KAAK,IAAI;IACzC;IACA,IAAA,2MAAU,EAAC,CAAC,gBAAgB,EAAE,OAAO,WAAW,EAAE,KAAK,SAAS,CAAC,OAAO,EAAE;IAC1E,MAAM,gBAAgB,MAAM,IAAA,yKAAW,EAAC,QAAQ,MAAM;QAClD,KAAK,SAAS;QACd;IACJ;IACA,IAAI,WAAW,eAAe;QAC1B,MAAM,SAAS;QACf,IAAI,OAAO,QAAQ,KAAK,WAAW;YAC/B,MAAM,EAAE,QAAQ,EAAE,GAAG;YACrB,MAAM,WAAW,IAAA,6MAAY,EAAC;gBAAE;YAAS;YACzC,IAAA,qNAAkB,EAAC,UAAU,QAAQ,GAAG,OAAO,QAAQ;YACvD,IAAA,2MAAU,EAAC,CAAC,eAAe,EAAE,UAAU,EAAE;YACzC,OAAO;QACX,OACK,IAAI,OAAO,MAAM,KAAK,WAAW;YAClC,6DAA6D;YAC7D,wDAAwD;YACxD,2CAA2C;YAC3C,IAAA,2MAAU,EAAC,OAAO,MAAM,KAAK,OACvB,CAAC,yCAAyC,CAAC,GAC3C,CAAC,yCAAyC,CAAC,EAAE;YACnD,MAAM,WAAW,IAAA,6MAAY,EAAC;gBAC1B,QAAQ,OAAO,MAAM,KAAK,OACpB;oBAAE,OAAO,OAAO,MAAM,CAAC,KAAK;oBAAE,cAAc;gBAAQ,IACpD;YACV;YACA,IAAA,+MAAc,EAAC,UAAU,OAAO,MAAM;YACtC,OAAO;QACX;QACA,OAAO,IAAA,6MAAY,EAAC;IACxB,OACK;QACD,IAAA,2MAAU,EAAC,CAAC,qBAAqB,CAAC,EAAE;QACpC,MAAM,WAAW,IAAA,6MAAY,EAAC;QAC9B,IAAA,+MAAc,EAAC,UAAU;QACzB,OAAO;IACX;AACJ;AACO,SAAS,sBAAsB,OAAO,EAAE,QAAQ;IACnD,yFAAyF;IACzF,yEAAyE;IACzE,MAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;IACtC,IAAI,SAAS,QAAQ,CAAC,MAAM;QACxB,OAAQ,WAAW,QAAQ,KAAK,YAC5B,WAAW,QAAQ,KAAK,SAAS,KAAK,CAAC,GAAG,CAAC;IACnD,OACK;QACD,OAAQ,WAAW,QAAQ,KAAK,YAAY,WAAW,QAAQ,KAAK,WAAW;IACnF;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 324, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/request.js"],"sourcesContent":["import { fetchAction } from \"convex/nextjs\";\nimport { jwtDecode } from \"jwt-decode\";\nimport { NextResponse } from \"next/server\";\nimport { getRequestCookies, getRequestCookiesInMiddleware } from \"./cookies.js\";\nimport { isCorsRequest, logVerbose, setAuthCookies } from \"./utils.js\";\nexport async function handleAuthenticationInRequest(request, verbose) {\n    logVerbose(`Begin handleAuthenticationInRequest`, verbose);\n    const requestUrl = new URL(request.url);\n    // Validate CORS\n    validateCors(request);\n    // Refresh tokens if necessary\n    const refreshTokens = await getRefreshedTokens(verbose);\n    // Handle code exchange for OAuth and magic links via server-side redirect\n    const code = requestUrl.searchParams.get(\"code\");\n    if (code &&\n        request.method === \"GET\" &&\n        request.headers.get(\"accept\")?.includes(\"text/html\")) {\n        logVerbose(`Handling code exchange for OAuth or magic link`, verbose);\n        const verifier = getRequestCookies().verifier ?? undefined;\n        const redirectUrl = new URL(requestUrl);\n        redirectUrl.searchParams.delete(\"code\");\n        try {\n            const result = await fetchAction(\"auth:signIn\", { params: { code }, verifier });\n            if (result.tokens === undefined) {\n                throw new Error(\"Invalid `signIn` action result for code exchange\");\n            }\n            const response = NextResponse.redirect(redirectUrl);\n            setAuthCookies(response, result.tokens);\n            logVerbose(`Successfully validated code, redirecting to ${redirectUrl.toString()} with auth cookies`, verbose);\n            return { kind: \"redirect\", response };\n        }\n        catch (error) {\n            console.error(error);\n            logVerbose(`Error validating code, redirecting to ${redirectUrl.toString()} and clearing auth cookies`, verbose);\n            const response = NextResponse.redirect(redirectUrl);\n            setAuthCookies(response, null);\n            return { kind: \"redirect\", response };\n        }\n    }\n    return { kind: \"refreshTokens\", refreshTokens };\n}\n// If this is a cross-origin request with `Origin` header set\n// do not allow the app to read auth cookies.\nfunction validateCors(request) {\n    if (isCorsRequest(request)) {\n        const cookies = getRequestCookiesInMiddleware(request);\n        cookies.token = null;\n        cookies.refreshToken = null;\n        cookies.verifier = null;\n    }\n}\nconst REQUIRED_TOKEN_LIFETIME_MS = 60_000; // 1 minute\nconst MINIMUM_REQUIRED_TOKEN_LIFETIME_MS = 10_000; // 10 seconds\nasync function getRefreshedTokens(verbose) {\n    const cookies = getRequestCookies();\n    const { token, refreshToken } = cookies;\n    if (refreshToken === null && token === null) {\n        logVerbose(`No tokens to refresh, returning undefined`, verbose);\n        return undefined;\n    }\n    if (refreshToken === null || token === null) {\n        logVerbose(`Refresh token null? ${refreshToken === null}, token null? ${token === null}, returning null`, verbose);\n        return null;\n    }\n    const decodedToken = decodeToken(token);\n    if (decodedToken === null) {\n        logVerbose(`Failed to decode token, returning null`, verbose);\n        return null;\n    }\n    const totalTokenLifetimeMs = decodedToken.exp * 1000 - decodedToken.iat * 1000;\n    // Check that the token is valid for the next 1 minute\n    // or at least 10% of its valid duration or 10 seconds\n    const minimumExpiration = Date.now() +\n        Math.min(REQUIRED_TOKEN_LIFETIME_MS, Math.max(MINIMUM_REQUIRED_TOKEN_LIFETIME_MS, totalTokenLifetimeMs / 10));\n    if (decodedToken.exp * 1000 > minimumExpiration) {\n        logVerbose(`Token expires far enough in the future, no need to refresh, returning undefined`, verbose);\n        return undefined;\n    }\n    try {\n        const result = await fetchAction(\"auth:signIn\", {\n            refreshToken,\n        });\n        if (result.tokens === undefined) {\n            throw new Error(\"Invalid `signIn` action result for token refresh\");\n        }\n        logVerbose(`Successfully refreshed tokens`, verbose);\n        return result.tokens;\n    }\n    catch (error) {\n        console.error(error);\n        logVerbose(`Failed to refresh tokens, returning null`, verbose);\n        return null;\n    }\n}\nfunction decodeToken(token) {\n    try {\n        return jwtDecode(token);\n    }\n    catch (e) {\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,eAAe,8BAA8B,OAAO,EAAE,OAAO;IAChE,IAAA,2MAAU,EAAC,CAAC,mCAAmC,CAAC,EAAE;IAClD,MAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;IACtC,gBAAgB;IAChB,aAAa;IACb,8BAA8B;IAC9B,MAAM,gBAAgB,MAAM,mBAAmB;IAC/C,0EAA0E;IAC1E,MAAM,OAAO,WAAW,YAAY,CAAC,GAAG,CAAC;IACzC,IAAI,QACA,QAAQ,MAAM,KAAK,SACnB,QAAQ,OAAO,CAAC,GAAG,CAAC,WAAW,SAAS,cAAc;QACtD,IAAA,2MAAU,EAAC,CAAC,8CAA8C,CAAC,EAAE;QAC7D,MAAM,WAAW,IAAA,oNAAiB,IAAG,QAAQ,IAAI;QACjD,MAAM,cAAc,IAAI,IAAI;QAC5B,YAAY,YAAY,CAAC,MAAM,CAAC;QAChC,IAAI;YACA,MAAM,SAAS,MAAM,IAAA,yKAAW,EAAC,eAAe;gBAAE,QAAQ;oBAAE;gBAAK;gBAAG;YAAS;YAC7E,IAAI,OAAO,MAAM,KAAK,WAAW;gBAC7B,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC;YACvC,IAAA,+MAAc,EAAC,UAAU,OAAO,MAAM;YACtC,IAAA,2MAAU,EAAC,CAAC,4CAA4C,EAAE,YAAY,QAAQ,GAAG,kBAAkB,CAAC,EAAE;YACtG,OAAO;gBAAE,MAAM;gBAAY;YAAS;QACxC,EACA,OAAO,OAAO;YACV,QAAQ,KAAK,CAAC;YACd,IAAA,2MAAU,EAAC,CAAC,sCAAsC,EAAE,YAAY,QAAQ,GAAG,0BAA0B,CAAC,EAAE;YACxG,MAAM,WAAW,gJAAY,CAAC,QAAQ,CAAC;YACvC,IAAA,+MAAc,EAAC,UAAU;YACzB,OAAO;gBAAE,MAAM;gBAAY;YAAS;QACxC;IACJ;IACA,OAAO;QAAE,MAAM;QAAiB;IAAc;AAClD;AACA,6DAA6D;AAC7D,6CAA6C;AAC7C,SAAS,aAAa,OAAO;IACzB,IAAI,IAAA,8MAAa,EAAC,UAAU;QACxB,MAAM,UAAU,IAAA,gOAA6B,EAAC;QAC9C,QAAQ,KAAK,GAAG;QAChB,QAAQ,YAAY,GAAG;QACvB,QAAQ,QAAQ,GAAG;IACvB;AACJ;AACA,MAAM,6BAA6B,QAAQ,WAAW;AACtD,MAAM,qCAAqC,QAAQ,aAAa;AAChE,eAAe,mBAAmB,OAAO;IACrC,MAAM,UAAU,IAAA,oNAAiB;IACjC,MAAM,EAAE,KAAK,EAAE,YAAY,EAAE,GAAG;IAChC,IAAI,iBAAiB,QAAQ,UAAU,MAAM;QACzC,IAAA,2MAAU,EAAC,CAAC,yCAAyC,CAAC,EAAE;QACxD,OAAO;IACX;IACA,IAAI,iBAAiB,QAAQ,UAAU,MAAM;QACzC,IAAA,2MAAU,EAAC,CAAC,oBAAoB,EAAE,iBAAiB,KAAK,cAAc,EAAE,UAAU,KAAK,gBAAgB,CAAC,EAAE;QAC1G,OAAO;IACX;IACA,MAAM,eAAe,YAAY;IACjC,IAAI,iBAAiB,MAAM;QACvB,IAAA,2MAAU,EAAC,CAAC,sCAAsC,CAAC,EAAE;QACrD,OAAO;IACX;IACA,MAAM,uBAAuB,aAAa,GAAG,GAAG,OAAO,aAAa,GAAG,GAAG;IAC1E,sDAAsD;IACtD,sDAAsD;IACtD,MAAM,oBAAoB,KAAK,GAAG,KAC9B,KAAK,GAAG,CAAC,4BAA4B,KAAK,GAAG,CAAC,oCAAoC,uBAAuB;IAC7G,IAAI,aAAa,GAAG,GAAG,OAAO,mBAAmB;QAC7C,IAAA,2MAAU,EAAC,CAAC,+EAA+E,CAAC,EAAE;QAC9F,OAAO;IACX;IACA,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,yKAAW,EAAC,eAAe;YAC5C;QACJ;QACA,IAAI,OAAO,MAAM,KAAK,WAAW;YAC7B,MAAM,IAAI,MAAM;QACpB;QACA,IAAA,2MAAU,EAAC,CAAC,6BAA6B,CAAC,EAAE;QAC5C,OAAO,OAAO,MAAM;IACxB,EACA,OAAO,OAAO;QACV,QAAQ,KAAK,CAAC;QACd,IAAA,2MAAU,EAAC,CAAC,wCAAwC,CAAC,EAAE;QACvD,OAAO;IACX;AACJ;AACA,SAAS,YAAY,KAAK;IACtB,IAAI;QACA,OAAO,IAAA,qKAAS,EAAC;IACrB,EACA,OAAO,GAAG;QACN,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 447, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/index.js"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport \"server-only\";\nimport { NextResponse, } from \"next/server\";\nimport { ConvexAuthNextjsClientProvider, } from \"../client.js\";\nimport { getRequestCookies } from \"./cookies.js\";\nimport { proxyAuthActionToConvex, shouldProxyAuthAction } from \"./proxy.js\";\nimport { handleAuthenticationInRequest } from \"./request.js\";\nimport { logVerbose, setAuthCookies, setAuthCookiesInMiddleware, } from \"./utils.js\";\n/**\n * Wrap your app with this provider in your root `layout.tsx`.\n */\nexport function ConvexAuthNextjsServerProvider(props) {\n    const { apiRoute, storage, storageNamespace, verbose, children } = props;\n    return (_jsx(ConvexAuthNextjsClientProvider, { serverState: convexAuthNextjsServerState(), apiRoute: apiRoute, storage: storage, storageNamespace: storageNamespace, verbose: verbose, children: children }));\n}\n/**\n * Retrieve the token for authenticating calls to your\n * Convex backend from Server Components, Server Actions and Route Handlers.\n * @returns The token if the the client is authenticated, otherwise `undefined`.\n */\nexport function convexAuthNextjsToken() {\n    return getRequestCookies().token ?? undefined;\n}\n/**\n * Whether the client is authenticated, which you can check\n * in Server Actions, Route Handlers and Middleware.\n *\n * Avoid the pitfall of checking authentication state in layouts,\n * since they won't stop nested pages from rendering.\n */\nexport function isAuthenticatedNextjs() {\n    return convexAuthNextjsToken() !== undefined;\n}\n/**\n * Use in your `middleware.ts` to enable your Next.js app to use\n * Convex Auth for authentication on the server.\n *\n * @returns A Next.js middleware.\n */\nexport function convexAuthNextjsMiddleware(\n/**\n * A custom handler, which you can use to decide\n * which routes should be accessible based on the client's authentication.\n */\nhandler, options = {}) {\n    return async (request, event) => {\n        const verbose = options.verbose ?? false;\n        logVerbose(`Begin middleware for request with URL ${request.url}`, verbose);\n        const requestUrl = new URL(request.url);\n        // Proxy signIn and signOut actions to Convex backend\n        const apiRoute = options?.apiRoute ?? \"/api/auth\";\n        if (shouldProxyAuthAction(request, apiRoute)) {\n            logVerbose(`Proxying auth action to Convex, path matches ${apiRoute} with or without trailing slash`, verbose);\n            return await proxyAuthActionToConvex(request, options);\n        }\n        logVerbose(`Not proxying auth action to Convex, path ${requestUrl.pathname} does not match ${apiRoute}`, verbose);\n        // Refresh tokens, handle code query param\n        const authResult = await handleAuthenticationInRequest(request, verbose);\n        // If redirecting, proceed, the middleware will run again on next request\n        if (authResult.kind === \"redirect\") {\n            logVerbose(`Redirecting to ${authResult.response.headers.get(\"Location\")}`, verbose);\n            return authResult.response;\n        }\n        let response = null;\n        // Forward cookies to request for custom handler\n        if (authResult.kind === \"refreshTokens\" &&\n            authResult.refreshTokens !== undefined) {\n            logVerbose(`Forwarding cookies to request`, verbose);\n            setAuthCookiesInMiddleware(request, authResult.refreshTokens);\n        }\n        if (handler === undefined) {\n            logVerbose(`No custom handler`, verbose);\n            response = NextResponse.next();\n        }\n        else {\n            // Call the custom handler\n            logVerbose(`Calling custom handler`, verbose);\n            response = (await handler(request, event)) ?? NextResponse.next();\n        }\n        // Port the cookies from the auth middleware to the response\n        if (authResult.kind === \"refreshTokens\" &&\n            authResult.refreshTokens !== undefined) {\n            response.headers.getSetCookie();\n            setAuthCookies(NextResponse.next(response), authResult.refreshTokens);\n        }\n        return response;\n    };\n}\nexport { createRouteMatcher } from \"./routeMatcher.js\";\n/**\n * Helper for redirecting to a different route from\n * a Next.js middleware.\n *\n * ```ts\n * return nextjsMiddlewareRedirect(request, \"/login\");\n * ```\n */\nexport function nextjsMiddlewareRedirect(\n/**\n * The incoming request handled by the middleware.\n */\nrequest, \n/**\n * The route path to redirect to.\n */\npathname) {\n    const url = request.nextUrl.clone();\n    url.pathname = pathname;\n    return NextResponse.redirect(url);\n}\nfunction convexAuthNextjsServerState() {\n    const { token } = getRequestCookies();\n    return {\n        // The server doesn't share the refresh token with the client\n        // for added security - the client has to use the server\n        // to refresh the access token via cookies.\n        _state: { token, refreshToken: \"dummy\" },\n        _timeFetched: Date.now(),\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAIO,SAAS,+BAA+B,KAAK;IAChD,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,gBAAgB,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG;IACnE,OAAQ,IAAA,gOAAI,EAAC,sNAA8B,EAAE;QAAE,aAAa;QAA+B,UAAU;QAAU,SAAS;QAAS,kBAAkB;QAAkB,SAAS;QAAS,UAAU;IAAS;AAC9M;AAMO,SAAS;IACZ,OAAO,IAAA,oNAAiB,IAAG,KAAK,IAAI;AACxC;AAQO,SAAS;IACZ,OAAO,4BAA4B;AACvC;AAOO,SAAS,2BAChB;;;CAGC,GACD,OAAO,EAAE,UAAU,CAAC,CAAC;IACjB,OAAO,OAAO,SAAS;QACnB,MAAM,UAAU,QAAQ,OAAO,IAAI;QACnC,IAAA,2MAAU,EAAC,CAAC,sCAAsC,EAAE,QAAQ,GAAG,EAAE,EAAE;QACnE,MAAM,aAAa,IAAI,IAAI,QAAQ,GAAG;QACtC,qDAAqD;QACrD,MAAM,WAAW,SAAS,YAAY;QACtC,IAAI,IAAA,sNAAqB,EAAC,SAAS,WAAW;YAC1C,IAAA,2MAAU,EAAC,CAAC,6CAA6C,EAAE,SAAS,+BAA+B,CAAC,EAAE;YACtG,OAAO,MAAM,IAAA,wNAAuB,EAAC,SAAS;QAClD;QACA,IAAA,2MAAU,EAAC,CAAC,yCAAyC,EAAE,WAAW,QAAQ,CAAC,gBAAgB,EAAE,UAAU,EAAE;QACzG,0CAA0C;QAC1C,MAAM,aAAa,MAAM,IAAA,gOAA6B,EAAC,SAAS;QAChE,yEAAyE;QACzE,IAAI,WAAW,IAAI,KAAK,YAAY;YAChC,IAAA,2MAAU,EAAC,CAAC,eAAe,EAAE,WAAW,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,EAAE;YAC5E,OAAO,WAAW,QAAQ;QAC9B;QACA,IAAI,WAAW;QACf,gDAAgD;QAChD,IAAI,WAAW,IAAI,KAAK,mBACpB,WAAW,aAAa,KAAK,WAAW;YACxC,IAAA,2MAAU,EAAC,CAAC,6BAA6B,CAAC,EAAE;YAC5C,IAAA,2NAA0B,EAAC,SAAS,WAAW,aAAa;QAChE;QACA,IAAI,YAAY,WAAW;YACvB,IAAA,2MAAU,EAAC,CAAC,iBAAiB,CAAC,EAAE;YAChC,WAAW,gJAAY,CAAC,IAAI;QAChC,OACK;YACD,0BAA0B;YAC1B,IAAA,2MAAU,EAAC,CAAC,sBAAsB,CAAC,EAAE;YACrC,WAAW,AAAC,MAAM,QAAQ,SAAS,UAAW,gJAAY,CAAC,IAAI;QACnE;QACA,4DAA4D;QAC5D,IAAI,WAAW,IAAI,KAAK,mBACpB,WAAW,aAAa,KAAK,WAAW;YACxC,SAAS,OAAO,CAAC,YAAY;YAC7B,IAAA,+MAAc,EAAC,gJAAY,CAAC,IAAI,CAAC,WAAW,WAAW,aAAa;QACxE;QACA,OAAO;IACX;AACJ;;AAUO,SAAS,yBAChB;;CAEC,GACD,OAAO,EACP;;CAEC,GACD,QAAQ;IACJ,MAAM,MAAM,QAAQ,OAAO,CAAC,KAAK;IACjC,IAAI,QAAQ,GAAG;IACf,OAAO,gJAAY,CAAC,QAAQ,CAAC;AACjC;AACA,SAAS;IACL,MAAM,EAAE,KAAK,EAAE,GAAG,IAAA,oNAAiB;IACnC,OAAO;QACH,6DAA6D;QAC7D,wDAAwD;QACxD,2CAA2C;QAC3C,QAAQ;YAAE;YAAO,cAAc;QAAQ;QACvC,cAAc,KAAK,GAAG;IAC1B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/nextjs/server/routeMatcher.js"],"sourcesContent":["// Adapted from Clerk\n//\n// MIT License\n//\n// Copyright (c) 2022 Clerk, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { pathToRegexp } from \"path-to-regexp\";\n/**\n * Returns a function that accepts a `Request` object and returns whether the request matches the list of\n * predefined routes that can be passed in as the first argument.\n *\n * You can use glob patterns to match multiple routes or a function to match against the request object.\n * Path patterns and regular expressions are supported, for example: `['/foo', '/bar(.*)'] or `[/^\\/foo\\/.*$/]`\n * For more information, see: https://github.com/pillarjs/path-to-regexp\n */\nexport const createRouteMatcher = (routes) => {\n    if (typeof routes === \"function\") {\n        return (req) => routes(req);\n    }\n    const routePatterns = [routes || \"\"].flat().filter(Boolean);\n    const matchers = precomputePathRegex(routePatterns);\n    return (req) => matchers.some((matcher) => matcher.test(req.nextUrl.pathname));\n};\nconst precomputePathRegex = (patterns) => {\n    return patterns.map((pattern) => pattern instanceof RegExp ? pattern : pathStringToRegExp(pattern));\n};\nfunction pathStringToRegExp(path) {\n    try {\n        return pathToRegexp(path);\n    }\n    catch (e) {\n        throw new Error(`Invalid path: ${path}.\\nConsult the documentation of path-to-regexp here: https://github.com/pillarjs/path-to-regexp\\n${e.message}`);\n    }\n}\n"],"names":[],"mappings":"AAAA,qBAAqB;AACrB,EAAE;AACF,cAAc;AACd,EAAE;AACF,iCAAiC;AACjC,EAAE;AACF,+EAA+E;AAC/E,gFAAgF;AAChF,+EAA+E;AAC/E,4EAA4E;AAC5E,wEAAwE;AACxE,2DAA2D;AAC3D,EAAE;AACF,iFAAiF;AACjF,kDAAkD;AAClD,EAAE;AACF,6EAA6E;AAC7E,2EAA2E;AAC3E,8EAA8E;AAC9E,yEAAyE;AACzE,gFAAgF;AAChF,gFAAgF;AAChF,YAAY;;;;;AACZ;;AASO,MAAM,qBAAqB,CAAC;IAC/B,IAAI,OAAO,WAAW,YAAY;QAC9B,OAAO,CAAC,MAAQ,OAAO;IAC3B;IACA,MAAM,gBAAgB;QAAC,UAAU;KAAG,CAAC,IAAI,GAAG,MAAM,CAAC;IACnD,MAAM,WAAW,oBAAoB;IACrC,OAAO,CAAC,MAAQ,SAAS,IAAI,CAAC,CAAC,UAAY,QAAQ,IAAI,CAAC,IAAI,OAAO,CAAC,QAAQ;AAChF;AACA,MAAM,sBAAsB,CAAC;IACzB,OAAO,SAAS,GAAG,CAAC,CAAC,UAAY,mBAAmB,SAAS,UAAU,mBAAmB;AAC9F;AACA,SAAS,mBAAmB,IAAI;IAC5B,IAAI;QACA,OAAO,IAAA,sLAAY,EAAC;IACxB,EACA,OAAO,GAAG;QACN,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK,iGAAiG,EAAE,EAAE,OAAO,EAAE;IACxJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 636, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/checks.js"],"sourcesContent":["// Some code adapted from Auth.js. Original license:\n//\n// ISC License\n//\n// Copyright (c) 2022-2024, Balázs Orbán\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\nimport { generateState } from \"arctic\";\nimport * as o from \"oauth4webapi\";\nconst SHARED_COOKIE_OPTIONS = {\n    httpOnly: true,\n    sameSite: \"none\",\n    secure: true,\n    path: \"/\",\n    partitioned: true,\n};\nexport const state = {\n    create(provider) {\n        const state = generateState();\n        const cookie = {\n            name: oauthStateCookieName(\"state\", provider.id),\n            value: state,\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: STATE_MAX_AGE },\n        };\n        return { state, cookie };\n    },\n    use(provider, cookies) {\n        const cookieName = oauthStateCookieName(\"state\", provider.id);\n        const state = cookies[cookieName];\n        if (state === undefined) {\n            throw new Error(\"state cookie is missing.\");\n        }\n        // Clear the state cookie after use\n        const updatedCookie = {\n            name: cookieName,\n            value: \"\",\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: 0 },\n        };\n        return { state, updatedCookie };\n    },\n};\nconst PKCE_MAX_AGE = 60 * 15; // 15 minutes in seconds\nexport const pkce = {\n    async create(provider) {\n        const codeVerifier = o.generateRandomCodeVerifier();\n        const codeChallenge = await o.calculatePKCECodeChallenge(codeVerifier);\n        const cookie = {\n            name: oauthStateCookieName(\"pkce\", provider.id),\n            value: codeVerifier,\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: PKCE_MAX_AGE },\n        };\n        return { codeChallenge, codeVerifier, cookie };\n    },\n    /**\n     * An error is thrown if the code_verifier is missing or invalid.\n     * @see https://www.rfc-editor.org/rfc/rfc7636\n     * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#pkce\n     */\n    use(provider, cookies) {\n        const cookieName = oauthStateCookieName(\"pkce\", provider.id);\n        const codeVerifier = cookies[cookieName];\n        if (codeVerifier === undefined) {\n            throw new Error(\"pkce cookie is missing.\");\n        }\n        // Clear the state cookie after use\n        const updatedCookie = {\n            name: cookieName,\n            value: \"\",\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: 0 },\n        };\n        return { codeVerifier, updatedCookie };\n    },\n};\nconst STATE_MAX_AGE = 60 * 15; // 15 minutes in seconds\nconst NONCE_MAX_AGE = 60 * 15; // 15 minutes in seconds\nexport const nonce = {\n    async create(provider) {\n        const nonce = o.generateRandomNonce();\n        const cookie = {\n            name: oauthStateCookieName(\"nonce\", provider.id),\n            value: nonce,\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: NONCE_MAX_AGE },\n        };\n        return { nonce, cookie };\n    },\n    /**\n     * An error is thrown if the nonce is missing or invalid.\n     * @see https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes\n     * @see https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/#nonce\n     */\n    use(provider, cookies) {\n        const cookieName = oauthStateCookieName(\"nonce\", provider.id);\n        const nonce = cookies[cookieName];\n        if (nonce === undefined) {\n            throw new Error(\"state cookie is missing.\");\n        }\n        // Clear the state cookie after use\n        const updatedCookie = {\n            name: cookieName,\n            value: \"\",\n            options: { ...SHARED_COOKIE_OPTIONS, maxAge: 0 },\n        };\n        return { nonce, updatedCookie };\n    },\n};\nconst REDIRECT_MAX_AGE = 60 * 15; // 15 minutes in seconds\nexport function redirectToParamCookie(providerId, redirectTo) {\n    return {\n        name: redirectToParamCookieName(providerId),\n        value: redirectTo,\n        options: { ...SHARED_COOKIE_OPTIONS, maxAge: REDIRECT_MAX_AGE },\n    };\n}\nexport function useRedirectToParam(providerId, cookies) {\n    const cookieName = redirectToParamCookieName(providerId);\n    const redirectTo = cookies[cookieName];\n    if (redirectTo === undefined) {\n        return null;\n    }\n    // Clear the cookie\n    const updatedCookie = {\n        name: cookieName,\n        value: \"\",\n        options: { ...SHARED_COOKIE_OPTIONS, maxAge: 0 },\n    };\n    return { redirectTo, updatedCookie };\n}\nfunction redirectToParamCookieName(providerId) {\n    return \"__Host-\" + providerId + \"RedirectTo\";\n}\nfunction oauthStateCookieName(type, providerId) {\n    return \"__Host-\" + providerId + \"OAuth\" + type;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 842, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/provider_utils.js"],"sourcesContent":["// Some code adapted from Auth.js. Original license:\n//\n// ISC License\n//\n// Copyright (c) 2022-2024, Balázs Orbán\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\nimport { setEnvDefaults } from \"@auth/core\";\n/**\n * @internal\n */\nexport function configDefaults(config_) {\n    const config = materializeAndDefaultProviders(config_);\n    // Collect extra providers\n    const extraProviders = config.providers\n        .filter((p) => p.type === \"credentials\")\n        .map((p) => p.extraProviders)\n        .flat()\n        .filter((p) => p !== undefined);\n    return {\n        ...config,\n        extraProviders: materializeProviders(extraProviders),\n        theme: config.theme ?? {\n            colorScheme: \"auto\",\n            logo: \"\",\n            brandColor: \"\",\n            buttonText: \"\",\n        },\n    };\n}\n/**\n * @internal\n */\nexport function materializeProvider(provider) {\n    const config = { providers: [provider] };\n    materializeAndDefaultProviders(config);\n    return config.providers[0];\n}\nfunction materializeProviders(providers) {\n    const config = { providers };\n    materializeAndDefaultProviders(config);\n    return config.providers;\n}\nfunction materializeAndDefaultProviders(config_) {\n    // Have to materialize first so that the correct env variables are used\n    const providers = config_.providers.map((provider) => providerDefaults(typeof provider === \"function\" ? provider() : provider));\n    const config = { ...config_, providers };\n    // Unfortunately mutates its argument\n    setEnvDefaults(process.env, config);\n    // Manually do this for new provider type\n    config.providers.forEach((provider) => {\n        if (provider.type === \"phone\") {\n            const ID = provider.id.toUpperCase().replace(/-/g, \"_\");\n            // Should not require this env var at push time, as the provider's\n            // implementation might not use it\n            provider.apiKey ??= process.env[`AUTH_${ID}_KEY`];\n        }\n    });\n    return config;\n}\nfunction providerDefaults(provider) {\n    // TODO: Add `redirectProxyUrl` to oauth providers\n    const merged = merge(provider, provider.options);\n    return merged.type === \"oauth\" || merged.type === \"oidc\"\n        ? normalizeOAuth(merged)\n        : merged;\n}\nconst defaultProfile = (profile) => {\n    return stripUndefined({\n        id: profile.sub ?? profile.id ?? crypto.randomUUID(),\n        name: profile.name ?? profile.nickname ?? profile.preferred_username,\n        email: profile.email ?? undefined,\n        image: profile.picture ?? undefined,\n    });\n};\nconst defaultAccount = (account) => {\n    return stripUndefined({\n        access_token: account.access_token,\n        id_token: account.id_token,\n        refresh_token: account.refresh_token,\n        expires_at: account.expires_at,\n        scope: account.scope,\n        token_type: account.token_type,\n        session_state: account.session_state,\n    });\n};\nfunction stripUndefined(o) {\n    const result = {};\n    for (const [k, v] of Object.entries(o))\n        v !== undefined && (result[k] = v);\n    return result;\n}\nfunction normalizeOAuth(c) {\n    if (c.issuer)\n        c.wellKnown ??= `${c.issuer}/.well-known/openid-configuration`;\n    const checks = c.checks ?? [\"pkce\"];\n    if (c.redirectProxyUrl) {\n        if (!checks.includes(\"state\"))\n            checks.push(\"state\");\n        c.redirectProxyUrl = `${c.redirectProxyUrl}/callback/${c.id}`;\n    }\n    return {\n        ...c,\n        checks,\n        profile: c.profile ?? defaultProfile,\n        account: c.account ?? defaultAccount,\n    };\n}\nexport const PLACEHOLDER_URL_HOST = \"convexauth.mumbojumbo\";\nconst PLACEHOLDER_URL = `https://${PLACEHOLDER_URL_HOST}`;\nexport function normalizeEndpoint(e, issuer) {\n    if (!e && issuer)\n        return undefined;\n    if (typeof e === \"string\") {\n        return { url: new URL(e) };\n    }\n    // Placeholder URL is used to pass around the URL object\n    // even if the URL hasn't been specified: the `issuer`\n    // is used instead.\n    const url = new URL(e?.url ?? PLACEHOLDER_URL);\n    if (e?.params != null) {\n        for (const [key, value] of Object.entries(e.params)) {\n            url.searchParams.set(key, String(key === \"claims\" ? JSON.stringify(value) : value));\n        }\n    }\n    return { url, request: e?.request, conform: e?.conform };\n}\n// Source: https://stackoverflow.com/a/34749873/5364135\n/**\n * Deep merge two objects\n *\n * @internal\n */\nexport function merge(target, ...sources) {\n    if (!sources.length)\n        return target;\n    const source = sources.shift();\n    if (isObject(target) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!target[key])\n                    Object.assign(target, { [key]: {} });\n                merge(target[key], source[key]);\n            }\n            else {\n                Object.assign(target, { [key]: source[key] });\n            }\n        }\n    }\n    return merge(target, ...sources);\n}\n/** Simple object check */\nfunction isObject(item) {\n    return item && typeof item === \"object\" && !Array.isArray(item);\n}\n/**\n * @internal\n */\nexport function listAvailableProviders(config, allowExtraProviders) {\n    const availableProviders = config.providers\n        .concat(allowExtraProviders ? config.extraProviders : [])\n        .map((provider) => `\\`${provider.id}\\``);\n    return availableProviders.length > 0\n        ? availableProviders.join(\", \")\n        : \"no providers have been configured\";\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1026, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/utils.js"],"sourcesContent":["export function requireEnv(name) {\n    const value = process.env[name];\n    if (value === undefined) {\n        throw new Error(`Missing environment variable \\`${name}\\``);\n    }\n    return value;\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,WAAW,IAAI;IAC3B,MAAM,QAAQ,QAAQ,GAAG,CAAC,KAAK;IAC/B,IAAI,UAAU,WAAW;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,KAAK,EAAE,CAAC;IAC9D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1043, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/utils.js"],"sourcesContent":["import { sha256 as rawSha256 } from \"oslo/crypto\";\nimport { encodeHex } from \"oslo/encoding\";\nexport const TOKEN_SUB_CLAIM_DIVIDER = \"|\";\nexport const REFRESH_TOKEN_DIVIDER = \"|\";\nexport function stringToNumber(value) {\n    return value !== undefined ? Number(value) : undefined;\n}\nexport async function sha256(input) {\n    return encodeHex(await rawSha256(new TextEncoder().encode(input)));\n}\nexport function logError(error) {\n    logWithLevel(LOG_LEVELS.ERROR, error instanceof Error\n        ? error.message + \"\\n\" + error.stack?.replace(\"\\\\n\", \"\\n\")\n        : error);\n}\nexport const LOG_LEVELS = {\n    ERROR: \"ERROR\",\n    WARN: \"WARN\",\n    INFO: \"INFO\",\n    DEBUG: \"DEBUG\",\n};\nexport function logWithLevel(level, ...args) {\n    const configuredLogLevel = LOG_LEVELS[process.env.AUTH_LOG_LEVEL ?? \"INFO\"] ?? \"INFO\";\n    switch (level) {\n        case \"ERROR\":\n            console.error(...args);\n            break;\n        case \"WARN\":\n            if (configuredLogLevel !== \"ERROR\") {\n                console.warn(...args);\n            }\n            break;\n        case \"INFO\":\n            if (configuredLogLevel === \"INFO\" || configuredLogLevel === \"DEBUG\") {\n                console.info(...args);\n            }\n            break;\n        case \"DEBUG\":\n            if (configuredLogLevel === \"DEBUG\") {\n                console.debug(...args);\n            }\n            break;\n    }\n}\nexport function maybeRedact(value) {\n    if (value === \"\") {\n        return \"\";\n    }\n    const shouldRedact = process.env.AUTH_LOG_SECRETS !== \"true\";\n    if (shouldRedact) {\n        if (value.length < 6) {\n            return \"<redacted>\";\n        }\n        return (value.substring(0, 3) + \"<redacted>\" + value.substring(value.length - 3));\n    }\n    else {\n        return value;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;;;;;;;;AACO,MAAM,0BAA0B;AAChC,MAAM,wBAAwB;AAC9B,SAAS,eAAe,KAAK;IAChC,OAAO,UAAU,YAAY,OAAO,SAAS;AACjD;AACO,eAAe,OAAO,KAAK;IAC9B,OAAO,IAAA,6IAAS,EAAC,MAAM,IAAA,sIAAS,EAAC,IAAI,cAAc,MAAM,CAAC;AAC9D;AACO,SAAS,SAAS,KAAK;IAC1B,aAAa,WAAW,KAAK,EAAE,iBAAiB,QAC1C,MAAM,OAAO,GAAG,OAAO,MAAM,KAAK,EAAE,QAAQ,OAAO,QACnD;AACV;AACO,MAAM,aAAa;IACtB,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;AACX;AACO,SAAS,aAAa,KAAK,EAAE,GAAG,IAAI;IACvC,MAAM,qBAAqB,UAAU,CAAC,QAAQ,GAAG,CAAC,cAAc,IAAI,OAAO,IAAI;IAC/E,OAAQ;QACJ,KAAK;YACD,QAAQ,KAAK,IAAI;YACjB;QACJ,KAAK;YACD,IAAI,uBAAuB,SAAS;gBAChC,QAAQ,IAAI,IAAI;YACpB;YACA;QACJ,KAAK;YACD,IAAI,uBAAuB,UAAU,uBAAuB,SAAS;gBACjE,QAAQ,IAAI,IAAI;YACpB;YACA;QACJ,KAAK;YACD,IAAI,uBAAuB,SAAS;gBAChC,QAAQ,KAAK,IAAI;YACrB;YACA;IACR;AACJ;AACO,SAAS,YAAY,KAAK;IAC7B,IAAI,UAAU,IAAI;QACd,OAAO;IACX;IACA,MAAM,eAAe,QAAQ,GAAG,CAAC,gBAAgB,KAAK;IACtD,IAAI,cAAc;QACd,IAAI,MAAM,MAAM,GAAG,GAAG;YAClB,OAAO;QACX;QACA,OAAQ,MAAM,SAAS,CAAC,GAAG,KAAK,eAAe,MAAM,SAAS,CAAC,MAAM,MAAM,GAAG;IAClF,OACK;QACD,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1131, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/oauth.js"],"sourcesContent":["// Some code adapted from Auth.js. Original license:\n//\n// ISC License\n//\n// Copyright (c) 2022-2024, Balázs Orbán\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\nimport * as o from \"oauth4webapi\";\nimport * as checks from \"./checks.js\";\nimport { normalizeEndpoint } from \"./provider_utils.js\";\nimport { requireEnv } from \"./utils.js\";\nimport { LOG_LEVELS, logWithLevel } from \"./implementation/utils.js\";\nexport async function getAuthorizationURL(provider) {\n    const { authorization, server, checks: providerChecks, } = await getOAuthConfig(provider);\n    const url = authorization.url;\n    const authParams = url.searchParams;\n    const redirect_uri = callbackUrl(provider.id);\n    // let data: object | undefined;\n    // TODO(convex auth): Support redirect proxy\n    // if (!options.isOnRedirectProxy && provider.redirectProxyUrl) {\n    //   redirect_uri = provider.redirectProxyUrl;\n    //   data = { origin: provider.callbackUrl };\n    //   logger.debug(\"using redirect proxy\", { redirect_uri, data });\n    // }\n    if (provider.clientId === undefined) {\n        throw new Error(`Missing \\`clientId\\`, set \\`${clientId(provider.id)}\\``);\n    }\n    if (provider.clientSecret === undefined) {\n        throw new Error(`Missing \\`clientSecret\\`, set \\`${clientSecret(provider.id)}\\``);\n    }\n    for (const [key, value] of Object.entries({\n        response_type: \"code\",\n        // clientId can technically be undefined, should we check this in assert.ts or rely on the Authorization Server to do it?\n        client_id: provider.clientId,\n        redirect_uri,\n        // (convex-auth) Ugh here we use\n        // the original params config from the provider\n        // @ts-expect-error TODO:\n        ...provider.authorization?.params,\n    })) {\n        authParams.set(key, value);\n    }\n    const cookies = [];\n    if (provider.checks?.includes(\"state\")) {\n        const { state, cookie } = checks.state.create(provider);\n        authParams.set(\"state\", state);\n        cookies.push(cookie);\n    }\n    let codeVerifier;\n    if (providerChecks?.includes(\"pkce\")) {\n        if (server === null ||\n            server.code_challenge_methods_supported?.includes(\"S256\")) {\n            const result = await checks.pkce.create(provider);\n            authParams.set(\"code_challenge\", result.codeChallenge);\n            authParams.set(\"code_challenge_method\", \"S256\");\n            cookies.push(result.cookie);\n            codeVerifier = result.codeVerifier;\n        }\n    }\n    // @ts-expect-error TS is confused by the combined types\n    if (providerChecks?.includes(\"nonce\")) {\n        const { nonce, cookie } = await checks.nonce.create(provider);\n        authParams.set(\"nonce\", nonce);\n        cookies.push(cookie);\n    }\n    if (!url.searchParams.has(\"scope\")) {\n        authParams.set(\"scope\", \"openid profile email\");\n    }\n    // logger.debug(\"authorization url is ready\", { url, cookies, provider });\n    return {\n        redirect: url.toString(),\n        cookies,\n        signature: getAuthorizationSignature({\n            codeVerifier,\n            state: authParams.get(\"state\") ?? undefined,\n            nonce: authParams.get(\"nonce\") ?? undefined,\n        }),\n    };\n}\nexport async function handleOAuthCallback(provider, request, cookies) {\n    const { userinfo, server: realServer, fakeServer, checks: providerChecks, } = await getOAuthConfig(provider);\n    const server = realServer ?? fakeServer;\n    const client = {\n        client_id: provider.clientId,\n        client_secret: provider.clientSecret,\n        ...provider.client,\n    };\n    const updatedCookies = [];\n    let state;\n    if (providerChecks?.includes(\"state\")) {\n        const result = checks.state.use(provider, cookies);\n        updatedCookies.push(result.updatedCookie);\n        state = result.state;\n    }\n    const params = new URL(request.url).searchParams;\n    // Handle OAuth providers that use formData (such as Apple)\n    if (request.headers.get(\"Content-Type\") === \"application/x-www-form-urlencoded\") {\n        const formData = await request.formData();\n        for (const [key, value] of formData.entries()) {\n            if (typeof value === \"string\") {\n                params.append(key, value);\n            }\n        }\n    }\n    const codeGrantParams = o.validateAuthResponse(server, client, params, providerChecks?.includes(\"state\") ? state : o.skipStateCheck);\n    /** https://www.rfc-editor.org/rfc/rfc6749#section-4.1.2.1 */\n    if (o.isOAuth2Error(codeGrantParams)) {\n        const cause = { providerId: provider.id, ...codeGrantParams };\n        throw new Error(\"OAuth Provider returned an error \" + JSON.stringify(cause));\n    }\n    let codeVerifier;\n    if (providerChecks?.includes(\"pkce\")) {\n        const result = checks.pkce.use(provider, cookies);\n        updatedCookies.push(result.updatedCookie);\n        codeVerifier = result.codeVerifier;\n    }\n    const redirect_uri = callbackUrl(provider.id);\n    // TODO(convex auth): Support redirect proxy\n    // if (!options.isOnRedirectProxy && provider.redirectProxyUrl) {\n    //   redirect_uri = provider.redirectProxyUrl;\n    // }\n    let codeGrantResponse = await o.authorizationCodeGrantRequest(server, client, codeGrantParams, redirect_uri, codeVerifier ?? \"auth\", // TODO: review fallback code verifier,\n    {\n        // https://github.com/nextauthjs/next-auth/pull/10765\n        [o.customFetch]: (...args) => {\n            if (!providerChecks.includes(\"pkce\") &&\n                args[1]?.body instanceof URLSearchParams) {\n                args[1].body.delete(\"code_verifier\");\n            }\n            return fetch(...args);\n        },\n    });\n    if (provider.token?.conform) {\n        codeGrantResponse =\n            (await provider.token.conform(codeGrantResponse.clone())) ??\n                codeGrantResponse;\n    }\n    if (o.parseWwwAuthenticateChallenges(codeGrantResponse)) {\n        throw new Error(\"www-authenticate challenges are not supported atm\");\n    }\n    let profile = {};\n    let tokens;\n    let nonce;\n    if (provider.type === \"oidc\") {\n        // @ts-expect-error TS is confused by the combined types\n        if (providerChecks?.includes(\"nonce\")) {\n            const result = checks.nonce.use(provider, cookies);\n            updatedCookies.push(result.updatedCookie);\n            nonce = result.nonce;\n        }\n        const result = await o.processAuthorizationCodeOpenIDResponse(server, client, codeGrantResponse, nonce ?? o.expectNoNonce);\n        if (o.isOAuth2Error(result)) {\n            logWithLevel(LOG_LEVELS.ERROR, \"OAuth2 error:\", result);\n            throw new Error(\"OIDC response body error\");\n        }\n        profile = o.getValidatedIdTokenClaims(result);\n        tokens = result;\n    }\n    else {\n        tokens = await o.processAuthorizationCodeOAuth2Response(server, client, codeGrantResponse);\n        if (o.isOAuth2Error(tokens)) {\n            logWithLevel(LOG_LEVELS.ERROR, \"OAuth2 error:\", tokens);\n            throw new Error(\"OAuth response body error\");\n        }\n        if (userinfo?.request) {\n            const _profile = await userinfo.request({ tokens, provider });\n            if (_profile instanceof Object)\n                profile = _profile;\n        }\n        else if (userinfo?.url) {\n            const userinfoResponse = await o.userInfoRequest(server, client, tokens.access_token);\n            profile = await userinfoResponse.json();\n        }\n        else {\n            logWithLevel(LOG_LEVELS.WARN, `No userinfo endpoint configured for ${provider.id}`);\n        }\n    }\n    if (tokens.expires_in) {\n        tokens.expires_at =\n            Math.floor(Date.now() / 1000) + Number(tokens.expires_in);\n    }\n    return {\n        profile,\n        cookies: updatedCookies,\n        tokens,\n        signature: getAuthorizationSignature({ codeVerifier, state, nonce }),\n    };\n}\n// TODO(convex auth): We need to support custom callback URLs\nfunction callbackUrl(providerId) {\n    return requireEnv(\"CONVEX_SITE_URL\") + \"/api/auth/callback/\" + providerId;\n}\nfunction getAuthorizationSignature({ codeVerifier, state, nonce, }) {\n    return [codeVerifier, state, nonce]\n        .filter((param) => param !== undefined)\n        .join(\" \");\n}\nfunction clientId(providerId) {\n    return `AUTH_${envProviderId(providerId)}_ID`;\n}\nfunction clientSecret(providerId) {\n    return `AUTH_${envProviderId(providerId)}_SECRET`;\n}\nfunction envProviderId(provider) {\n    return provider.toUpperCase().replace(/-/g, \"_\");\n}\nasync function getOAuthConfig(provider) {\n    if (!provider.authorization || !provider.token || !provider.userinfo) {\n        if (!provider.issuer) {\n            throw new Error(`Provider \\`${provider.id}\\` is missing an \\`issuer\\` URL configuration. Consult the provider docs.`);\n        }\n        const discovery = `${provider.issuer.replace(/\\/$/, \"\")}/.well-known/openid-configuration`;\n        const response = await fetch(discovery);\n        const config = await response.json();\n        return {\n            ...provider,\n            checks: provider.type === \"oidc\" &&\n                provider.checks?.includes(\"pkce\") &&\n                !config.code_challenge_methods_supported?.includes(\"S256\")\n                ? [\"nonce\"]\n                : provider.checks,\n            server: config,\n            fakeServer: null,\n            authorization: normalizeEndpoint({\n                ...provider.authorization,\n                url: new URL(config.authorization_endpoint),\n            }),\n            token: normalizeEndpoint({\n                ...provider.token,\n                url: new URL(config.token_endpoint),\n            }),\n            userinfo: config.userinfo_endpoint\n                ? normalizeEndpoint({\n                    ...provider.userinfo,\n                    url: new URL(config.userinfo_endpoint),\n                })\n                : provider.userinfo,\n        };\n    }\n    else {\n        const authorization = normalizeEndpoint(provider.authorization);\n        const token = normalizeEndpoint(provider.token);\n        const userinfo = provider.userinfo\n            ? normalizeEndpoint(provider.userinfo)\n            : undefined;\n        return {\n            ...provider,\n            authorization,\n            token,\n            userinfo,\n            fakeServer: {\n                issuer: provider.issuer ?? \"theremustbeastringhere.dev\",\n                authorization_endpoint: authorization?.url.toString(),\n                token_endpoint: token?.url.toString(),\n                userinfo_endpoint: userinfo?.url.toString(),\n            },\n            server: null,\n        };\n    }\n}\n"],"names":[],"mappings":"AAAA,oDAAoD;AACpD,EAAE;AACF,cAAc;AACd,EAAE;AACF,wCAAwC;AACxC,EAAE;AACF,2EAA2E;AAC3E,yEAAyE;AACzE,oEAAoE;AACpE,EAAE;AACF,2EAA2E;AAC3E,mEAAmE;AACnE,0EAA0E;AAC1E,yEAAyE;AACzE,wEAAwE;AACxE,0EAA0E;AAC1E,iEAAiE;;;;;;;AACjE;AACA;AACA;AACA;AACA;;;;;;;;;;AACO,eAAe,oBAAoB,QAAQ;IAC9C,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,QAAQ,cAAc,EAAG,GAAG,MAAM,eAAe;IAChF,MAAM,MAAM,cAAc,GAAG;IAC7B,MAAM,aAAa,IAAI,YAAY;IACnC,MAAM,eAAe,YAAY,SAAS,EAAE;IAC5C,gCAAgC;IAChC,4CAA4C;IAC5C,iEAAiE;IACjE,8CAA8C;IAC9C,6CAA6C;IAC7C,kEAAkE;IAClE,IAAI;IACJ,IAAI,SAAS,QAAQ,KAAK,WAAW;QACjC,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,SAAS,SAAS,EAAE,EAAE,EAAE,CAAC;IAC5E;IACA,IAAI,SAAS,YAAY,KAAK,WAAW;QACrC,MAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,aAAa,SAAS,EAAE,EAAE,EAAE,CAAC;IACpF;IACA,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC;QACtC,eAAe;QACf,yHAAyH;QACzH,WAAW,SAAS,QAAQ;QAC5B;QACA,gCAAgC;QAChC,+CAA+C;QAC/C,yBAAyB;QACzB,GAAG,SAAS,aAAa,EAAE,MAAM;IACrC,GAAI;QACA,WAAW,GAAG,CAAC,KAAK;IACxB;IACA,MAAM,UAAU,EAAE;IAClB,IAAI,SAAS,MAAM,EAAE,SAAS,UAAU;QACpC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,6LAAY,CAAC,MAAM,CAAC;QAC9C,WAAW,GAAG,CAAC,SAAS;QACxB,QAAQ,IAAI,CAAC;IACjB;IACA,IAAI;IACJ,IAAI,gBAAgB,SAAS,SAAS;QAClC,IAAI,WAAW,QACX,OAAO,gCAAgC,EAAE,SAAS,SAAS;YAC3D,MAAM,SAAS,MAAM,4LAAW,CAAC,MAAM,CAAC;YACxC,WAAW,GAAG,CAAC,kBAAkB,OAAO,aAAa;YACrD,WAAW,GAAG,CAAC,yBAAyB;YACxC,QAAQ,IAAI,CAAC,OAAO,MAAM;YAC1B,eAAe,OAAO,YAAY;QACtC;IACJ;IACA,wDAAwD;IACxD,IAAI,gBAAgB,SAAS,UAAU;QACnC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,MAAM,6LAAY,CAAC,MAAM,CAAC;QACpD,WAAW,GAAG,CAAC,SAAS;QACxB,QAAQ,IAAI,CAAC;IACjB;IACA,IAAI,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,UAAU;QAChC,WAAW,GAAG,CAAC,SAAS;IAC5B;IACA,0EAA0E;IAC1E,OAAO;QACH,UAAU,IAAI,QAAQ;QACtB;QACA,WAAW,0BAA0B;YACjC;YACA,OAAO,WAAW,GAAG,CAAC,YAAY;YAClC,OAAO,WAAW,GAAG,CAAC,YAAY;QACtC;IACJ;AACJ;AACO,eAAe,oBAAoB,QAAQ,EAAE,OAAO,EAAE,OAAO;IAChE,MAAM,EAAE,QAAQ,EAAE,QAAQ,UAAU,EAAE,UAAU,EAAE,QAAQ,cAAc,EAAG,GAAG,MAAM,eAAe;IACnG,MAAM,SAAS,cAAc;IAC7B,MAAM,SAAS;QACX,WAAW,SAAS,QAAQ;QAC5B,eAAe,SAAS,YAAY;QACpC,GAAG,SAAS,MAAM;IACtB;IACA,MAAM,iBAAiB,EAAE;IACzB,IAAI;IACJ,IAAI,gBAAgB,SAAS,UAAU;QACnC,MAAM,SAAS,6LAAY,CAAC,GAAG,CAAC,UAAU;QAC1C,eAAe,IAAI,CAAC,OAAO,aAAa;QACxC,QAAQ,OAAO,KAAK;IACxB;IACA,MAAM,SAAS,IAAI,IAAI,QAAQ,GAAG,EAAE,YAAY;IAChD,2DAA2D;IAC3D,IAAI,QAAQ,OAAO,CAAC,GAAG,CAAC,oBAAoB,qCAAqC;QAC7E,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,SAAS,OAAO,GAAI;YAC3C,IAAI,OAAO,UAAU,UAAU;gBAC3B,OAAO,MAAM,CAAC,KAAK;YACvB;QACJ;IACJ;IACA,MAAM,kBAAkB,wKAAsB,CAAC,QAAQ,QAAQ,QAAQ,gBAAgB,SAAS,WAAW,QAAQ,kKAAgB;IACnI,2DAA2D,GAC3D,IAAI,iKAAe,CAAC,kBAAkB;QAClC,MAAM,QAAQ;YAAE,YAAY,SAAS,EAAE;YAAE,GAAG,eAAe;QAAC;QAC5D,MAAM,IAAI,MAAM,sCAAsC,KAAK,SAAS,CAAC;IACzE;IACA,IAAI;IACJ,IAAI,gBAAgB,SAAS,SAAS;QAClC,MAAM,SAAS,4LAAW,CAAC,GAAG,CAAC,UAAU;QACzC,eAAe,IAAI,CAAC,OAAO,aAAa;QACxC,eAAe,OAAO,YAAY;IACtC;IACA,MAAM,eAAe,YAAY,SAAS,EAAE;IAC5C,4CAA4C;IAC5C,iEAAiE;IACjE,8CAA8C;IAC9C,IAAI;IACJ,IAAI,oBAAoB,MAAM,iLAA+B,CAAC,QAAQ,QAAQ,iBAAiB,cAAc,gBAAgB,QAC7H;QACI,qDAAqD;QACrD,CAAC,+JAAa,CAAC,EAAE,CAAC,GAAG;YACjB,IAAI,CAAC,eAAe,QAAQ,CAAC,WACzB,IAAI,CAAC,EAAE,EAAE,gBAAgB,iBAAiB;gBAC1C,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC;YACxB;YACA,OAAO,SAAS;QACpB;IACJ;IACA,IAAI,SAAS,KAAK,EAAE,SAAS;QACzB,oBACI,AAAC,MAAM,SAAS,KAAK,CAAC,OAAO,CAAC,kBAAkB,KAAK,OACjD;IACZ;IACA,IAAI,kLAAgC,CAAC,oBAAoB;QACrD,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,UAAU,CAAC;IACf,IAAI;IACJ,IAAI;IACJ,IAAI,SAAS,IAAI,KAAK,QAAQ;QAC1B,wDAAwD;QACxD,IAAI,gBAAgB,SAAS,UAAU;YACnC,MAAM,SAAS,6LAAY,CAAC,GAAG,CAAC,UAAU;YAC1C,eAAe,IAAI,CAAC,OAAO,aAAa;YACxC,QAAQ,OAAO,KAAK;QACxB;QACA,MAAM,SAAS,MAAM,0LAAwC,CAAC,QAAQ,QAAQ,mBAAmB,SAAS,iKAAe;QACzH,IAAI,iKAAe,CAAC,SAAS;YACzB,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,iBAAiB;YAChD,MAAM,IAAI,MAAM;QACpB;QACA,UAAU,6KAA2B,CAAC;QACtC,SAAS;IACb,OACK;QACD,SAAS,MAAM,0LAAwC,CAAC,QAAQ,QAAQ;QACxE,IAAI,iKAAe,CAAC,SAAS;YACzB,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,iBAAiB;YAChD,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,UAAU,SAAS;YACnB,MAAM,WAAW,MAAM,SAAS,OAAO,CAAC;gBAAE;gBAAQ;YAAS;YAC3D,IAAI,oBAAoB,QACpB,UAAU;QAClB,OACK,IAAI,UAAU,KAAK;YACpB,MAAM,mBAAmB,MAAM,mKAAiB,CAAC,QAAQ,QAAQ,OAAO,YAAY;YACpF,UAAU,MAAM,iBAAiB,IAAI;QACzC,OACK;YACD,IAAA,qNAAY,EAAC,mNAAU,CAAC,IAAI,EAAE,CAAC,oCAAoC,EAAE,SAAS,EAAE,EAAE;QACtF;IACJ;IACA,IAAI,OAAO,UAAU,EAAE;QACnB,OAAO,UAAU,GACb,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,QAAQ,OAAO,OAAO,UAAU;IAChE;IACA,OAAO;QACH;QACA,SAAS;QACT;QACA,WAAW,0BAA0B;YAAE;YAAc;YAAO;QAAM;IACtE;AACJ;AACA,6DAA6D;AAC7D,SAAS,YAAY,UAAU;IAC3B,OAAO,IAAA,iMAAU,EAAC,qBAAqB,wBAAwB;AACnE;AACA,SAAS,0BAA0B,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAG;IAC9D,OAAO;QAAC;QAAc;QAAO;KAAM,CAC9B,MAAM,CAAC,CAAC,QAAU,UAAU,WAC5B,IAAI,CAAC;AACd;AACA,SAAS,SAAS,UAAU;IACxB,OAAO,CAAC,KAAK,EAAE,cAAc,YAAY,GAAG,CAAC;AACjD;AACA,SAAS,aAAa,UAAU;IAC5B,OAAO,CAAC,KAAK,EAAE,cAAc,YAAY,OAAO,CAAC;AACrD;AACA,SAAS,cAAc,QAAQ;IAC3B,OAAO,SAAS,WAAW,GAAG,OAAO,CAAC,MAAM;AAChD;AACA,eAAe,eAAe,QAAQ;IAClC,IAAI,CAAC,SAAS,aAAa,IAAI,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,QAAQ,EAAE;QAClE,IAAI,CAAC,SAAS,MAAM,EAAE;YAClB,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,SAAS,EAAE,CAAC,yEAAyE,CAAC;QACxH;QACA,MAAM,YAAY,GAAG,SAAS,MAAM,CAAC,OAAO,CAAC,OAAO,IAAI,iCAAiC,CAAC;QAC1F,MAAM,WAAW,MAAM,MAAM;QAC7B,MAAM,SAAS,MAAM,SAAS,IAAI;QAClC,OAAO;YACH,GAAG,QAAQ;YACX,QAAQ,SAAS,IAAI,KAAK,UACtB,SAAS,MAAM,EAAE,SAAS,WAC1B,CAAC,OAAO,gCAAgC,EAAE,SAAS,UACjD;gBAAC;aAAQ,GACT,SAAS,MAAM;YACrB,QAAQ;YACR,YAAY;YACZ,eAAe,IAAA,iNAAiB,EAAC;gBAC7B,GAAG,SAAS,aAAa;gBACzB,KAAK,IAAI,IAAI,OAAO,sBAAsB;YAC9C;YACA,OAAO,IAAA,iNAAiB,EAAC;gBACrB,GAAG,SAAS,KAAK;gBACjB,KAAK,IAAI,IAAI,OAAO,cAAc;YACtC;YACA,UAAU,OAAO,iBAAiB,GAC5B,IAAA,iNAAiB,EAAC;gBAChB,GAAG,SAAS,QAAQ;gBACpB,KAAK,IAAI,IAAI,OAAO,iBAAiB;YACzC,KACE,SAAS,QAAQ;QAC3B;IACJ,OACK;QACD,MAAM,gBAAgB,IAAA,iNAAiB,EAAC,SAAS,aAAa;QAC9D,MAAM,QAAQ,IAAA,iNAAiB,EAAC,SAAS,KAAK;QAC9C,MAAM,WAAW,SAAS,QAAQ,GAC5B,IAAA,iNAAiB,EAAC,SAAS,QAAQ,IACnC;QACN,OAAO;YACH,GAAG,QAAQ;YACX;YACA;YACA;YACA,YAAY;gBACR,QAAQ,SAAS,MAAM,IAAI;gBAC3B,wBAAwB,eAAe,IAAI;gBAC3C,gBAAgB,OAAO,IAAI;gBAC3B,mBAAmB,UAAU,IAAI;YACrC;YACA,QAAQ;QACZ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1415, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/provider.js"],"sourcesContent":["export async function hash(provider, secret) {\n    if (provider.type !== \"credentials\") {\n        throw new Error(`Provider ${provider.id} is not a credentials provider`);\n    }\n    const hashSecretFn = provider.crypto?.hashSecret;\n    if (hashSecretFn === undefined) {\n        throw new Error(`Provider ${provider.id} does not have a \\`crypto.hashSecret\\` function`);\n    }\n    return await hashSecretFn(secret);\n}\nexport async function verify(provider, secret, hash) {\n    if (provider.type !== \"credentials\") {\n        throw new Error(`Provider ${provider.id} is not a credentials provider`);\n    }\n    const verifySecretFn = provider.crypto?.verifySecret;\n    if (verifySecretFn === undefined) {\n        throw new Error(`Provider ${provider.id} does not have a \\`crypto.verifySecret\\` function`);\n    }\n    return await verifySecretFn(secret, hash);\n}\n"],"names":[],"mappings":";;;;;;AAAO,eAAe,KAAK,QAAQ,EAAE,MAAM;IACvC,IAAI,SAAS,IAAI,KAAK,eAAe;QACjC,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,8BAA8B,CAAC;IAC3E;IACA,MAAM,eAAe,SAAS,MAAM,EAAE;IACtC,IAAI,iBAAiB,WAAW;QAC5B,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,+CAA+C,CAAC;IAC5F;IACA,OAAO,MAAM,aAAa;AAC9B;AACO,eAAe,OAAO,QAAQ,EAAE,MAAM,EAAE,IAAI;IAC/C,IAAI,SAAS,IAAI,KAAK,eAAe;QACjC,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,8BAA8B,CAAC;IAC3E;IACA,MAAM,iBAAiB,SAAS,MAAM,EAAE;IACxC,IAAI,mBAAmB,WAAW;QAC9B,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,iDAAiD,CAAC;IAC9F;IACA,OAAO,MAAM,eAAe,QAAQ;AACxC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1447, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/users.js"],"sourcesContent":["import { LOG_LEVELS, logWithLevel } from \"./utils.js\";\nexport async function upsertUserAndAccount(ctx, sessionId, account, args, config) {\n    const userId = await defaultCreateOrUpdateUser(ctx, sessionId, \"existingAccount\" in account ? account.existingAccount : null, args, config);\n    const accountId = await createOrUpdateAccount(ctx, userId, account, args);\n    return { userId, accountId };\n}\nasync function defaultCreateOrUpdateUser(ctx, existingSessionId, existingAccount, args, config) {\n    logWithLevel(LOG_LEVELS.DEBUG, \"defaultCreateOrUpdateUser args:\", {\n        existingAccountId: existingAccount?._id,\n        existingSessionId,\n        args,\n    });\n    const existingUserId = existingAccount?.userId ?? null;\n    if (config.callbacks?.createOrUpdateUser !== undefined) {\n        logWithLevel(LOG_LEVELS.DEBUG, \"Using custom createOrUpdateUser callback\");\n        return await config.callbacks.createOrUpdateUser(ctx, {\n            existingUserId,\n            ...args,\n        });\n    }\n    const { provider, profile: { emailVerified: profileEmailVerified, phoneVerified: profilePhoneVerified, ...profile }, } = args;\n    const emailVerified = profileEmailVerified ??\n        ((provider.type === \"oauth\" || provider.type === \"oidc\") &&\n            provider.allowDangerousEmailAccountLinking !== false);\n    const phoneVerified = profilePhoneVerified ?? false;\n    const shouldLinkViaEmail = args.shouldLinkViaEmail || emailVerified || provider.type === \"email\";\n    const shouldLinkViaPhone = args.shouldLinkViaPhone || phoneVerified || provider.type === \"phone\";\n    let userId = existingUserId;\n    if (existingUserId === null) {\n        const existingUserWithVerifiedEmailId = typeof profile.email === \"string\" && shouldLinkViaEmail\n            ? (await uniqueUserWithVerifiedEmail(ctx, profile.email))?._id ?? null\n            : null;\n        const existingUserWithVerifiedPhoneId = typeof profile.phone === \"string\" && shouldLinkViaPhone\n            ? (await uniqueUserWithVerifiedPhone(ctx, profile.phone))?._id ?? null\n            : null;\n        // If there is both email and phone verified user\n        // already we can't link.\n        if (existingUserWithVerifiedEmailId !== null &&\n            existingUserWithVerifiedPhoneId !== null) {\n            logWithLevel(LOG_LEVELS.DEBUG, `Found existing email and phone verified users, so not linking: email: ${existingUserWithVerifiedEmailId}, phone: ${existingUserWithVerifiedPhoneId}`);\n            userId = null;\n        }\n        else if (existingUserWithVerifiedEmailId !== null) {\n            logWithLevel(LOG_LEVELS.DEBUG, `Found existing email verified user, linking: ${existingUserWithVerifiedEmailId}`);\n            userId = existingUserWithVerifiedEmailId;\n        }\n        else if (existingUserWithVerifiedPhoneId !== null) {\n            logWithLevel(LOG_LEVELS.DEBUG, `Found existing phone verified user, linking: ${existingUserWithVerifiedPhoneId}`);\n            userId = existingUserWithVerifiedPhoneId;\n        }\n        else {\n            logWithLevel(LOG_LEVELS.DEBUG, \"No existing verified users found, creating new user\");\n            userId = null;\n        }\n    }\n    const userData = {\n        ...(emailVerified ? { emailVerificationTime: Date.now() } : null),\n        ...(phoneVerified ? { phoneVerificationTime: Date.now() } : null),\n        ...profile,\n    };\n    const existingOrLinkedUserId = userId;\n    if (userId !== null) {\n        try {\n            await ctx.db.patch(userId, userData);\n        }\n        catch (error) {\n            throw new Error(`Could not update user document with ID \\`${userId}\\`, ` +\n                `either the user has been deleted but their account has not, ` +\n                `or the profile data doesn't match the \\`users\\` table schema: ` +\n                `${error.message}`);\n        }\n    }\n    else {\n        userId = await ctx.db.insert(\"users\", userData);\n    }\n    const afterUserCreatedOrUpdated = config.callbacks?.afterUserCreatedOrUpdated;\n    if (afterUserCreatedOrUpdated !== undefined) {\n        logWithLevel(LOG_LEVELS.DEBUG, \"Calling custom afterUserCreatedOrUpdated callback\");\n        await afterUserCreatedOrUpdated(ctx, {\n            userId,\n            existingUserId: existingOrLinkedUserId,\n            ...args,\n        });\n    }\n    else {\n        logWithLevel(LOG_LEVELS.DEBUG, \"No custom afterUserCreatedOrUpdated callback, skipping\");\n    }\n    return userId;\n}\nasync function uniqueUserWithVerifiedEmail(ctx, email) {\n    const users = await ctx.db\n        .query(\"users\")\n        .withIndex(\"email\", (q) => q.eq(\"email\", email))\n        .filter((q) => q.neq(q.field(\"emailVerificationTime\"), undefined))\n        .take(2);\n    return users.length === 1 ? users[0] : null;\n}\nasync function uniqueUserWithVerifiedPhone(ctx, phone) {\n    const users = await ctx.db\n        .query(\"users\")\n        .withIndex(\"phone\", (q) => q.eq(\"phone\", phone))\n        .filter((q) => q.neq(q.field(\"phoneVerificationTime\"), undefined))\n        .take(2);\n    return users.length === 1 ? users[0] : null;\n}\nasync function createOrUpdateAccount(ctx, userId, account, args) {\n    const accountId = \"existingAccount\" in account\n        ? account.existingAccount._id\n        : await ctx.db.insert(\"authAccounts\", {\n            userId,\n            provider: args.provider.id,\n            providerAccountId: account.providerAccountId,\n            secret: account.secret,\n        });\n    // This is never used with the default `createOrUpdateUser` implementation,\n    // but it is used for manual linking via custom `createOrUpdateUser`:\n    if (\"existingAccount\" in account &&\n        account.existingAccount.userId !== userId) {\n        await ctx.db.patch(accountId, { userId });\n    }\n    if (args.profile.emailVerified) {\n        await ctx.db.patch(accountId, { emailVerified: args.profile.email });\n    }\n    if (args.profile.phoneVerified) {\n        await ctx.db.patch(accountId, { phoneVerified: args.profile.phone });\n    }\n    return accountId;\n}\nexport async function getAccountOrThrow(ctx, existingAccountId) {\n    const existingAccount = await ctx.db.get(existingAccountId);\n    if (existingAccount === null) {\n        throw new Error(`Expected an account to exist for ID \"${existingAccountId}\"`);\n    }\n    return existingAccount;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1586, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/tokens.js"],"sourcesContent":["import { SignJWT, importPKCS8 } from \"jose\";\nimport { requireEnv } from \"../utils.js\";\nimport { TOKEN_SUB_CLAIM_DIVIDER } from \"./utils.js\";\nconst DEFAULT_JWT_DURATION_MS = 1000 * 60 * 60; // 1 hour\nexport async function generateToken(args, config) {\n    const privateKey = await importPKCS8(requireEnv(\"JWT_PRIVATE_KEY\"), \"RS256\");\n    const expirationTime = new Date(Date.now() + (config.jwt?.durationMs ?? DEFAULT_JWT_DURATION_MS));\n    return await new SignJWT({\n        sub: args.userId + TOKEN_SUB_CLAIM_DIVIDER + args.sessionId,\n    })\n        .setProtectedHeader({ alg: \"RS256\" })\n        .setIssuedAt()\n        .setIssuer(requireEnv(\"CONVEX_SITE_URL\"))\n        .setAudience(\"convex\")\n        .setExpirationTime(expirationTime)\n        .sign(privateKey);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;;;;;AACA,MAAM,0BAA0B,OAAO,KAAK,IAAI,SAAS;AAClD,eAAe,cAAc,IAAI,EAAE,MAAM;IAC5C,MAAM,aAAa,MAAM,IAAA,6KAAW,EAAC,IAAA,iMAAU,EAAC,oBAAoB;IACpE,MAAM,iBAAiB,IAAI,KAAK,KAAK,GAAG,KAAK,CAAC,OAAO,GAAG,EAAE,cAAc,uBAAuB;IAC/F,OAAO,MAAM,IAAI,uKAAO,CAAC;QACrB,KAAK,KAAK,MAAM,GAAG,gOAAuB,GAAG,KAAK,SAAS;IAC/D,GACK,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,SAAS,CAAC,IAAA,iMAAU,EAAC,oBACrB,WAAW,CAAC,UACZ,iBAAiB,CAAC,gBAClB,IAAI,CAAC;AACd","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1618, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/refreshTokens.js"],"sourcesContent":["import { LOG_LEVELS, REFRESH_TOKEN_DIVIDER, logWithLevel, stringToNumber, } from \"./utils.js\";\nconst DEFAULT_SESSION_INACTIVE_DURATION_MS = 1000 * 60 * 60 * 24 * 30; // 30 days\nexport async function createRefreshToken(ctx, sessionId, config) {\n    const expirationTime = Date.now() +\n        (config.session?.inactiveDurationMs ??\n            stringToNumber(process.env.AUTH_SESSION_INACTIVE_DURATION_MS) ??\n            DEFAULT_SESSION_INACTIVE_DURATION_MS);\n    const newRefreshTokenId = await ctx.db.insert(\"authRefreshTokens\", {\n        sessionId,\n        expirationTime,\n    });\n    return `${newRefreshTokenId}${REFRESH_TOKEN_DIVIDER}${sessionId}`;\n}\nexport async function deleteRefreshTokens(ctx, sessionId) {\n    const existingRefreshTokens = await ctx.db\n        .query(\"authRefreshTokens\")\n        .withIndex(\"sessionId\", (q) => q.eq(\"sessionId\", sessionId))\n        .collect();\n    for (const refreshTokenDoc of existingRefreshTokens) {\n        await ctx.db.delete(refreshTokenDoc._id);\n    }\n}\nexport async function validateRefreshToken(ctx, refreshTokenId, tokenSessionId) {\n    const refreshTokenDoc = await ctx.db.get(refreshTokenId);\n    if (refreshTokenDoc === null) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Invalid refresh token\");\n        return null;\n    }\n    if (refreshTokenDoc.expirationTime < Date.now()) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Expired refresh token\");\n        return null;\n    }\n    if (refreshTokenDoc.sessionId !== tokenSessionId) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Invalid refresh token session ID\");\n        return null;\n    }\n    const session = await ctx.db.get(refreshTokenDoc.sessionId);\n    if (session === null) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Invalid refresh token session\");\n        return null;\n    }\n    if (session.expirationTime < Date.now()) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Expired refresh token session\");\n        return null;\n    }\n    return { session, refreshTokenDoc };\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;;;AACA,MAAM,uCAAuC,OAAO,KAAK,KAAK,KAAK,IAAI,UAAU;AAC1E,eAAe,mBAAmB,GAAG,EAAE,SAAS,EAAE,MAAM;IAC3D,MAAM,iBAAiB,KAAK,GAAG,KAC3B,CAAC,OAAO,OAAO,EAAE,sBACb,IAAA,uNAAc,EAAC,QAAQ,GAAG,CAAC,iCAAiC,KAC5D,oCAAoC;IAC5C,MAAM,oBAAoB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,qBAAqB;QAC/D;QACA;IACJ;IACA,OAAO,GAAG,oBAAoB,8NAAqB,GAAG,WAAW;AACrE;AACO,eAAe,oBAAoB,GAAG,EAAE,SAAS;IACpD,MAAM,wBAAwB,MAAM,IAAI,EAAE,CACrC,KAAK,CAAC,qBACN,SAAS,CAAC,aAAa,CAAC,IAAM,EAAE,EAAE,CAAC,aAAa,YAChD,OAAO;IACZ,KAAK,MAAM,mBAAmB,sBAAuB;QACjD,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,gBAAgB,GAAG;IAC3C;AACJ;AACO,eAAe,qBAAqB,GAAG,EAAE,cAAc,EAAE,cAAc;IAC1E,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;IACzC,IAAI,oBAAoB,MAAM;QAC1B,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE;QAC/B,OAAO;IACX;IACA,IAAI,gBAAgB,cAAc,GAAG,KAAK,GAAG,IAAI;QAC7C,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE;QAC/B,OAAO;IACX;IACA,IAAI,gBAAgB,SAAS,KAAK,gBAAgB;QAC9C,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE;QAC/B,OAAO;IACX;IACA,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC,gBAAgB,SAAS;IAC1D,IAAI,YAAY,MAAM;QAClB,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE;QAC/B,OAAO;IACX;IACA,IAAI,QAAQ,cAAc,GAAG,KAAK,GAAG,IAAI;QACrC,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE;QAC/B,OAAO;IACX;IACA,OAAO;QAAE;QAAS;IAAgB;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1682, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/sessions.js"],"sourcesContent":["import { LOG_LEVELS, TOKEN_SUB_CLAIM_DIVIDER, logWithLevel, stringToNumber, } from \"./utils.js\";\nimport { generateToken } from \"./tokens.js\";\nimport { createRefreshToken, deleteRefreshTokens } from \"./refreshTokens.js\";\nconst DEFAULT_SESSION_TOTAL_DURATION_MS = 1000 * 60 * 60 * 24 * 30; // 30 days\nexport async function maybeGenerateTokensForSession(ctx, config, userId, sessionId, generateTokens) {\n    return {\n        userId,\n        sessionId,\n        tokens: generateTokens\n            ? await generateTokensForSession(ctx, config, userId, sessionId)\n            : null,\n    };\n}\nexport async function createNewAndDeleteExistingSession(ctx, config, userId) {\n    const existingSessionId = await getAuthSessionId(ctx);\n    if (existingSessionId !== null) {\n        const existingSession = await ctx.db.get(existingSessionId);\n        if (existingSession !== null) {\n            await deleteSession(ctx, existingSession);\n        }\n    }\n    return await createSession(ctx, userId, config);\n}\nexport async function generateTokensForSession(ctx, config, userId, sessionId) {\n    const ids = { userId, sessionId };\n    const result = {\n        token: await generateToken(ids, config),\n        refreshToken: await createRefreshToken(ctx, sessionId, config),\n    };\n    logWithLevel(LOG_LEVELS.DEBUG, \"Generated tokens for session:\", result);\n    return result;\n}\nasync function createSession(ctx, userId, config) {\n    const expirationTime = Date.now() +\n        (config.session?.totalDurationMs ??\n            stringToNumber(process.env.AUTH_SESSION_TOTAL_DURATION_MS) ??\n            DEFAULT_SESSION_TOTAL_DURATION_MS);\n    return await ctx.db.insert(\"authSessions\", { expirationTime, userId });\n}\nexport async function deleteSession(ctx, session) {\n    await ctx.db.delete(session._id);\n    await deleteRefreshTokens(ctx, session._id);\n}\n/**\n * Return the current session ID.\n *\n * ```ts filename=\"convex/myFunctions.tsx\"\n * import { mutation } from \"./_generated/server\";\n * import { getAuthSessionId } from \"@convex-dev/auth/server\";\n *\n * export const doSomething = mutation({\n *   args: {/* ... *\\/},\n *   handler: async (ctx, args) => {\n *     const sessionId = await getAuthSessionId(ctx);\n *     if (sessionId === null) {\n *       throw new Error(\"Client is not authenticated!\")\n *     }\n *     const session = await ctx.db.get(sessionId);\n *     // ...\n *   },\n * });\n * ```\n *\n * @param ctx query, mutation or action `ctx`\n * @returns the session ID or `null` if the client isn't authenticated\n */\nexport async function getAuthSessionId(ctx) {\n    const identity = await ctx.auth.getUserIdentity();\n    if (identity === null) {\n        return null;\n    }\n    const [, sessionId] = identity.subject.split(TOKEN_SUB_CLAIM_DIVIDER);\n    return sessionId;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;;AACA,MAAM,oCAAoC,OAAO,KAAK,KAAK,KAAK,IAAI,UAAU;AACvE,eAAe,8BAA8B,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,cAAc;IAC9F,OAAO;QACH;QACA;QACA,QAAQ,iBACF,MAAM,yBAAyB,KAAK,QAAQ,QAAQ,aACpD;IACV;AACJ;AACO,eAAe,kCAAkC,GAAG,EAAE,MAAM,EAAE,MAAM;IACvE,MAAM,oBAAoB,MAAM,iBAAiB;IACjD,IAAI,sBAAsB,MAAM;QAC5B,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;QACzC,IAAI,oBAAoB,MAAM;YAC1B,MAAM,cAAc,KAAK;QAC7B;IACJ;IACA,OAAO,MAAM,cAAc,KAAK,QAAQ;AAC5C;AACO,eAAe,yBAAyB,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS;IACzE,MAAM,MAAM;QAAE;QAAQ;IAAU;IAChC,MAAM,SAAS;QACX,OAAO,MAAM,IAAA,uNAAa,EAAC,KAAK;QAChC,cAAc,MAAM,IAAA,mOAAkB,EAAC,KAAK,WAAW;IAC3D;IACA,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,iCAAiC;IAChE,OAAO;AACX;AACA,eAAe,cAAc,GAAG,EAAE,MAAM,EAAE,MAAM;IAC5C,MAAM,iBAAiB,KAAK,GAAG,KAC3B,CAAC,OAAO,OAAO,EAAE,mBACb,IAAA,uNAAc,EAAC,QAAQ,GAAG,CAAC,8BAA8B,KACzD,iCAAiC;IACzC,OAAO,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,gBAAgB;QAAE;QAAgB;IAAO;AACxE;AACO,eAAe,cAAc,GAAG,EAAE,OAAO;IAC5C,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,GAAG;IAC/B,MAAM,IAAA,oOAAmB,EAAC,KAAK,QAAQ,GAAG;AAC9C;AAwBO,eAAe,iBAAiB,GAAG;IACtC,MAAM,WAAW,MAAM,IAAI,IAAI,CAAC,eAAe;IAC/C,IAAI,aAAa,MAAM;QACnB,OAAO;IACX;IACA,MAAM,GAAG,UAAU,GAAG,SAAS,OAAO,CAAC,KAAK,CAAC,gOAAuB;IACpE,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1762, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/createAccountFromCredentials.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport * as Provider from \"../provider.js\";\nimport { upsertUserAndAccount } from \"../users.js\";\nimport { getAuthSessionId } from \"../sessions.js\";\nimport { LOG_LEVELS, logWithLevel, maybeRedact } from \"../utils.js\";\nexport const createAccountFromCredentialsArgs = v.object({\n    provider: v.string(),\n    account: v.object({ id: v.string(), secret: v.optional(v.string()) }),\n    profile: v.any(),\n    shouldLinkViaEmail: v.optional(v.boolean()),\n    shouldLinkViaPhone: v.optional(v.boolean()),\n});\nexport async function createAccountFromCredentialsImpl(ctx, args, getProviderOrThrow, config) {\n    logWithLevel(LOG_LEVELS.DEBUG, \"createAccountFromCredentialsImpl args:\", {\n        provider: args.provider,\n        account: {\n            id: args.account.id,\n            secret: maybeRedact(args.account.secret ?? \"\"),\n        },\n    });\n    const { provider: providerId, account, profile, shouldLinkViaEmail, shouldLinkViaPhone, } = args;\n    const provider = getProviderOrThrow(providerId);\n    const existingAccount = await ctx.db\n        .query(\"authAccounts\")\n        .withIndex(\"providerAndAccountId\", (q) => q.eq(\"provider\", provider.id).eq(\"providerAccountId\", account.id))\n        .unique();\n    if (existingAccount !== null) {\n        if (account.secret !== undefined &&\n            !(await Provider.verify(provider, account.secret, existingAccount.secret ?? \"\"))) {\n            throw new Error(`Account ${account.id} already exists`);\n        }\n        return {\n            account: existingAccount,\n            // TODO: Ian removed this,\n            user: (await ctx.db.get(existingAccount.userId)),\n        };\n    }\n    const secret = account.secret !== undefined\n        ? await Provider.hash(provider, account.secret)\n        : undefined;\n    const { userId, accountId } = await upsertUserAndAccount(ctx, await getAuthSessionId(ctx), { providerAccountId: account.id, secret }, {\n        type: \"credentials\",\n        provider,\n        profile,\n        shouldLinkViaEmail,\n        shouldLinkViaPhone,\n    }, config);\n    return {\n        account: (await ctx.db.get(accountId)),\n        user: (await ctx.db.get(userId)),\n    };\n}\nexport const callCreateAccountFromCredentials = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"createAccountFromCredentials\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AACO,MAAM,mCAAmC,mKAAC,CAAC,MAAM,CAAC;IACrD,UAAU,mKAAC,CAAC,MAAM;IAClB,SAAS,mKAAC,CAAC,MAAM,CAAC;QAAE,IAAI,mKAAC,CAAC,MAAM;QAAI,QAAQ,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,MAAM;IAAI;IACnE,SAAS,mKAAC,CAAC,GAAG;IACd,oBAAoB,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,OAAO;IACxC,oBAAoB,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,OAAO;AAC5C;AACO,eAAe,iCAAiC,GAAG,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM;IACxF,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,0CAA0C;QACrE,UAAU,KAAK,QAAQ;QACvB,SAAS;YACL,IAAI,KAAK,OAAO,CAAC,EAAE;YACnB,QAAQ,IAAA,oNAAW,EAAC,KAAK,OAAO,CAAC,MAAM,IAAI;QAC/C;IACJ;IACA,MAAM,EAAE,UAAU,UAAU,EAAE,OAAO,EAAE,OAAO,EAAE,kBAAkB,EAAE,kBAAkB,EAAG,GAAG;IAC5F,MAAM,WAAW,mBAAmB;IACpC,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAC/B,KAAK,CAAC,gBACN,SAAS,CAAC,wBAAwB,CAAC,IAAM,EAAE,EAAE,CAAC,YAAY,SAAS,EAAE,EAAE,EAAE,CAAC,qBAAqB,QAAQ,EAAE,GACzG,MAAM;IACX,IAAI,oBAAoB,MAAM;QAC1B,IAAI,QAAQ,MAAM,KAAK,aACnB,CAAE,MAAM,kNAAe,CAAC,UAAU,QAAQ,MAAM,EAAE,gBAAgB,MAAM,IAAI,KAAM;YAClF,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,eAAe,CAAC;QAC1D;QACA,OAAO;YACH,SAAS;YACT,0BAA0B;YAC1B,MAAO,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC,gBAAgB,MAAM;QAClD;IACJ;IACA,MAAM,SAAS,QAAQ,MAAM,KAAK,YAC5B,MAAM,gNAAa,CAAC,UAAU,QAAQ,MAAM,IAC5C;IACN,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,6NAAoB,EAAC,KAAK,MAAM,IAAA,4NAAgB,EAAC,MAAM;QAAE,mBAAmB,QAAQ,EAAE;QAAE;IAAO,GAAG;QAClI,MAAM;QACN;QACA;QACA;QACA;IACJ,GAAG;IACH,OAAO;QACH,SAAU,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;QAC3B,MAAO,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;IAC5B;AACJ;AACO,MAAM,mCAAmC,OAAO,KAAK;IACxD,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/invalidateSessions.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { deleteSession } from \"../sessions.js\";\nimport { LOG_LEVELS, logWithLevel } from \"../utils.js\";\nexport const invalidateSessionsArgs = v.object({\n    userId: v.id(\"users\"),\n    except: v.optional(v.array(v.id(\"authSessions\"))),\n});\nexport const callInvalidateSessions = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"invalidateSessions\",\n            ...args,\n        },\n    });\n};\nexport const invalidateSessionsImpl = async (ctx, args) => {\n    logWithLevel(LOG_LEVELS.DEBUG, \"invalidateSessionsImpl args:\", args);\n    const { userId, except } = args;\n    const exceptSet = new Set(except ?? []);\n    const sessions = await ctx.db\n        .query(\"authSessions\")\n        .withIndex(\"userId\", (q) => q.eq(\"userId\", userId))\n        .collect();\n    for (const session of sessions) {\n        if (!exceptSet.has(session._id)) {\n            await deleteSession(ctx, session);\n        }\n    }\n    return;\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;;;;;;;;;AACO,MAAM,yBAAyB,mKAAC,CAAC,MAAM,CAAC;IAC3C,QAAQ,mKAAC,CAAC,EAAE,CAAC;IACb,QAAQ,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,KAAK,CAAC,mKAAC,CAAC,EAAE,CAAC;AACpC;AACO,MAAM,yBAAyB,OAAO,KAAK;IAC9C,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ;AACO,MAAM,yBAAyB,OAAO,KAAK;IAC9C,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,gCAAgC;IAC/D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG;IAC3B,MAAM,YAAY,IAAI,IAAI,UAAU,EAAE;IACtC,MAAM,WAAW,MAAM,IAAI,EAAE,CACxB,KAAK,CAAC,gBACN,SAAS,CAAC,UAAU,CAAC,IAAM,EAAE,EAAE,CAAC,UAAU,SAC1C,OAAO;IACZ,KAAK,MAAM,WAAW,SAAU;QAC5B,IAAI,CAAC,UAAU,GAAG,CAAC,QAAQ,GAAG,GAAG;YAC7B,MAAM,IAAA,yNAAa,EAAC,KAAK;QAC7B;IACJ;IACA;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1900, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/modifyAccount.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { hash } from \"../provider.js\";\nimport { LOG_LEVELS, logWithLevel, maybeRedact } from \"../utils.js\";\nexport const modifyAccountArgs = v.object({\n    provider: v.string(),\n    account: v.object({ id: v.string(), secret: v.string() }),\n});\nexport async function modifyAccountImpl(ctx, args, getProviderOrThrow) {\n    const { provider, account } = args;\n    logWithLevel(LOG_LEVELS.DEBUG, \"retrieveAccountWithCredentialsImpl args:\", {\n        provider: provider,\n        account: {\n            id: account.id,\n            secret: maybeRedact(account.secret ?? \"\"),\n        },\n    });\n    const existingAccount = await ctx.db\n        .query(\"authAccounts\")\n        .withIndex(\"providerAndAccountId\", (q) => q.eq(\"provider\", provider).eq(\"providerAccountId\", account.id))\n        .unique();\n    if (existingAccount === null) {\n        throw new Error(`Cannot modify account with ID ${account.id} because it does not exist`);\n    }\n    await ctx.db.patch(existingAccount._id, {\n        secret: await hash(getProviderOrThrow(provider), account.secret),\n    });\n    return;\n}\nexport const callModifyAccount = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"modifyAccount\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;;;;;;;;AACO,MAAM,oBAAoB,mKAAC,CAAC,MAAM,CAAC;IACtC,UAAU,mKAAC,CAAC,MAAM;IAClB,SAAS,mKAAC,CAAC,MAAM,CAAC;QAAE,IAAI,mKAAC,CAAC,MAAM;QAAI,QAAQ,mKAAC,CAAC,MAAM;IAAG;AAC3D;AACO,eAAe,kBAAkB,GAAG,EAAE,IAAI,EAAE,kBAAkB;IACjE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG;IAC9B,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,4CAA4C;QACvE,UAAU;QACV,SAAS;YACL,IAAI,QAAQ,EAAE;YACd,QAAQ,IAAA,oNAAW,EAAC,QAAQ,MAAM,IAAI;QAC1C;IACJ;IACA,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAC/B,KAAK,CAAC,gBACN,SAAS,CAAC,wBAAwB,CAAC,IAAM,EAAE,EAAE,CAAC,YAAY,UAAU,EAAE,CAAC,qBAAqB,QAAQ,EAAE,GACtG,MAAM;IACX,IAAI,oBAAoB,MAAM;QAC1B,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,QAAQ,EAAE,CAAC,0BAA0B,CAAC;IAC3F;IACA,MAAM,IAAI,EAAE,CAAC,KAAK,CAAC,gBAAgB,GAAG,EAAE;QACpC,QAAQ,MAAM,IAAA,gNAAI,EAAC,mBAAmB,WAAW,QAAQ,MAAM;IACnE;IACA;AACJ;AACO,MAAM,oBAAoB,OAAO,KAAK;IACzC,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1957, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/rateLimit.js"],"sourcesContent":["const DEFAULT_MAX_SIGN_IN_ATTEMPS_PER_HOUR = 10;\nexport async function isSignInRateLimited(ctx, identifier, config) {\n    const state = await getRateLimitState(ctx, identifier, config);\n    if (state === null) {\n        return false;\n    }\n    return state.attempsLeft < 1;\n}\nexport async function recordFailedSignIn(ctx, identifier, config) {\n    const state = await getRateLimitState(ctx, identifier, config);\n    if (state !== null) {\n        await ctx.db.patch(state.limit._id, {\n            attemptsLeft: state.attempsLeft - 1,\n            lastAttemptTime: Date.now(),\n        });\n    }\n    else {\n        const maxAttempsPerHour = configuredMaxAttempsPerHour(config);\n        await ctx.db.insert(\"authRateLimits\", {\n            identifier,\n            attemptsLeft: maxAttempsPerHour - 1,\n            lastAttemptTime: Date.now(),\n        });\n    }\n}\nexport async function resetSignInRateLimit(ctx, identifier) {\n    const existingState = await ctx.db\n        .query(\"authRateLimits\")\n        .withIndex(\"identifier\", (q) => q.eq(\"identifier\", identifier))\n        .unique();\n    if (existingState !== null) {\n        await ctx.db.delete(existingState._id);\n    }\n}\nasync function getRateLimitState(ctx, identifier, config) {\n    const now = Date.now();\n    const maxAttempsPerHour = configuredMaxAttempsPerHour(config);\n    const limit = await ctx.db\n        .query(\"authRateLimits\")\n        .withIndex(\"identifier\", (q) => q.eq(\"identifier\", identifier))\n        .unique();\n    if (limit === null) {\n        return null;\n    }\n    const elapsed = now - limit.lastAttemptTime;\n    const maxAttempsPerMs = maxAttempsPerHour / (60 * 60 * 1000);\n    const attempsLeft = Math.min(maxAttempsPerHour, limit.attemptsLeft + elapsed * maxAttempsPerMs);\n    return { limit, attempsLeft };\n}\nfunction configuredMaxAttempsPerHour(config) {\n    return (config.signIn?.maxFailedAttempsPerHour ??\n        DEFAULT_MAX_SIGN_IN_ATTEMPS_PER_HOUR);\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,MAAM,uCAAuC;AACtC,eAAe,oBAAoB,GAAG,EAAE,UAAU,EAAE,MAAM;IAC7D,MAAM,QAAQ,MAAM,kBAAkB,KAAK,YAAY;IACvD,IAAI,UAAU,MAAM;QAChB,OAAO;IACX;IACA,OAAO,MAAM,WAAW,GAAG;AAC/B;AACO,eAAe,mBAAmB,GAAG,EAAE,UAAU,EAAE,MAAM;IAC5D,MAAM,QAAQ,MAAM,kBAAkB,KAAK,YAAY;IACvD,IAAI,UAAU,MAAM;QAChB,MAAM,IAAI,EAAE,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,EAAE;YAChC,cAAc,MAAM,WAAW,GAAG;YAClC,iBAAiB,KAAK,GAAG;QAC7B;IACJ,OACK;QACD,MAAM,oBAAoB,4BAA4B;QACtD,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,kBAAkB;YAClC;YACA,cAAc,oBAAoB;YAClC,iBAAiB,KAAK,GAAG;QAC7B;IACJ;AACJ;AACO,eAAe,qBAAqB,GAAG,EAAE,UAAU;IACtD,MAAM,gBAAgB,MAAM,IAAI,EAAE,CAC7B,KAAK,CAAC,kBACN,SAAS,CAAC,cAAc,CAAC,IAAM,EAAE,EAAE,CAAC,cAAc,aAClD,MAAM;IACX,IAAI,kBAAkB,MAAM;QACxB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,cAAc,GAAG;IACzC;AACJ;AACA,eAAe,kBAAkB,GAAG,EAAE,UAAU,EAAE,MAAM;IACpD,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,oBAAoB,4BAA4B;IACtD,MAAM,QAAQ,MAAM,IAAI,EAAE,CACrB,KAAK,CAAC,kBACN,SAAS,CAAC,cAAc,CAAC,IAAM,EAAE,EAAE,CAAC,cAAc,aAClD,MAAM;IACX,IAAI,UAAU,MAAM;QAChB,OAAO;IACX;IACA,MAAM,UAAU,MAAM,MAAM,eAAe;IAC3C,MAAM,kBAAkB,oBAAoB,CAAC,KAAK,KAAK,IAAI;IAC3D,MAAM,cAAc,KAAK,GAAG,CAAC,mBAAmB,MAAM,YAAY,GAAG,UAAU;IAC/E,OAAO;QAAE;QAAO;IAAY;AAChC;AACA,SAAS,4BAA4B,MAAM;IACvC,OAAQ,OAAO,MAAM,EAAE,2BACnB;AACR","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2019, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/retrieveAccountWithCredentials.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { isSignInRateLimited, recordFailedSignIn, resetSignInRateLimit, } from \"../rateLimit.js\";\nimport * as Provider from \"../provider.js\";\nimport { LOG_LEVELS, logWithLevel, maybeRedact } from \"../utils.js\";\nexport const retrieveAccountWithCredentialsArgs = v.object({\n    provider: v.string(),\n    account: v.object({ id: v.string(), secret: v.optional(v.string()) }),\n});\nexport async function retrieveAccountWithCredentialsImpl(ctx, args, getProviderOrThrow, config) {\n    const { provider: providerId, account } = args;\n    logWithLevel(LOG_LEVELS.DEBUG, \"retrieveAccountWithCredentialsImpl args:\", {\n        provider: providerId,\n        account: {\n            id: account.id,\n            secret: maybeRedact(account.secret ?? \"\"),\n        },\n    });\n    const existingAccount = await ctx.db\n        .query(\"authAccounts\")\n        .withIndex(\"providerAndAccountId\", (q) => q.eq(\"provider\", providerId).eq(\"providerAccountId\", account.id))\n        .unique();\n    if (existingAccount === null) {\n        return \"InvalidAccountId\";\n    }\n    if (account.secret !== undefined) {\n        if (await isSignInRateLimited(ctx, existingAccount._id, config)) {\n            return \"TooManyFailedAttempts\";\n        }\n        if (!(await Provider.verify(getProviderOrThrow(providerId), account.secret, existingAccount.secret ?? \"\"))) {\n            await recordFailedSignIn(ctx, existingAccount._id, config);\n            return \"InvalidSecret\";\n        }\n        await resetSignInRateLimit(ctx, existingAccount._id);\n    }\n    return {\n        account: existingAccount,\n        // TODO: Ian removed this\n        user: (await ctx.db.get(existingAccount.userId)),\n    };\n}\nexport const callRetreiveAccountWithCredentials = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"retrieveAccountWithCredentials\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;AACO,MAAM,qCAAqC,mKAAC,CAAC,MAAM,CAAC;IACvD,UAAU,mKAAC,CAAC,MAAM;IAClB,SAAS,mKAAC,CAAC,MAAM,CAAC;QAAE,IAAI,mKAAC,CAAC,MAAM;QAAI,QAAQ,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,MAAM;IAAI;AACvE;AACO,eAAe,mCAAmC,GAAG,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM;IAC1F,MAAM,EAAE,UAAU,UAAU,EAAE,OAAO,EAAE,GAAG;IAC1C,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,4CAA4C;QACvE,UAAU;QACV,SAAS;YACL,IAAI,QAAQ,EAAE;YACd,QAAQ,IAAA,oNAAW,EAAC,QAAQ,MAAM,IAAI;QAC1C;IACJ;IACA,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAC/B,KAAK,CAAC,gBACN,SAAS,CAAC,wBAAwB,CAAC,IAAM,EAAE,EAAE,CAAC,YAAY,YAAY,EAAE,CAAC,qBAAqB,QAAQ,EAAE,GACxG,MAAM;IACX,IAAI,oBAAoB,MAAM;QAC1B,OAAO;IACX;IACA,IAAI,QAAQ,MAAM,KAAK,WAAW;QAC9B,IAAI,MAAM,IAAA,gOAAmB,EAAC,KAAK,gBAAgB,GAAG,EAAE,SAAS;YAC7D,OAAO;QACX;QACA,IAAI,CAAE,MAAM,kNAAe,CAAC,mBAAmB,aAAa,QAAQ,MAAM,EAAE,gBAAgB,MAAM,IAAI,KAAM;YACxG,MAAM,IAAA,+NAAkB,EAAC,KAAK,gBAAgB,GAAG,EAAE;YACnD,OAAO;QACX;QACA,MAAM,IAAA,iOAAoB,EAAC,KAAK,gBAAgB,GAAG;IACvD;IACA,OAAO;QACH,SAAS;QACT,yBAAyB;QACzB,MAAO,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC,gBAAgB,MAAM;IAClD;AACJ;AACO,MAAM,qCAAqC,OAAO,KAAK;IAC1D,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2091, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/signOut.js"],"sourcesContent":["import { deleteSession, getAuthSessionId } from \"../sessions.js\";\nexport async function signOutImpl(ctx) {\n    const sessionId = await getAuthSessionId(ctx);\n    if (sessionId !== null) {\n        const session = await ctx.db.get(sessionId);\n        if (session !== null) {\n            await deleteSession(ctx, session);\n            return { userId: session.userId, sessionId: session._id };\n        }\n    }\n    return null;\n}\nexport const callSignOut = async (ctx) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"signOut\",\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;AACO,eAAe,YAAY,GAAG;IACjC,MAAM,YAAY,MAAM,IAAA,4NAAgB,EAAC;IACzC,IAAI,cAAc,MAAM;QACpB,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;QACjC,IAAI,YAAY,MAAM;YAClB,MAAM,IAAA,yNAAa,EAAC,KAAK;YACzB,OAAO;gBAAE,QAAQ,QAAQ,MAAM;gBAAE,WAAW,QAAQ,GAAG;YAAC;QAC5D;IACJ;IACA,OAAO;AACX;AACO,MAAM,cAAc,OAAO;IAC9B,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;QACV;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2131, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/userOAuth.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { upsertUserAndAccount } from \"../users.js\";\nimport { logWithLevel, sha256 } from \"../utils.js\";\nimport { alphabet, generateRandomString } from \"oslo/crypto\";\nconst OAUTH_SIGN_IN_EXPIRATION_MS = 1000 * 60 * 2; // 2 minutes\nexport const userOAuthArgs = v.object({\n    provider: v.string(),\n    providerAccountId: v.string(),\n    profile: v.any(),\n    signature: v.string(),\n});\nexport async function userOAuthImpl(ctx, args, getProviderOrThrow, config) {\n    logWithLevel(\"DEBUG\", \"userOAuthImpl args:\", args);\n    const { profile, provider, providerAccountId, signature } = args;\n    const providerConfig = getProviderOrThrow(provider);\n    const existingAccount = await ctx.db\n        .query(\"authAccounts\")\n        .withIndex(\"providerAndAccountId\", (q) => q.eq(\"provider\", provider).eq(\"providerAccountId\", providerAccountId))\n        .unique();\n    const verifier = await ctx.db\n        .query(\"authVerifiers\")\n        .withIndex(\"signature\", (q) => q.eq(\"signature\", signature))\n        .unique();\n    if (verifier === null) {\n        throw new Error(\"Invalid state\");\n    }\n    const { accountId } = await upsertUserAndAccount(ctx, verifier.sessionId ?? null, existingAccount !== null ? { existingAccount } : { providerAccountId }, { type: \"oauth\", provider: providerConfig, profile }, config);\n    const code = generateRandomString(8, alphabet(\"0-9\"));\n    await ctx.db.delete(verifier._id);\n    const existingVerificationCode = await ctx.db\n        .query(\"authVerificationCodes\")\n        .withIndex(\"accountId\", (q) => q.eq(\"accountId\", accountId))\n        .unique();\n    if (existingVerificationCode !== null) {\n        await ctx.db.delete(existingVerificationCode._id);\n    }\n    await ctx.db.insert(\"authVerificationCodes\", {\n        code: await sha256(code),\n        accountId,\n        provider,\n        expirationTime: Date.now() + OAUTH_SIGN_IN_EXPIRATION_MS,\n        // The use of a verifier means we don't need an identifier\n        // during verification.\n        verifier: verifier._id,\n    });\n    return code;\n}\nexport const callUserOAuth = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"userOAuth\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AACA,MAAM,8BAA8B,OAAO,KAAK,GAAG,YAAY;AACxD,MAAM,gBAAgB,mKAAC,CAAC,MAAM,CAAC;IAClC,UAAU,mKAAC,CAAC,MAAM;IAClB,mBAAmB,mKAAC,CAAC,MAAM;IAC3B,SAAS,mKAAC,CAAC,GAAG;IACd,WAAW,mKAAC,CAAC,MAAM;AACvB;AACO,eAAe,cAAc,GAAG,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM;IACrE,IAAA,qNAAY,EAAC,SAAS,uBAAuB;IAC7C,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,iBAAiB,EAAE,SAAS,EAAE,GAAG;IAC5D,MAAM,iBAAiB,mBAAmB;IAC1C,MAAM,kBAAkB,MAAM,IAAI,EAAE,CAC/B,KAAK,CAAC,gBACN,SAAS,CAAC,wBAAwB,CAAC,IAAM,EAAE,EAAE,CAAC,YAAY,UAAU,EAAE,CAAC,qBAAqB,oBAC5F,MAAM;IACX,MAAM,WAAW,MAAM,IAAI,EAAE,CACxB,KAAK,CAAC,iBACN,SAAS,CAAC,aAAa,CAAC,IAAM,EAAE,EAAE,CAAC,aAAa,YAChD,MAAM;IACX,IAAI,aAAa,MAAM;QACnB,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,6NAAoB,EAAC,KAAK,SAAS,SAAS,IAAI,MAAM,oBAAoB,OAAO;QAAE;IAAgB,IAAI;QAAE;IAAkB,GAAG;QAAE,MAAM;QAAS,UAAU;QAAgB;IAAQ,GAAG;IAChN,MAAM,OAAO,IAAA,oJAAoB,EAAC,GAAG,IAAA,wIAAQ,EAAC;IAC9C,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,SAAS,GAAG;IAChC,MAAM,2BAA2B,MAAM,IAAI,EAAE,CACxC,KAAK,CAAC,yBACN,SAAS,CAAC,aAAa,CAAC,IAAM,EAAE,EAAE,CAAC,aAAa,YAChD,MAAM;IACX,IAAI,6BAA6B,MAAM;QACnC,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,yBAAyB,GAAG;IACpD;IACA,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,yBAAyB;QACzC,MAAM,MAAM,IAAA,+MAAM,EAAC;QACnB;QACA;QACA,gBAAgB,KAAK,GAAG,KAAK;QAC7B,0DAA0D;QAC1D,uBAAuB;QACvB,UAAU,SAAS,GAAG;IAC1B;IACA,OAAO;AACX;AACO,MAAM,gBAAgB,OAAO,KAAK;IACrC,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2209, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/verifierSignature.js"],"sourcesContent":["import { v } from \"convex/values\";\nexport const verifierSignatureArgs = v.object({\n    verifier: v.string(),\n    signature: v.string(),\n});\nexport async function verifierSignatureImpl(ctx, args) {\n    const { verifier, signature } = args;\n    const verifierDoc = await ctx.db.get(verifier);\n    if (verifierDoc === null) {\n        throw new Error(\"Invalid verifier\");\n    }\n    return await ctx.db.patch(verifierDoc._id, { signature });\n}\nexport const callVerifierSignature = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"verifierSignature\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;;AACO,MAAM,wBAAwB,mKAAC,CAAC,MAAM,CAAC;IAC1C,UAAU,mKAAC,CAAC,MAAM;IAClB,WAAW,mKAAC,CAAC,MAAM;AACvB;AACO,eAAe,sBAAsB,GAAG,EAAE,IAAI;IACjD,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG;IAChC,MAAM,cAAc,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;IACrC,IAAI,gBAAgB,MAAM;QACtB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,MAAM,IAAI,EAAE,CAAC,KAAK,CAAC,YAAY,GAAG,EAAE;QAAE;IAAU;AAC3D;AACO,MAAM,wBAAwB,OAAO,KAAK;IAC7C,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2248, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/signIn.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { createNewAndDeleteExistingSession, maybeGenerateTokensForSession, } from \"../sessions.js\";\nimport { LOG_LEVELS, logWithLevel } from \"../utils.js\";\nexport const signInArgs = v.object({\n    userId: v.id(\"users\"),\n    sessionId: v.optional(v.id(\"authSessions\")),\n    generateTokens: v.boolean(),\n});\nexport async function signInImpl(ctx, args, config) {\n    logWithLevel(LOG_LEVELS.DEBUG, \"signInImpl args:\", args);\n    const { userId, sessionId: existingSessionId, generateTokens } = args;\n    const sessionId = existingSessionId ??\n        (await createNewAndDeleteExistingSession(ctx, config, userId));\n    return await maybeGenerateTokensForSession(ctx, config, userId, sessionId, generateTokens);\n}\nexport const callSignIn = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"signIn\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;;;;;;;;;AACO,MAAM,aAAa,mKAAC,CAAC,MAAM,CAAC;IAC/B,QAAQ,mKAAC,CAAC,EAAE,CAAC;IACb,WAAW,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,EAAE,CAAC;IAC3B,gBAAgB,mKAAC,CAAC,OAAO;AAC7B;AACO,eAAe,WAAW,GAAG,EAAE,IAAI,EAAE,MAAM;IAC9C,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,oBAAoB;IACnD,MAAM,EAAE,MAAM,EAAE,WAAW,iBAAiB,EAAE,cAAc,EAAE,GAAG;IACjE,MAAM,YAAY,qBACb,MAAM,IAAA,6OAAiC,EAAC,KAAK,QAAQ;IAC1D,OAAO,MAAM,IAAA,yOAA6B,EAAC,KAAK,QAAQ,QAAQ,WAAW;AAC/E;AACO,MAAM,aAAa,OAAO,KAAK;IAClC,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2294, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/refreshSession.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { REFRESH_TOKEN_DIVIDER, logWithLevel } from \"../utils.js\";\nimport { deleteRefreshTokens, validateRefreshToken } from \"../refreshTokens.js\";\nimport { generateTokensForSession } from \"../sessions.js\";\nexport const refreshSessionArgs = v.object({\n    refreshToken: v.string(),\n});\nexport async function refreshSessionImpl(ctx, args, getProviderOrThrow, config) {\n    logWithLevel(\"DEBUG\", \"refreshSessionImpl args:\", args);\n    const { refreshToken } = args;\n    const [refreshTokenId, tokenSessionId] = refreshToken.split(REFRESH_TOKEN_DIVIDER);\n    const validationResult = await validateRefreshToken(ctx, refreshTokenId, tokenSessionId);\n    // This invalidates all other refresh tokens for this session,\n    // including ones created later, regardless of whether\n    // the passed one is valid or not.\n    await deleteRefreshTokens(ctx, tokenSessionId);\n    if (validationResult === null) {\n        // Can't call `deleteSession` here because we already deleted\n        // refresh tokens above\n        const session = await ctx.db.get(tokenSessionId);\n        if (session !== null) {\n            await ctx.db.delete(session._id);\n        }\n        return null;\n    }\n    const { session } = validationResult;\n    const sessionId = session._id;\n    const userId = session.userId;\n    return await generateTokensForSession(ctx, config, userId, sessionId);\n}\nexport const callRefreshSession = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"refreshSession\",\n            ...args,\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AACO,MAAM,qBAAqB,mKAAC,CAAC,MAAM,CAAC;IACvC,cAAc,mKAAC,CAAC,MAAM;AAC1B;AACO,eAAe,mBAAmB,GAAG,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM;IAC1E,IAAA,qNAAY,EAAC,SAAS,4BAA4B;IAClD,MAAM,EAAE,YAAY,EAAE,GAAG;IACzB,MAAM,CAAC,gBAAgB,eAAe,GAAG,aAAa,KAAK,CAAC,8NAAqB;IACjF,MAAM,mBAAmB,MAAM,IAAA,qOAAoB,EAAC,KAAK,gBAAgB;IACzE,8DAA8D;IAC9D,sDAAsD;IACtD,kCAAkC;IAClC,MAAM,IAAA,oOAAmB,EAAC,KAAK;IAC/B,IAAI,qBAAqB,MAAM;QAC3B,6DAA6D;QAC7D,uBAAuB;QACvB,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,GAAG,CAAC;QACjC,IAAI,YAAY,MAAM;YAClB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,GAAG;QACnC;QACA,OAAO;IACX;IACA,MAAM,EAAE,OAAO,EAAE,GAAG;IACpB,MAAM,YAAY,QAAQ,GAAG;IAC7B,MAAM,SAAS,QAAQ,MAAM;IAC7B,OAAO,MAAM,IAAA,oOAAwB,EAAC,KAAK,QAAQ,QAAQ;AAC/D;AACO,MAAM,qBAAqB,OAAO,KAAK;IAC1C,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2358, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/verifyCodeAndSignIn.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { isSignInRateLimited, recordFailedSignIn, resetSignInRateLimit, } from \"../rateLimit.js\";\nimport { createNewAndDeleteExistingSession, getAuthSessionId, maybeGenerateTokensForSession, } from \"../sessions.js\";\nimport { LOG_LEVELS, logWithLevel, sha256 } from \"../utils.js\";\nimport { upsertUserAndAccount } from \"../users.js\";\nexport const verifyCodeAndSignInArgs = v.object({\n    params: v.any(),\n    provider: v.optional(v.string()),\n    verifier: v.optional(v.string()),\n    generateTokens: v.boolean(),\n    allowExtraProviders: v.boolean(),\n});\nexport async function verifyCodeAndSignInImpl(ctx, args, getProviderOrThrow, config) {\n    logWithLevel(LOG_LEVELS.DEBUG, \"verifyCodeAndSignInImpl args:\", {\n        params: { email: args.params.email, phone: args.params.phone },\n        provider: args.provider,\n        verifier: args.verifier,\n        generateTokens: args.generateTokens,\n        allowExtraProviders: args.allowExtraProviders,\n    });\n    const { generateTokens, provider, allowExtraProviders } = args;\n    const identifier = args.params.email ?? args.params.phone;\n    if (identifier !== undefined) {\n        if (await isSignInRateLimited(ctx, identifier, config)) {\n            logWithLevel(LOG_LEVELS.ERROR, \"Too many failed attemps to verify code for this email\");\n            return null;\n        }\n    }\n    const verifyResult = await verifyCodeOnly(ctx, args, provider ?? null, getProviderOrThrow, allowExtraProviders, config, await getAuthSessionId(ctx));\n    if (verifyResult === null) {\n        if (identifier !== undefined) {\n            await recordFailedSignIn(ctx, identifier, config);\n        }\n        return null;\n    }\n    if (identifier !== undefined) {\n        await resetSignInRateLimit(ctx, identifier);\n    }\n    const { userId } = verifyResult;\n    const sessionId = await createNewAndDeleteExistingSession(ctx, config, userId);\n    return await maybeGenerateTokensForSession(ctx, config, userId, sessionId, generateTokens);\n}\nexport const callVerifyCodeAndSignIn = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"verifyCodeAndSignIn\",\n            ...args,\n        },\n    });\n};\nasync function verifyCodeOnly(ctx, args, \n/**\n * There are two providers at play:\n * 1. the provider that generated the code\n * 2. the provider the account is tied to.\n * This is because we allow signing into an account\n * via another provider, see {@link signInViaProvider}.\n * This is the first provider.\n */\nmethodProviderId, getProviderOrThrow, allowExtraProviders, config, sessionId) {\n    const { params, verifier } = args;\n    const codeHash = await sha256(params.code);\n    const verificationCode = await ctx.db\n        .query(\"authVerificationCodes\")\n        .withIndex(\"code\", (q) => q.eq(\"code\", codeHash))\n        .unique();\n    if (verificationCode === null) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Invalid verification code\");\n        return null;\n    }\n    await ctx.db.delete(verificationCode._id);\n    if (verificationCode.verifier !== verifier) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Invalid verifier\");\n        return null;\n    }\n    if (verificationCode.expirationTime < Date.now()) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Expired verification code\");\n        return null;\n    }\n    const { accountId, emailVerified, phoneVerified } = verificationCode;\n    const account = await ctx.db.get(accountId);\n    if (account === null) {\n        logWithLevel(LOG_LEVELS.ERROR, \"Account associated with this email has been deleted\");\n        return null;\n    }\n    if (methodProviderId !== null &&\n        verificationCode.provider !== methodProviderId) {\n        logWithLevel(LOG_LEVELS.ERROR, `Invalid provider \"${methodProviderId}\" for given \\`code\\`, ` +\n            `which was generated by provider \"${verificationCode.provider}\"`);\n        return null;\n    }\n    // OTP providers perform an additional check against the provided\n    // params.\n    const methodProvider = getProviderOrThrow(verificationCode.provider, allowExtraProviders);\n    if (methodProvider !== null &&\n        (methodProvider.type === \"email\" || methodProvider.type === \"phone\") &&\n        methodProvider.authorize !== undefined) {\n        await methodProvider.authorize(args.params, account);\n    }\n    let userId = account.userId;\n    const provider = getProviderOrThrow(account.provider);\n    if (!(provider.type === \"oauth\" || provider.type === \"oidc\")) {\n        ({ userId } = await upsertUserAndAccount(ctx, sessionId, { existingAccount: account }, {\n            type: \"verification\",\n            provider,\n            profile: {\n                ...(emailVerified !== undefined\n                    ? { email: emailVerified, emailVerified: true }\n                    : {}),\n                ...(phoneVerified !== undefined\n                    ? { phone: phoneVerified, phoneVerified: true }\n                    : {}),\n            },\n        }, config));\n    }\n    return { providerAccountId: account.providerAccountId, userId };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2503, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/createVerificationCode.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { getAccountOrThrow, upsertUserAndAccount } from \"../users.js\";\nimport { getAuthSessionId } from \"../sessions.js\";\nimport { LOG_LEVELS, logWithLevel, sha256 } from \"../utils.js\";\nexport const createVerificationCodeArgs = v.object({\n    accountId: v.optional(v.id(\"authAccounts\")),\n    provider: v.string(),\n    email: v.optional(v.string()),\n    phone: v.optional(v.string()),\n    code: v.string(),\n    expirationTime: v.number(),\n    allowExtraProviders: v.boolean(),\n});\nexport async function createVerificationCodeImpl(ctx, args, getProviderOrThrow, config) {\n    logWithLevel(LOG_LEVELS.DEBUG, \"createVerificationCodeImpl args:\", args);\n    const { email, phone, code, expirationTime, provider: providerId, accountId: existingAccountId, allowExtraProviders, } = args;\n    const existingAccount = existingAccountId !== undefined\n        ? await getAccountOrThrow(ctx, existingAccountId)\n        : await ctx.db\n            .query(\"authAccounts\")\n            .withIndex(\"providerAndAccountId\", (q) => q\n            .eq(\"provider\", providerId)\n            .eq(\"providerAccountId\", email ?? phone))\n            .unique();\n    const provider = getProviderOrThrow(providerId, allowExtraProviders);\n    const { accountId } = await upsertUserAndAccount(ctx, await getAuthSessionId(ctx), existingAccount !== null\n        ? { existingAccount }\n        : { providerAccountId: email ?? phone }, provider.type === \"email\"\n        ? { type: \"email\", provider, profile: { email: email } }\n        : { type: \"phone\", provider, profile: { phone: phone } }, config);\n    await generateUniqueVerificationCode(ctx, accountId, providerId, code, expirationTime, { email, phone });\n    return email ?? phone;\n}\nexport const callCreateVerificationCode = async (ctx, args) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"createVerificationCode\",\n            ...args,\n        },\n    });\n};\nasync function generateUniqueVerificationCode(ctx, accountId, provider, code, expirationTime, { email, phone }) {\n    const existingCode = await ctx.db\n        .query(\"authVerificationCodes\")\n        .withIndex(\"accountId\", (q) => q.eq(\"accountId\", accountId))\n        .unique();\n    if (existingCode !== null) {\n        await ctx.db.delete(existingCode._id);\n    }\n    await ctx.db.insert(\"authVerificationCodes\", {\n        accountId,\n        provider,\n        code: await sha256(code),\n        expirationTime,\n        emailVerified: email,\n        phoneVerified: phone,\n    });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AACO,MAAM,6BAA6B,mKAAC,CAAC,MAAM,CAAC;IAC/C,WAAW,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,EAAE,CAAC;IAC3B,UAAU,mKAAC,CAAC,MAAM;IAClB,OAAO,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,MAAM;IAC1B,OAAO,mKAAC,CAAC,QAAQ,CAAC,mKAAC,CAAC,MAAM;IAC1B,MAAM,mKAAC,CAAC,MAAM;IACd,gBAAgB,mKAAC,CAAC,MAAM;IACxB,qBAAqB,mKAAC,CAAC,OAAO;AAClC;AACO,eAAe,2BAA2B,GAAG,EAAE,IAAI,EAAE,kBAAkB,EAAE,MAAM;IAClF,IAAA,qNAAY,EAAC,mNAAU,CAAC,KAAK,EAAE,oCAAoC;IACnE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,EAAE,cAAc,EAAE,UAAU,UAAU,EAAE,WAAW,iBAAiB,EAAE,mBAAmB,EAAG,GAAG;IACzH,MAAM,kBAAkB,sBAAsB,YACxC,MAAM,IAAA,0NAAiB,EAAC,KAAK,qBAC7B,MAAM,IAAI,EAAE,CACT,KAAK,CAAC,gBACN,SAAS,CAAC,wBAAwB,CAAC,IAAM,EACzC,EAAE,CAAC,YAAY,YACf,EAAE,CAAC,qBAAqB,SAAS,QACjC,MAAM;IACf,MAAM,WAAW,mBAAmB,YAAY;IAChD,MAAM,EAAE,SAAS,EAAE,GAAG,MAAM,IAAA,6NAAoB,EAAC,KAAK,MAAM,IAAA,4NAAgB,EAAC,MAAM,oBAAoB,OACjG;QAAE;IAAgB,IAClB;QAAE,mBAAmB,SAAS;IAAM,GAAG,SAAS,IAAI,KAAK,UACzD;QAAE,MAAM;QAAS;QAAU,SAAS;YAAE,OAAO;QAAM;IAAE,IACrD;QAAE,MAAM;QAAS;QAAU,SAAS;YAAE,OAAO;QAAM;IAAE,GAAG;IAC9D,MAAM,+BAA+B,KAAK,WAAW,YAAY,MAAM,gBAAgB;QAAE;QAAO;IAAM;IACtG,OAAO,SAAS;AACpB;AACO,MAAM,6BAA6B,OAAO,KAAK;IAClD,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;YACN,GAAG,IAAI;QACX;IACJ;AACJ;AACA,eAAe,+BAA+B,GAAG,EAAE,SAAS,EAAE,QAAQ,EAAE,IAAI,EAAE,cAAc,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE;IAC1G,MAAM,eAAe,MAAM,IAAI,EAAE,CAC5B,KAAK,CAAC,yBACN,SAAS,CAAC,aAAa,CAAC,IAAM,EAAE,EAAE,CAAC,aAAa,YAChD,MAAM;IACX,IAAI,iBAAiB,MAAM;QACvB,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,GAAG;IACxC;IACA,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,yBAAyB;QACzC;QACA;QACA,MAAM,MAAM,IAAA,+MAAM,EAAC;QACnB;QACA,eAAe;QACf,eAAe;IACnB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2592, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/verifier.js"],"sourcesContent":["import { getAuthSessionId } from \"../sessions.js\";\nexport async function verifierImpl(ctx) {\n    return await ctx.db.insert(\"authVerifiers\", {\n        sessionId: (await getAuthSessionId(ctx)) ?? undefined,\n    });\n}\nexport const callVerifier = async (ctx) => {\n    return ctx.runMutation(\"auth:store\", {\n        args: {\n            type: \"verifier\",\n        },\n    });\n};\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;AACO,eAAe,aAAa,GAAG;IAClC,OAAO,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,iBAAiB;QACxC,WAAW,AAAC,MAAM,IAAA,4NAAgB,EAAC,QAAS;IAChD;AACJ;AACO,MAAM,eAAe,OAAO;IAC/B,OAAO,IAAI,WAAW,CAAC,cAAc;QACjC,MAAM;YACF,MAAM;QACV;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2623, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/mutations/index.js"],"sourcesContent":["import { v } from \"convex/values\";\nimport { signInArgs, signInImpl } from \"./signIn.js\";\nimport { signOutImpl } from \"./signOut.js\";\nimport { refreshSessionArgs, refreshSessionImpl } from \"./refreshSession.js\";\nimport { verifyCodeAndSignInArgs, verifyCodeAndSignInImpl, } from \"./verifyCodeAndSignIn.js\";\nimport { verifierSignatureArgs, verifierSignatureImpl, } from \"./verifierSignature.js\";\nimport { userOAuthArgs, userOAuthImpl } from \"./userOAuth.js\";\nimport { createVerificationCodeArgs, createVerificationCodeImpl, } from \"./createVerificationCode.js\";\nimport { createAccountFromCredentialsArgs, createAccountFromCredentialsImpl, } from \"./createAccountFromCredentials.js\";\nimport { retrieveAccountWithCredentialsArgs, retrieveAccountWithCredentialsImpl, } from \"./retrieveAccountWithCredentials.js\";\nimport { modifyAccountArgs, modifyAccountImpl } from \"./modifyAccount.js\";\nimport { invalidateSessionsArgs, invalidateSessionsImpl, } from \"./invalidateSessions.js\";\nimport { verifierImpl } from \"./verifier.js\";\nimport { LOG_LEVELS, logWithLevel } from \"../utils.js\";\nexport { callInvalidateSessions } from \"./invalidateSessions.js\";\nexport { callModifyAccount } from \"./modifyAccount.js\";\nexport { callRetreiveAccountWithCredentials } from \"./retrieveAccountWithCredentials.js\";\nexport { callCreateAccountFromCredentials } from \"./createAccountFromCredentials.js\";\nexport { callCreateVerificationCode } from \"./createVerificationCode.js\";\nexport { callUserOAuth } from \"./userOAuth.js\";\nexport { callVerifierSignature } from \"./verifierSignature.js\";\nexport { callVerifyCodeAndSignIn } from \"./verifyCodeAndSignIn.js\";\nexport { callVerifier } from \"./verifier.js\";\nexport { callRefreshSession } from \"./refreshSession.js\";\nexport { callSignOut } from \"./signOut.js\";\nexport { callSignIn } from \"./signIn.js\";\nexport const storeArgs = v.object({\n    args: v.union(v.object({\n        type: v.literal(\"signIn\"),\n        ...signInArgs.fields,\n    }), v.object({\n        type: v.literal(\"signOut\"),\n    }), v.object({\n        type: v.literal(\"refreshSession\"),\n        ...refreshSessionArgs.fields,\n    }), v.object({\n        type: v.literal(\"verifyCodeAndSignIn\"),\n        ...verifyCodeAndSignInArgs.fields,\n    }), v.object({\n        type: v.literal(\"verifier\"),\n    }), v.object({\n        type: v.literal(\"verifierSignature\"),\n        ...verifierSignatureArgs.fields,\n    }), v.object({\n        type: v.literal(\"userOAuth\"),\n        ...userOAuthArgs.fields,\n    }), v.object({\n        type: v.literal(\"createVerificationCode\"),\n        ...createVerificationCodeArgs.fields,\n    }), v.object({\n        type: v.literal(\"createAccountFromCredentials\"),\n        ...createAccountFromCredentialsArgs.fields,\n    }), v.object({\n        type: v.literal(\"retrieveAccountWithCredentials\"),\n        ...retrieveAccountWithCredentialsArgs.fields,\n    }), v.object({\n        type: v.literal(\"modifyAccount\"),\n        ...modifyAccountArgs.fields,\n    }), v.object({\n        type: v.literal(\"invalidateSessions\"),\n        ...invalidateSessionsArgs.fields,\n    })),\n});\nexport const storeImpl = async (ctx, fnArgs, getProviderOrThrow, config) => {\n    const args = fnArgs.args;\n    logWithLevel(LOG_LEVELS.INFO, `\\`auth:store\\` type: ${args.type}`);\n    switch (args.type) {\n        case \"signIn\": {\n            return signInImpl(ctx, args, config);\n        }\n        case \"signOut\": {\n            return signOutImpl(ctx);\n        }\n        case \"refreshSession\": {\n            return refreshSessionImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"verifyCodeAndSignIn\": {\n            return verifyCodeAndSignInImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"verifier\": {\n            return verifierImpl(ctx);\n        }\n        case \"verifierSignature\": {\n            return verifierSignatureImpl(ctx, args);\n        }\n        case \"userOAuth\": {\n            return userOAuthImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"createVerificationCode\": {\n            return createVerificationCodeImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"createAccountFromCredentials\": {\n            return createAccountFromCredentialsImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"retrieveAccountWithCredentials\": {\n            return retrieveAccountWithCredentialsImpl(ctx, args, getProviderOrThrow, config);\n        }\n        case \"modifyAccount\": {\n            return modifyAccountImpl(ctx, args, getProviderOrThrow);\n        }\n        case \"invalidateSessions\": {\n            return invalidateSessionsImpl(ctx, args);\n        }\n        default:\n            args;\n    }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2783, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/redirects.js"],"sourcesContent":["import { requireEnv } from \"../utils.js\";\nexport async function redirectAbsoluteUrl(config, params) {\n    if (params.redirectTo !== undefined) {\n        if (typeof params.redirectTo !== \"string\") {\n            throw new Error(`Expected \\`redirectTo\\` to be a string, got ${params.redirectTo}`);\n        }\n        const redirectCallback = config.callbacks?.redirect ?? defaultRedirectCallback;\n        return await redirectCallback(params);\n    }\n    return siteUrl();\n}\nasync function defaultRedirectCallback({ redirectTo }) {\n    const baseUrl = siteUrl();\n    if (redirectTo.startsWith(\"?\") || redirectTo.startsWith(\"/\")) {\n        return `${baseUrl}${redirectTo}`;\n    }\n    if (redirectTo.startsWith(baseUrl)) {\n        const after = redirectTo[baseUrl.length];\n        if (after === undefined || after === \"?\" || after === \"/\") {\n            return redirectTo;\n        }\n    }\n    throw new Error(`Invalid \\`redirectTo\\` ${redirectTo} for configured SITE_URL: ${baseUrl.toString()}`);\n}\n// Temporary work-around because Convex doesn't support\n// schemes other than http and https.\nexport function setURLSearchParam(absoluteUrl, param, value) {\n    const pattern = /([^:]+):(.*)/;\n    const [, scheme, rest] = absoluteUrl.match(pattern);\n    const hasNoDomain = /^\\/\\/(?:\\/|$|\\?)/.test(rest);\n    const startsWithPath = hasNoDomain && rest.startsWith(\"///\");\n    const url = new URL(`http:${hasNoDomain ? \"//googblibok\" + rest.slice(2) : rest}`);\n    url.searchParams.set(param, value);\n    const [, , withParam] = url.toString().match(pattern);\n    return `${scheme}:${hasNoDomain ? (startsWithPath ? \"/\" : \"\") + \"//\" + withParam.slice(13) : withParam}`;\n}\nfunction siteUrl() {\n    return requireEnv(\"SITE_URL\").replace(/\\/$/, \"\");\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,eAAe,oBAAoB,MAAM,EAAE,MAAM;IACpD,IAAI,OAAO,UAAU,KAAK,WAAW;QACjC,IAAI,OAAO,OAAO,UAAU,KAAK,UAAU;YACvC,MAAM,IAAI,MAAM,CAAC,4CAA4C,EAAE,OAAO,UAAU,EAAE;QACtF;QACA,MAAM,mBAAmB,OAAO,SAAS,EAAE,YAAY;QACvD,OAAO,MAAM,iBAAiB;IAClC;IACA,OAAO;AACX;AACA,eAAe,wBAAwB,EAAE,UAAU,EAAE;IACjD,MAAM,UAAU;IAChB,IAAI,WAAW,UAAU,CAAC,QAAQ,WAAW,UAAU,CAAC,MAAM;QAC1D,OAAO,GAAG,UAAU,YAAY;IACpC;IACA,IAAI,WAAW,UAAU,CAAC,UAAU;QAChC,MAAM,QAAQ,UAAU,CAAC,QAAQ,MAAM,CAAC;QACxC,IAAI,UAAU,aAAa,UAAU,OAAO,UAAU,KAAK;YACvD,OAAO;QACX;IACJ;IACA,MAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,WAAW,0BAA0B,EAAE,QAAQ,QAAQ,IAAI;AACzG;AAGO,SAAS,kBAAkB,WAAW,EAAE,KAAK,EAAE,KAAK;IACvD,MAAM,UAAU;IAChB,MAAM,GAAG,QAAQ,KAAK,GAAG,YAAY,KAAK,CAAC;IAC3C,MAAM,cAAc,mBAAmB,IAAI,CAAC;IAC5C,MAAM,iBAAiB,eAAe,KAAK,UAAU,CAAC;IACtD,MAAM,MAAM,IAAI,IAAI,CAAC,KAAK,EAAE,cAAc,iBAAiB,KAAK,KAAK,CAAC,KAAK,MAAM;IACjF,IAAI,YAAY,CAAC,GAAG,CAAC,OAAO;IAC5B,MAAM,KAAK,UAAU,GAAG,IAAI,QAAQ,GAAG,KAAK,CAAC;IAC7C,OAAO,GAAG,OAAO,CAAC,EAAE,cAAc,CAAC,iBAAiB,MAAM,EAAE,IAAI,OAAO,UAAU,KAAK,CAAC,MAAM,WAAW;AAC5G;AACA,SAAS;IACL,OAAO,IAAA,iMAAU,EAAC,YAAY,OAAO,CAAC,OAAO;AACjD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2833, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/signIn.js"],"sourcesContent":["import { callCreateVerificationCode, callRefreshSession, callSignIn, callVerifier, callVerifyCodeAndSignIn, } from \"./mutations/index.js\";\nimport { alphabet, generateRandomString } from \"oslo/crypto\";\nimport { redirectAbsoluteUrl, setURLSearchParam } from \"./redirects.js\";\nimport { requireEnv } from \"../utils.js\";\nconst DEFAULT_EMAIL_VERIFICATION_CODE_DURATION_S = 60 * 60 * 24; // 24 hours\nexport async function signInImpl(ctx, provider, args, options) {\n    if (provider === null && args.refreshToken) {\n        const tokens = (await callRefreshSession(ctx, {\n            refreshToken: args.refreshToken,\n        }));\n        return { kind: \"refreshTokens\", signedIn: { tokens } };\n    }\n    if (provider === null && args.params?.code !== undefined) {\n        const result = await callVerifyCodeAndSignIn(ctx, {\n            params: args.params,\n            verifier: args.verifier,\n            generateTokens: true,\n            allowExtraProviders: options.allowExtraProviders,\n        });\n        return {\n            kind: \"signedIn\",\n            signedIn: result,\n        };\n    }\n    if (provider === null) {\n        throw new Error(\"Cannot sign in: Missing `provider`, `params.code` or `refreshToken`\");\n    }\n    if (provider.type === \"email\" || provider.type === \"phone\") {\n        return handleEmailAndPhoneProvider(ctx, provider, args, options);\n    }\n    if (provider.type === \"credentials\") {\n        return handleCredentials(ctx, provider, args, options);\n    }\n    if (provider.type === \"oauth\" || provider.type === \"oidc\") {\n        return handleOAuthProvider(ctx, provider, args, options);\n    }\n    const _typecheck = provider;\n    throw new Error(`Provider type ${provider.type} is not supported yet`);\n}\nasync function handleEmailAndPhoneProvider(ctx, provider, args, options) {\n    if (args.params?.code !== undefined) {\n        const result = await callVerifyCodeAndSignIn(ctx, {\n            params: args.params,\n            provider: provider.id,\n            generateTokens: options.generateTokens,\n            allowExtraProviders: options.allowExtraProviders,\n        });\n        if (result === null) {\n            throw new Error(\"Could not verify code\");\n        }\n        return {\n            kind: \"signedIn\",\n            signedIn: result,\n        };\n    }\n    const code = provider.generateVerificationToken\n        ? await provider.generateVerificationToken()\n        : generateRandomString(32, alphabet(\"0-9\", \"A-Z\", \"a-z\"));\n    const expirationTime = Date.now() +\n        (provider.maxAge ?? DEFAULT_EMAIL_VERIFICATION_CODE_DURATION_S) * 1000;\n    const identifier = await callCreateVerificationCode(ctx, {\n        provider: provider.id,\n        accountId: args.accountId,\n        email: args.params?.email,\n        phone: args.params?.phone,\n        code,\n        expirationTime,\n        allowExtraProviders: options.allowExtraProviders,\n    });\n    const destination = await redirectAbsoluteUrl(ctx.auth.config, (args.params ?? {}));\n    const verificationArgs = {\n        identifier,\n        url: setURLSearchParam(destination, \"code\", code),\n        token: code,\n        expires: new Date(expirationTime),\n    };\n    if (provider.type === \"email\") {\n        await provider.sendVerificationRequest({\n            ...verificationArgs,\n            provider: {\n                ...provider,\n                from: \n                // Simplifies demo configuration of Resend\n                provider.from === \"Auth.js <no-reply@authjs.dev>\" &&\n                    provider.id === \"resend\"\n                    ? \"My App <onboarding@resend.dev>\"\n                    : provider.from,\n            },\n            request: new Request(\"http://localhost\"), // TODO: Document\n            theme: ctx.auth.config.theme,\n        }, \n        // @ts-expect-error Figure out typing for email providers so they can\n        // access ctx.\n        ctx);\n    }\n    else if (provider.type === \"phone\") {\n        await provider.sendVerificationRequest({ ...verificationArgs, provider }, ctx);\n    }\n    return { kind: \"started\", started: true };\n}\nasync function handleCredentials(ctx, provider, args, options) {\n    const result = await provider.authorize(args.params ?? {}, ctx);\n    if (result === null) {\n        return { kind: \"signedIn\", signedIn: null };\n    }\n    const idsAndTokens = await callSignIn(ctx, {\n        userId: result.userId,\n        sessionId: result.sessionId,\n        generateTokens: options.generateTokens,\n    });\n    return {\n        kind: \"signedIn\",\n        signedIn: idsAndTokens,\n    };\n}\nasync function handleOAuthProvider(ctx, provider, args, options) {\n    // We have this action because:\n    // 1. We remember the current sessionId if any, so we can link accounts\n    // 2. The client doesn't need to know the HTTP Actions URL\n    //    of the backend (this simplifies using local backend)\n    // 3. The client doesn't need to know which provider is of which type,\n    //    and hence which provider requires client-side redirect\n    // 4. On mobile the client can complete the flow manually\n    if (args.params?.code !== undefined) {\n        const result = await callVerifyCodeAndSignIn(ctx, {\n            params: args.params,\n            verifier: args.verifier,\n            generateTokens: true,\n            allowExtraProviders: options.allowExtraProviders,\n        });\n        return {\n            kind: \"signedIn\",\n            signedIn: result,\n        };\n    }\n    const redirect = new URL(requireEnv(\"CONVEX_SITE_URL\") + `/api/auth/signin/${provider.id}`);\n    const verifier = await callVerifier(ctx);\n    redirect.searchParams.set(\"code\", verifier);\n    if (args.params?.redirectTo !== undefined) {\n        if (typeof args.params.redirectTo !== \"string\") {\n            throw new Error(`Expected \\`redirectTo\\` to be a string, got ${args.params.redirectTo}`);\n        }\n        redirect.searchParams.set(\"redirectTo\", args.params.redirectTo);\n    }\n    return { kind: \"redirect\", redirect: redirect.toString(), verifier };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3016, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/server/implementation/index.js"],"sourcesContent":["import { actionGeneric, httpActionGeneric, internalMutationGeneric, } from \"convex/server\";\nimport { ConvexError, v } from \"convex/values\";\nimport { parse as parseCookies, serialize as serializeCookie } from \"cookie\";\nimport { redirectToParamCookie, useRedirectToParam } from \"../checks.js\";\nimport { getAuthorizationURL, handleOAuthCallback } from \"../oauth.js\";\nimport { configDefaults, listAvailableProviders, materializeProvider, } from \"../provider_utils.js\";\nimport { requireEnv } from \"../utils.js\";\nexport { authTables } from \"./types.js\";\nimport { LOG_LEVELS, TOKEN_SUB_CLAIM_DIVIDER, logError, logWithLevel, } from \"./utils.js\";\nimport { callCreateAccountFromCredentials, callInvalidateSessions, callModifyAccount, callRetreiveAccountWithCredentials, callSignOut, callUserOAuth, callVerifierSignature, storeArgs, storeImpl, } from \"./mutations/index.js\";\nimport { signInImpl } from \"./signIn.js\";\nimport { redirectAbsoluteUrl, setURLSearchParam } from \"./redirects.js\";\nexport { getAuthSessionId } from \"./sessions.js\";\n/**\n * Configure the Convex Auth library. Returns an object with\n * functions and `auth` helper. You must export the functions\n * from `convex/auth.ts` to make them callable:\n *\n * ```ts filename=\"convex/auth.ts\"\n * import { convexAuth } from \"@convex-dev/auth/server\";\n *\n * export const { auth, signIn, signOut, store } = convexAuth({\n *   providers: [],\n * });\n * ```\n *\n * @returns An object with fields you should reexport from your\n *          `convex/auth.ts` file.\n */\nexport function convexAuth(config_) {\n    const config = configDefaults(config_);\n    const hasOAuth = config.providers.some((provider) => provider.type === \"oauth\" || provider.type === \"oidc\");\n    const getProvider = (id, allowExtraProviders = false) => {\n        return (config.providers.find((provider) => provider.id === id) ??\n            (allowExtraProviders\n                ? config.extraProviders.find((provider) => provider.id === id)\n                : undefined));\n    };\n    const getProviderOrThrow = (id, allowExtraProviders = false) => {\n        const provider = getProvider(id, allowExtraProviders);\n        if (provider === undefined) {\n            const message = `Provider \\`${id}\\` is not configured, ` +\n                `available providers are ${listAvailableProviders(config, allowExtraProviders)}.`;\n            logWithLevel(LOG_LEVELS.ERROR, message);\n            throw new Error(message);\n        }\n        return provider;\n    };\n    const enrichCtx = (ctx) => ({ ...ctx, auth: { ...ctx.auth, config } });\n    const auth = {\n        /**\n         * @deprecated - Use `getAuthUserId` from \"@convex-dev/auth/server\":\n         *\n         * ```ts\n         * import { getAuthUserId } from \"@convex-dev/auth/server\";\n         * ```\n         *\n         * @hidden\n         */\n        getUserId: async (ctx) => {\n            const identity = await ctx.auth.getUserIdentity();\n            if (identity === null) {\n                return null;\n            }\n            const [userId] = identity.subject.split(TOKEN_SUB_CLAIM_DIVIDER);\n            return userId;\n        },\n        /**\n         * @deprecated - Use `getAuthSessionId` from \"@convex-dev/auth/server\":\n         *\n         * ```\n         * import { getAuthSessionId } from \"@convex-dev/auth/server\";\n         * ```\n         *\n         * @hidden\n         */\n        getSessionId: async (ctx) => {\n            const identity = await ctx.auth.getUserIdentity();\n            if (identity === null) {\n                return null;\n            }\n            const [, sessionId] = identity.subject.split(TOKEN_SUB_CLAIM_DIVIDER);\n            return sessionId;\n        },\n        /**\n         * Add HTTP actions for JWT verification and OAuth sign-in.\n         *\n         * ```ts\n         * import { httpRouter } from \"convex/server\";\n         * import { auth } from \"./auth.js\";\n         *\n         * const http = httpRouter();\n         *\n         * auth.addHttpRoutes(http);\n         *\n         * export default http;\n         * ```\n         *\n         * The following routes are handled always:\n         *\n         * - `/.well-known/openid-configuration`\n         * - `/.well-known/jwks.json`\n         *\n         * The following routes are handled if OAuth is configured:\n         *\n         * - `/api/auth/signin/*`\n         * - `/api/auth/callback/*`\n         *\n         * @param http your HTTP router\n         */\n        addHttpRoutes: (http) => {\n            http.route({\n                path: \"/.well-known/openid-configuration\",\n                method: \"GET\",\n                handler: httpActionGeneric(async () => {\n                    return new Response(JSON.stringify({\n                        issuer: requireEnv(\"CONVEX_SITE_URL\"),\n                        jwks_uri: requireEnv(\"CONVEX_SITE_URL\") + \"/.well-known/jwks.json\",\n                        authorization_endpoint: requireEnv(\"CONVEX_SITE_URL\") + \"/oauth/authorize\",\n                    }), {\n                        status: 200,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            \"Cache-Control\": \"public, max-age=15, stale-while-revalidate=15, stale-if-error=86400\",\n                        },\n                    });\n                }),\n            });\n            http.route({\n                path: \"/.well-known/jwks.json\",\n                method: \"GET\",\n                handler: httpActionGeneric(async () => {\n                    return new Response(requireEnv(\"JWKS\"), {\n                        status: 200,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            \"Cache-Control\": \"public, max-age=15, stale-while-revalidate=15, stale-if-error=86400\",\n                        },\n                    });\n                }),\n            });\n            if (hasOAuth) {\n                http.route({\n                    pathPrefix: \"/api/auth/signin/\",\n                    method: \"GET\",\n                    handler: httpActionGeneric(convertErrorsToResponse(400, async (ctx, request) => {\n                        const url = new URL(request.url);\n                        const pathParts = url.pathname.split(\"/\");\n                        const providerId = pathParts.at(-1);\n                        if (providerId === null) {\n                            throw new Error(\"Missing provider id\");\n                        }\n                        const verifier = url.searchParams.get(\"code\");\n                        if (verifier === null) {\n                            throw new Error(\"Missing sign-in verifier\");\n                        }\n                        const provider = getProviderOrThrow(providerId);\n                        const { redirect, cookies, signature } = await getAuthorizationURL(provider);\n                        await callVerifierSignature(ctx, {\n                            verifier,\n                            signature,\n                        });\n                        const redirectTo = url.searchParams.get(\"redirectTo\");\n                        if (redirectTo !== null) {\n                            cookies.push(redirectToParamCookie(providerId, redirectTo));\n                        }\n                        const headers = new Headers({ Location: redirect });\n                        for (const { name, value, options } of cookies) {\n                            headers.append(\"Set-Cookie\", serializeCookie(name, value, options));\n                        }\n                        return new Response(null, { status: 302, headers });\n                    })),\n                });\n                const callbackAction = httpActionGeneric(async (genericCtx, request) => {\n                    const ctx = genericCtx;\n                    const url = new URL(request.url);\n                    const pathParts = url.pathname.split(\"/\");\n                    const providerId = pathParts.at(-1);\n                    logWithLevel(LOG_LEVELS.DEBUG, \"Handling OAuth callback for provider:\", providerId);\n                    const provider = getProviderOrThrow(providerId);\n                    const cookies = getCookies(request);\n                    const maybeRedirectTo = useRedirectToParam(provider.id, cookies);\n                    const destinationUrl = await redirectAbsoluteUrl(config, {\n                        redirectTo: maybeRedirectTo?.redirectTo,\n                    });\n                    try {\n                        const { profile, tokens, signature } = await handleOAuthCallback(provider, request, cookies);\n                        const { id, ...profileFromCallback } = await provider.profile(profile, tokens);\n                        if (typeof id !== \"string\") {\n                            throw new Error(`The profile method of the ${providerId} config must return a string ID`);\n                        }\n                        const verificationCode = await callUserOAuth(ctx, {\n                            provider: providerId,\n                            providerAccountId: id,\n                            profile: profileFromCallback,\n                            signature,\n                        });\n                        return new Response(null, {\n                            status: 302,\n                            headers: {\n                                Location: setURLSearchParam(destinationUrl, \"code\", verificationCode),\n                                \"Cache-Control\": \"must-revalidate\",\n                            },\n                        });\n                    }\n                    catch (error) {\n                        logError(error);\n                        return Response.redirect(destinationUrl);\n                    }\n                });\n                http.route({\n                    pathPrefix: \"/api/auth/callback/\",\n                    method: \"GET\",\n                    handler: callbackAction,\n                });\n                http.route({\n                    pathPrefix: \"/api/auth/callback/\",\n                    method: \"POST\",\n                    handler: callbackAction,\n                });\n            }\n        },\n    };\n    return {\n        /**\n         * Helper for configuring HTTP actions.\n         */\n        auth,\n        /**\n         * Action called by the client to sign the user in.\n         *\n         * Also used for refreshing the session.\n         */\n        signIn: actionGeneric({\n            args: {\n                provider: v.optional(v.string()),\n                params: v.optional(v.any()),\n                verifier: v.optional(v.string()),\n                refreshToken: v.optional(v.string()),\n            },\n            handler: async (ctx, args) => {\n                const provider = args.provider !== undefined\n                    ? getProviderOrThrow(args.provider)\n                    : null;\n                const result = await signInImpl(enrichCtx(ctx), provider, args, {\n                    generateTokens: true,\n                    allowExtraProviders: false,\n                });\n                switch (result.kind) {\n                    case \"redirect\":\n                        return { redirect: result.redirect, verifier: result.verifier };\n                    case \"signedIn\":\n                    case \"refreshTokens\":\n                        return { tokens: result.signedIn?.tokens ?? null };\n                    case \"started\":\n                        return { started: true };\n                    default: {\n                        const _typecheck = result;\n                        throw new Error(`Unexpected result from signIn, ${result}`);\n                    }\n                }\n            },\n        }),\n        /**\n         * Action called by the client to invalidate the current session.\n         */\n        signOut: actionGeneric({\n            args: {},\n            handler: async (ctx) => {\n                await callSignOut(ctx);\n            },\n        }),\n        /**\n         * Internal mutation used by the library to read and write\n         * to the database during signin and signout.\n         */\n        store: internalMutationGeneric({\n            args: storeArgs,\n            handler: async (ctx, args) => {\n                return storeImpl(ctx, args, getProviderOrThrow, config);\n            },\n        }),\n    };\n}\n/**\n * Return the currently signed-in user's ID.\n *\n * ```ts filename=\"convex/myFunctions.tsx\"\n * import { mutation } from \"./_generated/server\";\n * import { getAuthUserId } from \"@convex-dev/auth/server\";\n *\n * export const doSomething = mutation({\n *   args: {/* ... *\\/},\n *   handler: async (ctx, args) => {\n *     const userId = await getAuthUserId(ctx);\n *     if (userId === null) {\n *       throw new Error(\"Client is not authenticated!\")\n *     }\n *     const user = await ctx.db.get(userId);\n *     // ...\n *   },\n * });\n * ```\n *\n * @param ctx query, mutation or action `ctx`\n * @returns the user ID or `null` if the client isn't authenticated\n */\nexport async function getAuthUserId(ctx) {\n    const identity = await ctx.auth.getUserIdentity();\n    if (identity === null) {\n        return null;\n    }\n    const [userId] = identity.subject.split(TOKEN_SUB_CLAIM_DIVIDER);\n    return userId;\n}\n/**\n * Use this function from a\n * [`ConvexCredentials`](https://labs.convex.dev/auth/api_reference/providers/ConvexCredentials)\n * provider to create an account and a user with a unique account \"id\" (OAuth\n * provider ID, email address, phone number, username etc.).\n *\n * @returns user ID if it successfully creates the account\n * or throws an error.\n */\nexport async function createAccount(ctx, args) {\n    const actionCtx = ctx;\n    return await callCreateAccountFromCredentials(actionCtx, args);\n}\n/**\n * Use this function from a\n * [`ConvexCredentials`](https://labs.convex.dev/auth/api_reference/providers/ConvexCredentials)\n * provider to retrieve a user given the account provider ID and\n * the provider-specific account ID.\n *\n * @returns the retrieved user document, or `null` if there is no account\n * for given account ID or throws if the provided\n * secret does not match.\n */\nexport async function retrieveAccount(ctx, args) {\n    const actionCtx = ctx;\n    const result = await callRetreiveAccountWithCredentials(actionCtx, args);\n    if (typeof result === \"string\") {\n        throw new Error(result);\n    }\n    return result;\n}\n/**\n * Use this function to modify the account credentials\n * from a [`ConvexCredentials`](https://labs.convex.dev/auth/api_reference/providers/ConvexCredentials)\n * provider.\n */\nexport async function modifyAccountCredentials(ctx, args) {\n    const actionCtx = ctx;\n    return await callModifyAccount(actionCtx, args);\n}\n/**\n * Use this function to invalidate existing sessions.\n */\nexport async function invalidateSessions(ctx, args) {\n    const actionCtx = ctx;\n    return await callInvalidateSessions(actionCtx, args);\n}\n/**\n * Use this function from a\n * [`ConvexCredentials`](https://labs.convex.dev/auth/api_reference/providers/ConvexCredentials)\n * provider to sign in the user via another provider (usually\n * for email verification on sign up or password reset).\n *\n * Returns the user ID if the sign can proceed,\n * or `null`.\n */\nexport async function signInViaProvider(ctx, provider, args) {\n    const result = await signInImpl(ctx, materializeProvider(provider), args, {\n        generateTokens: false,\n        allowExtraProviders: true,\n    });\n    return result.kind === \"signedIn\"\n        ? result.signedIn !== null\n            ? { userId: result.signedIn.userId, sessionId: result.signedIn.sessionId }\n            : null\n        : null;\n}\nfunction convertErrorsToResponse(errorStatusCode, action) {\n    return async (ctx, request) => {\n        try {\n            return await action(ctx, request);\n        }\n        catch (error) {\n            if (error instanceof ConvexError) {\n                return new Response(null, {\n                    status: errorStatusCode,\n                    statusText: error.data,\n                });\n            }\n            else {\n                logError(error);\n                return new Response(null, {\n                    status: 500,\n                    statusText: \"Internal Server Error\",\n                });\n            }\n        }\n    };\n}\nfunction getCookies(request) {\n    return parseCookies(request.headers.get(\"Cookie\") ?? \"\");\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3405, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/providers/ConvexCredentials.js"],"sourcesContent":["/**\n * Configure {@link ConvexCredentials} provider given a {@link ConvexCredentialsUserConfig}.\n *\n * This is for a very custom authentication implementation, often you can\n * use the [`Password`](https://labs.convex.dev/auth/api_reference/providers/Password) provider instead.\n *\n * ```ts\n * import ConvexCredentials from \"@convex-dev/auth/providers/ConvexCredentials\";\n * import { convexAuth } from \"@convex-dev/auth/server\";\n *\n * export const { auth, signIn, signOut, store } = convexAuth({\n *   providers: [\n *     ConvexCredentials({\n *       authorize: async (credentials, ctx) => {\n *         // Your custom logic here...\n *       },\n *     }),\n *   ],\n * });\n * ```\n *\n * @module\n */\n/**\n * The Credentials provider allows you to handle signing in with arbitrary credentials,\n * such as a username and password, domain, or two factor authentication or hardware device (e.g. YubiKey U2F / FIDO).\n */\nexport function ConvexCredentials(config) {\n    return {\n        id: \"credentials\",\n        type: \"credentials\",\n        authorize: async () => null,\n        // @ts-expect-error Internal\n        options: config,\n    };\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD;;;CAGC;;;;AACM,SAAS,kBAAkB,MAAM;IACpC,OAAO;QACH,IAAI;QACJ,MAAM;QACN,WAAW,UAAY;QACvB,4BAA4B;QAC5B,SAAS;IACb;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3449, "column": 0}, "map": {"version":3,"sources":["file:///Users/itwelaibomu/Desktop/code/agents-2025-dope/apps/web/node_modules/%40convex-dev/auth/dist/providers/Password.js"],"sourcesContent":["/**\n * Configure {@link Password} provider given a {@link PasswordConfig}.\n *\n * The `Password` provider supports the following flows, determined\n * by the `flow` parameter:\n *\n * - `\"signUp\"`: Create a new account with a password.\n * - `\"signIn\"`: Sign in with an existing account and password.\n * - `\"reset\"`: Request a password reset.\n * - `\"reset-verification\"`: Verify a password reset code and change password.\n * - `\"email-verification\"`: If email verification is enabled and `code` is\n *    included in params, verify an OTP.\n *\n * ```ts\n * import Password from \"@convex-dev/auth/providers/Password\";\n * import { convexAuth } from \"@convex-dev/auth/server\";\n *\n * export const { auth, signIn, signOut, store } = convexAuth({\n *   providers: [Password],\n * });\n * ```\n *\n * @module\n */\nimport { ConvexCredentials, } from \"@convex-dev/auth/providers/ConvexCredentials\";\nimport { createAccount, invalidateSessions, modifyAccountCredentials, retrieveAccount, signInViaProvider, } from \"@convex-dev/auth/server\";\nimport { Scrypt } from \"lucia\";\n/**\n * Email and password authentication provider.\n *\n * Passwords are by default hashed using Scrypt from Lucia.\n * You can customize the hashing via the `crypto` option.\n *\n * Email verification is not required unless you pass\n * an email provider to the `verify` option.\n */\nexport function Password(config = {}) {\n    const provider = config.id ?? \"password\";\n    return ConvexCredentials({\n        id: \"password\",\n        authorize: async (params, ctx) => {\n            const profile = config.profile?.(params, ctx) ?? defaultProfile(params);\n            const { email } = profile;\n            const flow = params.flow;\n            const secret = params.password;\n            let account;\n            let user;\n            if (flow === \"signUp\") {\n                if (secret === undefined) {\n                    throw new Error(\"Missing `password` param for `signUp` flow\");\n                }\n                const created = await createAccount(ctx, {\n                    provider,\n                    account: { id: email, secret },\n                    profile: profile,\n                    shouldLinkViaEmail: config.verify !== undefined,\n                    shouldLinkViaPhone: false,\n                });\n                ({ account, user } = created);\n            }\n            else if (flow === \"signIn\") {\n                if (secret === undefined) {\n                    throw new Error(\"Missing `password` param for `signIn` flow\");\n                }\n                const retrieved = await retrieveAccount(ctx, {\n                    provider,\n                    account: { id: email, secret },\n                });\n                if (retrieved === null) {\n                    throw new Error(\"Invalid credentials\");\n                }\n                ({ account, user } = retrieved);\n                // START: Optional, support password reset\n            }\n            else if (flow === \"reset\") {\n                if (!config.reset) {\n                    throw new Error(`Password reset is not enabled for ${provider}`);\n                }\n                const { account } = await retrieveAccount(ctx, {\n                    provider,\n                    account: { id: email },\n                });\n                return await signInViaProvider(ctx, config.reset, {\n                    accountId: account._id,\n                    params,\n                });\n            }\n            else if (flow === \"reset-verification\") {\n                if (!config.reset) {\n                    throw new Error(`Password reset is not enabled for ${provider}`);\n                }\n                if (params.newPassword === undefined) {\n                    throw new Error(\"Missing `newPassword` param for `reset-verification` flow\");\n                }\n                const result = await signInViaProvider(ctx, config.reset, { params });\n                if (result === null) {\n                    throw new Error(\"Invalid code\");\n                }\n                const { userId, sessionId } = result;\n                const secret = params.newPassword;\n                await modifyAccountCredentials(ctx, {\n                    provider,\n                    account: { id: email, secret },\n                });\n                await invalidateSessions(ctx, { userId, except: [sessionId] });\n                return { userId, sessionId };\n                // END\n                // START: Optional, email verification during sign in\n            }\n            else if (flow === \"email-verification\") {\n                if (!config.verify) {\n                    throw new Error(`Email verification is not enabled for ${provider}`);\n                }\n                const { account } = await retrieveAccount(ctx, {\n                    provider,\n                    account: { id: email },\n                });\n                return await signInViaProvider(ctx, config.verify, {\n                    accountId: account._id,\n                    params,\n                });\n                // END\n            }\n            else {\n                throw new Error(\"Missing `flow` param, it must be one of \" +\n                    '\"signUp\", \"signIn\", \"reset\", \"reset-verification\" or ' +\n                    '\"email-verification\"!');\n            }\n            // START: Optional, email verification during sign in\n            if (config.verify && !account.emailVerified) {\n                return await signInViaProvider(ctx, config.verify, {\n                    accountId: account._id,\n                    params,\n                });\n            }\n            // END\n            return { userId: user._id };\n        },\n        crypto: {\n            async hashSecret(password) {\n                return await new Scrypt().hash(password);\n            },\n            async verifySecret(password, hash) {\n                return await new Scrypt().verify(hash, password);\n            },\n        },\n        extraProviders: [config.reset, config.verify],\n        ...config,\n    });\n}\nfunction defaultProfile(params) {\n    const flow = params.flow;\n    if (flow === \"signUp\" || flow === \"reset-verification\") {\n        const password = (flow === \"signUp\" ? params.password : params.newPassword);\n        if (!password || password.length < 8) {\n            throw new Error(\"Invalid password\");\n        }\n    }\n    return {\n        email: params.email,\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}