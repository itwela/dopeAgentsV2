import { jsx as _jsx } from "react/jsx-runtime";
import "server-only";
import { NextResponse, } from "next/server";
import { ConvexAuthNextjsClientProvider, } from "../client.js";
import { getRequestCookies } from "./cookies.js";
import { proxyAuthActionToConvex, shouldProxyAuthAction } from "./proxy.js";
import { handleAuthenticationInRequest } from "./request.js";
import { logVerbose, setAuthCookies, setAuthCookiesInMiddleware, } from "./utils.js";
/**
 * Wrap your app with this provider in your root `layout.tsx`.
 */
export function ConvexAuthNextjsServerProvider(props) {
    const { apiRoute, storage, storageNamespace, verbose, children } = props;
    return (_jsx(ConvexAuthNextjsClientProvider, { serverState: convexAuthNextjsServerState(), apiRoute: apiRoute, storage: storage, storageNamespace: storageNamespace, verbose: verbose, children: children }));
}
/**
 * Retrieve the token for authenticating calls to your
 * Convex backend from Server Components, Server Actions and Route Handlers.
 * @returns The token if the the client is authenticated, otherwise `undefined`.
 */
export function convexAuthNextjsToken() {
    return getRequestCookies().token ?? undefined;
}
/**
 * Whether the client is authenticated, which you can check
 * in Server Actions, Route Handlers and Middleware.
 *
 * Avoid the pitfall of checking authentication state in layouts,
 * since they won't stop nested pages from rendering.
 */
export function isAuthenticatedNextjs() {
    return convexAuthNextjsToken() !== undefined;
}
/**
 * Use in your `middleware.ts` to enable your Next.js app to use
 * Convex Auth for authentication on the server.
 *
 * @returns A Next.js middleware.
 */
export function convexAuthNextjsMiddleware(
/**
 * A custom handler, which you can use to decide
 * which routes should be accessible based on the client's authentication.
 */
handler, options = {}) {
    return async (request, event) => {
        const verbose = options.verbose ?? false;
        logVerbose(`Begin middleware for request with URL ${request.url}`, verbose);
        const requestUrl = new URL(request.url);
        // Proxy signIn and signOut actions to Convex backend
        const apiRoute = options?.apiRoute ?? "/api/auth";
        if (shouldProxyAuthAction(request, apiRoute)) {
            logVerbose(`Proxying auth action to Convex, path matches ${apiRoute} with or without trailing slash`, verbose);
            return await proxyAuthActionToConvex(request, options);
        }
        logVerbose(`Not proxying auth action to Convex, path ${requestUrl.pathname} does not match ${apiRoute}`, verbose);
        // Refresh tokens, handle code query param
        const authResult = await handleAuthenticationInRequest(request, verbose);
        // If redirecting, proceed, the middleware will run again on next request
        if (authResult.kind === "redirect") {
            logVerbose(`Redirecting to ${authResult.response.headers.get("Location")}`, verbose);
            return authResult.response;
        }
        let response = null;
        // Forward cookies to request for custom handler
        if (authResult.kind === "refreshTokens" &&
            authResult.refreshTokens !== undefined) {
            logVerbose(`Forwarding cookies to request`, verbose);
            setAuthCookiesInMiddleware(request, authResult.refreshTokens);
        }
        if (handler === undefined) {
            logVerbose(`No custom handler`, verbose);
            response = NextResponse.next();
        }
        else {
            // Call the custom handler
            logVerbose(`Calling custom handler`, verbose);
            response = (await handler(request, event)) ?? NextResponse.next();
        }
        // Port the cookies from the auth middleware to the response
        if (authResult.kind === "refreshTokens" &&
            authResult.refreshTokens !== undefined) {
            response.headers.getSetCookie();
            setAuthCookies(NextResponse.next(response), authResult.refreshTokens);
        }
        return response;
    };
}
export { createRouteMatcher } from "./routeMatcher.js";
/**
 * Helper for redirecting to a different route from
 * a Next.js middleware.
 *
 * ```ts
 * return nextjsMiddlewareRedirect(request, "/login");
 * ```
 */
export function nextjsMiddlewareRedirect(
/**
 * The incoming request handled by the middleware.
 */
request, 
/**
 * The route path to redirect to.
 */
pathname) {
    const url = request.nextUrl.clone();
    url.pathname = pathname;
    return NextResponse.redirect(url);
}
function convexAuthNextjsServerState() {
    const { token } = getRequestCookies();
    return {
        // The server doesn't share the refresh token with the client
        // for added security - the client has to use the server
        // to refresh the access token via cookies.
        _state: { token, refreshToken: "dummy" },
        _timeFetched: Date.now(),
    };
}
